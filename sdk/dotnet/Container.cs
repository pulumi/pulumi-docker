// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Docker
{
    /// <summary>
    /// Manages the lifecycle of a Docker container.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-docker/blob/master/website/docs/r/container.html.markdown.
    /// </summary>
    public partial class Container : Pulumi.CustomResource
    {
        /// <summary>
        /// If true attach to the container after its creation and waits the end of his execution.
        /// </summary>
        [Output("attach")]
        public Output<bool?> Attach { get; private set; } = null!;

        /// <summary>
        /// The network bridge of the container as read from its NetworkSettings.
        /// </summary>
        [Output("bridge")]
        public Output<string> Bridge { get; private set; } = null!;

        /// <summary>
        /// See Capabilities below for details.
        /// </summary>
        [Output("capabilities")]
        public Output<Outputs.ContainerCapabilities?> Capabilities { get; private set; } = null!;

        /// <summary>
        /// The command to use to start the
        /// container. For example, to run `/usr/bin/myprogram -f baz.conf` set the
        /// command to be `["/usr/bin/myprogram", "-f", "baz.conf"]`.
        /// </summary>
        [Output("command")]
        public Output<ImmutableArray<string>> Command { get; private set; } = null!;

        /// <summary>
        /// The logs of the container if its execution is done (`attach` must be disabled).
        /// </summary>
        [Output("containerLogs")]
        public Output<string> ContainerLogs { get; private set; } = null!;

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Output("cpuSet")]
        public Output<string?> CpuSet { get; private set; } = null!;

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Output("cpuShares")]
        public Output<int?> CpuShares { get; private set; } = null!;

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Output("destroyGraceSeconds")]
        public Output<int?> DestroyGraceSeconds { get; private set; } = null!;

        /// <summary>
        /// See Devices below for details.
        /// </summary>
        [Output("devices")]
        public Output<ImmutableArray<Outputs.ContainerDevices>> Devices { get; private set; } = null!;

        /// <summary>
        /// Set of DNS servers.
        /// </summary>
        [Output("dns")]
        public Output<ImmutableArray<string>> Dns { get; private set; } = null!;

        /// <summary>
        /// Set of DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        [Output("dnsOpts")]
        public Output<ImmutableArray<string>> DnsOpts { get; private set; } = null!;

        /// <summary>
        /// Set of DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        [Output("dnsSearches")]
        public Output<ImmutableArray<string>> DnsSearches { get; private set; } = null!;

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Output("domainname")]
        public Output<string?> Domainname { get; private set; } = null!;

        /// <summary>
        /// The command to use as the
        /// Entrypoint for the container. The Entrypoint allows you to configure a
        /// container to run as an executable. For example, to run `/usr/bin/myprogram`
        /// when starting a container, set the entrypoint to be
        /// `["/usr/bin/myprogram"]`.
        /// </summary>
        [Output("entrypoints")]
        public Output<ImmutableArray<string>> Entrypoints { get; private set; } = null!;

        /// <summary>
        /// Environment variables to set.
        /// </summary>
        [Output("envs")]
        public Output<ImmutableArray<string>> Envs { get; private set; } = null!;

        /// <summary>
        /// The exit code of the container if its execution is done (`must_run` must be disabled).
        /// </summary>
        [Output("exitCode")]
        public Output<int> ExitCode { get; private set; } = null!;

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The network gateway of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Output("gateway")]
        public Output<string> Gateway { get; private set; } = null!;

        /// <summary>
        /// Add additional groups to run as.
        /// </summary>
        [Output("groupAdds")]
        public Output<ImmutableArray<string>> GroupAdds { get; private set; } = null!;

        /// <summary>
        /// See Healthcheck below for details.
        /// </summary>
        [Output("healthcheck")]
        public Output<Outputs.ContainerHealthcheck?> Healthcheck { get; private set; } = null!;

        /// <summary>
        /// Hostname to add.
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<Outputs.ContainerHosts>> Hosts { get; private set; } = null!;

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Output("hostname")]
        public Output<string?> Hostname { get; private set; } = null!;

        /// <summary>
        /// The ID of the image to back this container.
        /// The easiest way to get this value is to use the `docker..RemoteImage` resource
        /// as is shown in the example above.
        /// </summary>
        [Output("image")]
        public Output<string> Image { get; private set; } = null!;

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP address of the container's first network it.
        /// </summary>
        [Output("ipAddress")]
        public Output<string> IpAddress { get; private set; } = null!;

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP prefix length of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Output("ipPrefixLength")]
        public Output<int> IpPrefixLength { get; private set; } = null!;

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Output("ipcMode")]
        public Output<string?> IpcMode { get; private set; } = null!;

        /// <summary>
        /// Adding labels.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, object>?> Labels { get; private set; } = null!;

        /// <summary>
        /// Set of links for link based
        /// connectivity between containers that are running on the same host.
        /// </summary>
        [Output("links")]
        public Output<ImmutableArray<string>> Links { get; private set; } = null!;

        /// <summary>
        /// The logging driver to use for the container.
        /// Defaults to "json-file".
        /// </summary>
        [Output("logDriver")]
        public Output<string?> LogDriver { get; private set; } = null!;

        /// <summary>
        /// Key/value pairs to use as options for
        /// the logging driver.
        /// </summary>
        [Output("logOpts")]
        public Output<ImmutableDictionary<string, object>?> LogOpts { get; private set; } = null!;

        /// <summary>
        /// Save the container logs (`attach` must be enabled).
        /// </summary>
        [Output("logs")]
        public Output<bool?> Logs { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of times to an attempt
        /// a restart when `restart` is set to "on-failure"
        /// * `working_dir`- (Optional, string) The working directory for commands to run in
        /// </summary>
        [Output("maxRetryCount")]
        public Output<int?> MaxRetryCount { get; private set; } = null!;

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Output("memory")]
        public Output<int?> Memory { get; private set; } = null!;

        [Output("memorySwap")]
        public Output<int?> MemorySwap { get; private set; } = null!;

        /// <summary>
        /// See Mounts below for details.
        /// </summary>
        [Output("mounts")]
        public Output<ImmutableArray<Outputs.ContainerMounts>> Mounts { get; private set; } = null!;

        [Output("mustRun")]
        public Output<bool?> MustRun { get; private set; } = null!;

        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Network aliases of the container for user-defined networks only. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Output("networkAliases")]
        public Output<ImmutableArray<string>> NetworkAliases { get; private set; } = null!;

        /// <summary>
        /// (Map of a block) The IP addresses of the container on each
        /// network. Key are the network names, values are the IP addresses.
        /// </summary>
        [Output("networkDatas")]
        public Output<ImmutableArray<Outputs.ContainerNetworkDatas>> NetworkDatas { get; private set; } = null!;

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Output("networkMode")]
        public Output<string?> NetworkMode { get; private set; } = null!;

        /// <summary>
        /// Id of the networks in which the
        /// container is. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Output("networks")]
        public Output<ImmutableArray<string>> Networks { get; private set; } = null!;

        /// <summary>
        /// See Networks Advanced below for details. If this block has priority to the deprecated `network_alias` and `network` properties.
        /// </summary>
        [Output("networksAdvanced")]
        public Output<ImmutableArray<Outputs.ContainerNetworksAdvanced>> NetworksAdvanced { get; private set; } = null!;

        /// <summary>
        /// The PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Output("pidMode")]
        public Output<string?> PidMode { get; private set; } = null!;

        /// <summary>
        /// See Ports below for details.
        /// </summary>
        [Output("ports")]
        public Output<ImmutableArray<Outputs.ContainerPorts>> Ports { get; private set; } = null!;

        /// <summary>
        /// Run container in privileged mode.
        /// </summary>
        [Output("privileged")]
        public Output<bool?> Privileged { get; private set; } = null!;

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Output("publishAllPorts")]
        public Output<bool?> PublishAllPorts { get; private set; } = null!;

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Output("readOnly")]
        public Output<bool?> ReadOnly { get; private set; } = null!;

        /// <summary>
        /// The restart policy for the container. Must be
        /// one of "no", "on-failure", "always", "unless-stopped".
        /// </summary>
        [Output("restart")]
        public Output<string?> Restart { get; private set; } = null!;

        [Output("rm")]
        public Output<bool?> Rm { get; private set; } = null!;

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Output("shmSize")]
        public Output<int?> ShmSize { get; private set; } = null!;

        /// <summary>
        /// If true, then the Docker container will be
        /// started after creation. If false, then the container is only created.
        /// </summary>
        [Output("start")]
        public Output<bool?> Start { get; private set; } = null!;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        [Output("sysctls")]
        public Output<ImmutableDictionary<string, object>?> Sysctls { get; private set; } = null!;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        [Output("tmpfs")]
        public Output<ImmutableDictionary<string, object>?> Tmpfs { get; private set; } = null!;

        /// <summary>
        /// See Ulimits below for
        /// details.
        /// </summary>
        [Output("ulimits")]
        public Output<ImmutableArray<Outputs.ContainerUlimits>> Ulimits { get; private set; } = null!;

        /// <summary>
        /// See File Upload below for details.
        /// </summary>
        [Output("uploads")]
        public Output<ImmutableArray<Outputs.ContainerUploads>> Uploads { get; private set; } = null!;

        /// <summary>
        /// User used for run the first process. Format is
        /// `user` or `user:group` which user and group can be passed literraly or
        /// by name.
        /// </summary>
        [Output("user")]
        public Output<string?> User { get; private set; } = null!;

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Output("usernsMode")]
        public Output<string?> UsernsMode { get; private set; } = null!;

        /// <summary>
        /// See Volumes below for details.
        /// </summary>
        [Output("volumes")]
        public Output<ImmutableArray<Outputs.ContainerVolumes>> Volumes { get; private set; } = null!;

        [Output("workingDir")]
        public Output<string?> WorkingDir { get; private set; } = null!;


        /// <summary>
        /// Create a Container resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Container(string name, ContainerArgs args, CustomResourceOptions? options = null)
            : base("docker:index/container:Container", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private Container(string name, Input<string> id, ContainerState? state = null, CustomResourceOptions? options = null)
            : base("docker:index/container:Container", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Container resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Container Get(string name, Input<string> id, ContainerState? state = null, CustomResourceOptions? options = null)
        {
            return new Container(name, id, state, options);
        }
    }

    public sealed class ContainerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// If true attach to the container after its creation and waits the end of his execution.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// See Capabilities below for details.
        /// </summary>
        [Input("capabilities")]
        public Input<Inputs.ContainerCapabilitiesArgs>? Capabilities { get; set; }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// The command to use to start the
        /// container. For example, to run `/usr/bin/myprogram -f baz.conf` set the
        /// command to be `["/usr/bin/myprogram", "-f", "baz.conf"]`.
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Input("cpuSet")]
        public Input<string>? CpuSet { get; set; }

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Input("destroyGraceSeconds")]
        public Input<int>? DestroyGraceSeconds { get; set; }

        [Input("devices")]
        private InputList<Inputs.ContainerDevicesArgs>? _devices;

        /// <summary>
        /// See Devices below for details.
        /// </summary>
        public InputList<Inputs.ContainerDevicesArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.ContainerDevicesArgs>());
            set => _devices = value;
        }

        [Input("dns")]
        private InputList<string>? _dns;

        /// <summary>
        /// Set of DNS servers.
        /// </summary>
        public InputList<string> Dns
        {
            get => _dns ?? (_dns = new InputList<string>());
            set => _dns = value;
        }

        [Input("dnsOpts")]
        private InputList<string>? _dnsOpts;

        /// <summary>
        /// Set of DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        public InputList<string> DnsOpts
        {
            get => _dnsOpts ?? (_dnsOpts = new InputList<string>());
            set => _dnsOpts = value;
        }

        [Input("dnsSearches")]
        private InputList<string>? _dnsSearches;

        /// <summary>
        /// Set of DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        public InputList<string> DnsSearches
        {
            get => _dnsSearches ?? (_dnsSearches = new InputList<string>());
            set => _dnsSearches = value;
        }

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Input("domainname")]
        public Input<string>? Domainname { get; set; }

        [Input("entrypoints")]
        private InputList<string>? _entrypoints;

        /// <summary>
        /// The command to use as the
        /// Entrypoint for the container. The Entrypoint allows you to configure a
        /// container to run as an executable. For example, to run `/usr/bin/myprogram`
        /// when starting a container, set the entrypoint to be
        /// `["/usr/bin/myprogram"]`.
        /// </summary>
        public InputList<string> Entrypoints
        {
            get => _entrypoints ?? (_entrypoints = new InputList<string>());
            set => _entrypoints = value;
        }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// Environment variables to set.
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        [Input("groupAdds")]
        private InputList<string>? _groupAdds;

        /// <summary>
        /// Add additional groups to run as.
        /// </summary>
        public InputList<string> GroupAdds
        {
            get => _groupAdds ?? (_groupAdds = new InputList<string>());
            set => _groupAdds = value;
        }

        /// <summary>
        /// See Healthcheck below for details.
        /// </summary>
        [Input("healthcheck")]
        public Input<Inputs.ContainerHealthcheckArgs>? Healthcheck { get; set; }

        [Input("hosts")]
        private InputList<Inputs.ContainerHostsArgs>? _hosts;

        /// <summary>
        /// Hostname to add.
        /// </summary>
        public InputList<Inputs.ContainerHostsArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.ContainerHostsArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// The ID of the image to back this container.
        /// The easiest way to get this value is to use the `docker..RemoteImage` resource
        /// as is shown in the example above.
        /// </summary>
        [Input("image", required: true)]
        public Input<string> Image { get; set; } = null!;

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("ipcMode")]
        public Input<string>? IpcMode { get; set; }

        [Input("labels")]
        private InputMap<object>? _labels;

        /// <summary>
        /// Adding labels.
        /// </summary>
        public InputMap<object> Labels
        {
            get => _labels ?? (_labels = new InputMap<object>());
            set => _labels = value;
        }

        [Input("links")]
        private InputList<string>? _links;

        /// <summary>
        /// Set of links for link based
        /// connectivity between containers that are running on the same host.
        /// </summary>
        public InputList<string> Links
        {
            get => _links ?? (_links = new InputList<string>());
            set => _links = value;
        }

        /// <summary>
        /// The logging driver to use for the container.
        /// Defaults to "json-file".
        /// </summary>
        [Input("logDriver")]
        public Input<string>? LogDriver { get; set; }

        [Input("logOpts")]
        private InputMap<object>? _logOpts;

        /// <summary>
        /// Key/value pairs to use as options for
        /// the logging driver.
        /// </summary>
        public InputMap<object> LogOpts
        {
            get => _logOpts ?? (_logOpts = new InputMap<object>());
            set => _logOpts = value;
        }

        /// <summary>
        /// Save the container logs (`attach` must be enabled).
        /// </summary>
        [Input("logs")]
        public Input<bool>? Logs { get; set; }

        /// <summary>
        /// The maximum amount of times to an attempt
        /// a restart when `restart` is set to "on-failure"
        /// * `working_dir`- (Optional, string) The working directory for commands to run in
        /// </summary>
        [Input("maxRetryCount")]
        public Input<int>? MaxRetryCount { get; set; }

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        [Input("memorySwap")]
        public Input<int>? MemorySwap { get; set; }

        [Input("mounts")]
        private InputList<Inputs.ContainerMountsArgs>? _mounts;

        /// <summary>
        /// See Mounts below for details.
        /// </summary>
        public InputList<Inputs.ContainerMountsArgs> Mounts
        {
            get => _mounts ?? (_mounts = new InputList<Inputs.ContainerMountsArgs>());
            set => _mounts = value;
        }

        [Input("mustRun")]
        public Input<bool>? MustRun { get; set; }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAliases")]
        private InputList<string>? _networkAliases;

        /// <summary>
        /// Network aliases of the container for user-defined networks only. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        public InputList<string> NetworkAliases
        {
            get => _networkAliases ?? (_networkAliases = new InputList<string>());
            set => _networkAliases = value;
        }

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Input("networkMode")]
        public Input<string>? NetworkMode { get; set; }

        [Input("networks")]
        private InputList<string>? _networks;

        /// <summary>
        /// Id of the networks in which the
        /// container is. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        public InputList<string> Networks
        {
            get => _networks ?? (_networks = new InputList<string>());
            set => _networks = value;
        }

        [Input("networksAdvanced")]
        private InputList<Inputs.ContainerNetworksAdvancedArgs>? _networksAdvanced;

        /// <summary>
        /// See Networks Advanced below for details. If this block has priority to the deprecated `network_alias` and `network` properties.
        /// </summary>
        public InputList<Inputs.ContainerNetworksAdvancedArgs> NetworksAdvanced
        {
            get => _networksAdvanced ?? (_networksAdvanced = new InputList<Inputs.ContainerNetworksAdvancedArgs>());
            set => _networksAdvanced = value;
        }

        /// <summary>
        /// The PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("pidMode")]
        public Input<string>? PidMode { get; set; }

        [Input("ports")]
        private InputList<Inputs.ContainerPortsArgs>? _ports;

        /// <summary>
        /// See Ports below for details.
        /// </summary>
        public InputList<Inputs.ContainerPortsArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Inputs.ContainerPortsArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// Run container in privileged mode.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Input("publishAllPorts")]
        public Input<bool>? PublishAllPorts { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The restart policy for the container. Must be
        /// one of "no", "on-failure", "always", "unless-stopped".
        /// </summary>
        [Input("restart")]
        public Input<string>? Restart { get; set; }

        [Input("rm")]
        public Input<bool>? Rm { get; set; }

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Input("shmSize")]
        public Input<int>? ShmSize { get; set; }

        /// <summary>
        /// If true, then the Docker container will be
        /// started after creation. If false, then the container is only created.
        /// </summary>
        [Input("start")]
        public Input<bool>? Start { get; set; }

        [Input("sysctls")]
        private InputMap<object>? _sysctls;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        public InputMap<object> Sysctls
        {
            get => _sysctls ?? (_sysctls = new InputMap<object>());
            set => _sysctls = value;
        }

        [Input("tmpfs")]
        private InputMap<object>? _tmpfs;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        public InputMap<object> Tmpfs
        {
            get => _tmpfs ?? (_tmpfs = new InputMap<object>());
            set => _tmpfs = value;
        }

        [Input("ulimits")]
        private InputList<Inputs.ContainerUlimitsArgs>? _ulimits;

        /// <summary>
        /// See Ulimits below for
        /// details.
        /// </summary>
        public InputList<Inputs.ContainerUlimitsArgs> Ulimits
        {
            get => _ulimits ?? (_ulimits = new InputList<Inputs.ContainerUlimitsArgs>());
            set => _ulimits = value;
        }

        [Input("uploads")]
        private InputList<Inputs.ContainerUploadsArgs>? _uploads;

        /// <summary>
        /// See File Upload below for details.
        /// </summary>
        public InputList<Inputs.ContainerUploadsArgs> Uploads
        {
            get => _uploads ?? (_uploads = new InputList<Inputs.ContainerUploadsArgs>());
            set => _uploads = value;
        }

        /// <summary>
        /// User used for run the first process. Format is
        /// `user` or `user:group` which user and group can be passed literraly or
        /// by name.
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Input("usernsMode")]
        public Input<string>? UsernsMode { get; set; }

        [Input("volumes")]
        private InputList<Inputs.ContainerVolumesArgs>? _volumes;

        /// <summary>
        /// See Volumes below for details.
        /// </summary>
        public InputList<Inputs.ContainerVolumesArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Inputs.ContainerVolumesArgs>());
            set => _volumes = value;
        }

        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

        public ContainerArgs()
        {
        }
    }

    public sealed class ContainerState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// If true attach to the container after its creation and waits the end of his execution.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// The network bridge of the container as read from its NetworkSettings.
        /// </summary>
        [Input("bridge")]
        public Input<string>? Bridge { get; set; }

        /// <summary>
        /// See Capabilities below for details.
        /// </summary>
        [Input("capabilities")]
        public Input<Inputs.ContainerCapabilitiesGetArgs>? Capabilities { get; set; }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// The command to use to start the
        /// container. For example, to run `/usr/bin/myprogram -f baz.conf` set the
        /// command to be `["/usr/bin/myprogram", "-f", "baz.conf"]`.
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        /// <summary>
        /// The logs of the container if its execution is done (`attach` must be disabled).
        /// </summary>
        [Input("containerLogs")]
        public Input<string>? ContainerLogs { get; set; }

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Input("cpuSet")]
        public Input<string>? CpuSet { get; set; }

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Input("destroyGraceSeconds")]
        public Input<int>? DestroyGraceSeconds { get; set; }

        [Input("devices")]
        private InputList<Inputs.ContainerDevicesGetArgs>? _devices;

        /// <summary>
        /// See Devices below for details.
        /// </summary>
        public InputList<Inputs.ContainerDevicesGetArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.ContainerDevicesGetArgs>());
            set => _devices = value;
        }

        [Input("dns")]
        private InputList<string>? _dns;

        /// <summary>
        /// Set of DNS servers.
        /// </summary>
        public InputList<string> Dns
        {
            get => _dns ?? (_dns = new InputList<string>());
            set => _dns = value;
        }

        [Input("dnsOpts")]
        private InputList<string>? _dnsOpts;

        /// <summary>
        /// Set of DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        public InputList<string> DnsOpts
        {
            get => _dnsOpts ?? (_dnsOpts = new InputList<string>());
            set => _dnsOpts = value;
        }

        [Input("dnsSearches")]
        private InputList<string>? _dnsSearches;

        /// <summary>
        /// Set of DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        public InputList<string> DnsSearches
        {
            get => _dnsSearches ?? (_dnsSearches = new InputList<string>());
            set => _dnsSearches = value;
        }

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Input("domainname")]
        public Input<string>? Domainname { get; set; }

        [Input("entrypoints")]
        private InputList<string>? _entrypoints;

        /// <summary>
        /// The command to use as the
        /// Entrypoint for the container. The Entrypoint allows you to configure a
        /// container to run as an executable. For example, to run `/usr/bin/myprogram`
        /// when starting a container, set the entrypoint to be
        /// `["/usr/bin/myprogram"]`.
        /// </summary>
        public InputList<string> Entrypoints
        {
            get => _entrypoints ?? (_entrypoints = new InputList<string>());
            set => _entrypoints = value;
        }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// Environment variables to set.
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        /// <summary>
        /// The exit code of the container if its execution is done (`must_run` must be disabled).
        /// </summary>
        [Input("exitCode")]
        public Input<int>? ExitCode { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The network gateway of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Input("gateway")]
        public Input<string>? Gateway { get; set; }

        [Input("groupAdds")]
        private InputList<string>? _groupAdds;

        /// <summary>
        /// Add additional groups to run as.
        /// </summary>
        public InputList<string> GroupAdds
        {
            get => _groupAdds ?? (_groupAdds = new InputList<string>());
            set => _groupAdds = value;
        }

        /// <summary>
        /// See Healthcheck below for details.
        /// </summary>
        [Input("healthcheck")]
        public Input<Inputs.ContainerHealthcheckGetArgs>? Healthcheck { get; set; }

        [Input("hosts")]
        private InputList<Inputs.ContainerHostsGetArgs>? _hosts;

        /// <summary>
        /// Hostname to add.
        /// </summary>
        public InputList<Inputs.ContainerHostsGetArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.ContainerHostsGetArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// The ID of the image to back this container.
        /// The easiest way to get this value is to use the `docker..RemoteImage` resource
        /// as is shown in the example above.
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP address of the container's first network it.
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP prefix length of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Input("ipPrefixLength")]
        public Input<int>? IpPrefixLength { get; set; }

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("ipcMode")]
        public Input<string>? IpcMode { get; set; }

        [Input("labels")]
        private InputMap<object>? _labels;

        /// <summary>
        /// Adding labels.
        /// </summary>
        public InputMap<object> Labels
        {
            get => _labels ?? (_labels = new InputMap<object>());
            set => _labels = value;
        }

        [Input("links")]
        private InputList<string>? _links;

        /// <summary>
        /// Set of links for link based
        /// connectivity between containers that are running on the same host.
        /// </summary>
        public InputList<string> Links
        {
            get => _links ?? (_links = new InputList<string>());
            set => _links = value;
        }

        /// <summary>
        /// The logging driver to use for the container.
        /// Defaults to "json-file".
        /// </summary>
        [Input("logDriver")]
        public Input<string>? LogDriver { get; set; }

        [Input("logOpts")]
        private InputMap<object>? _logOpts;

        /// <summary>
        /// Key/value pairs to use as options for
        /// the logging driver.
        /// </summary>
        public InputMap<object> LogOpts
        {
            get => _logOpts ?? (_logOpts = new InputMap<object>());
            set => _logOpts = value;
        }

        /// <summary>
        /// Save the container logs (`attach` must be enabled).
        /// </summary>
        [Input("logs")]
        public Input<bool>? Logs { get; set; }

        /// <summary>
        /// The maximum amount of times to an attempt
        /// a restart when `restart` is set to "on-failure"
        /// * `working_dir`- (Optional, string) The working directory for commands to run in
        /// </summary>
        [Input("maxRetryCount")]
        public Input<int>? MaxRetryCount { get; set; }

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        [Input("memorySwap")]
        public Input<int>? MemorySwap { get; set; }

        [Input("mounts")]
        private InputList<Inputs.ContainerMountsGetArgs>? _mounts;

        /// <summary>
        /// See Mounts below for details.
        /// </summary>
        public InputList<Inputs.ContainerMountsGetArgs> Mounts
        {
            get => _mounts ?? (_mounts = new InputList<Inputs.ContainerMountsGetArgs>());
            set => _mounts = value;
        }

        [Input("mustRun")]
        public Input<bool>? MustRun { get; set; }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAliases")]
        private InputList<string>? _networkAliases;

        /// <summary>
        /// Network aliases of the container for user-defined networks only. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        public InputList<string> NetworkAliases
        {
            get => _networkAliases ?? (_networkAliases = new InputList<string>());
            set => _networkAliases = value;
        }

        [Input("networkDatas")]
        private InputList<Inputs.ContainerNetworkDatasGetArgs>? _networkDatas;

        /// <summary>
        /// (Map of a block) The IP addresses of the container on each
        /// network. Key are the network names, values are the IP addresses.
        /// </summary>
        public InputList<Inputs.ContainerNetworkDatasGetArgs> NetworkDatas
        {
            get => _networkDatas ?? (_networkDatas = new InputList<Inputs.ContainerNetworkDatasGetArgs>());
            set => _networkDatas = value;
        }

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Input("networkMode")]
        public Input<string>? NetworkMode { get; set; }

        [Input("networks")]
        private InputList<string>? _networks;

        /// <summary>
        /// Id of the networks in which the
        /// container is. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        public InputList<string> Networks
        {
            get => _networks ?? (_networks = new InputList<string>());
            set => _networks = value;
        }

        [Input("networksAdvanced")]
        private InputList<Inputs.ContainerNetworksAdvancedGetArgs>? _networksAdvanced;

        /// <summary>
        /// See Networks Advanced below for details. If this block has priority to the deprecated `network_alias` and `network` properties.
        /// </summary>
        public InputList<Inputs.ContainerNetworksAdvancedGetArgs> NetworksAdvanced
        {
            get => _networksAdvanced ?? (_networksAdvanced = new InputList<Inputs.ContainerNetworksAdvancedGetArgs>());
            set => _networksAdvanced = value;
        }

        /// <summary>
        /// The PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("pidMode")]
        public Input<string>? PidMode { get; set; }

        [Input("ports")]
        private InputList<Inputs.ContainerPortsGetArgs>? _ports;

        /// <summary>
        /// See Ports below for details.
        /// </summary>
        public InputList<Inputs.ContainerPortsGetArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Inputs.ContainerPortsGetArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// Run container in privileged mode.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Input("publishAllPorts")]
        public Input<bool>? PublishAllPorts { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The restart policy for the container. Must be
        /// one of "no", "on-failure", "always", "unless-stopped".
        /// </summary>
        [Input("restart")]
        public Input<string>? Restart { get; set; }

        [Input("rm")]
        public Input<bool>? Rm { get; set; }

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Input("shmSize")]
        public Input<int>? ShmSize { get; set; }

        /// <summary>
        /// If true, then the Docker container will be
        /// started after creation. If false, then the container is only created.
        /// </summary>
        [Input("start")]
        public Input<bool>? Start { get; set; }

        [Input("sysctls")]
        private InputMap<object>? _sysctls;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        public InputMap<object> Sysctls
        {
            get => _sysctls ?? (_sysctls = new InputMap<object>());
            set => _sysctls = value;
        }

        [Input("tmpfs")]
        private InputMap<object>? _tmpfs;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        public InputMap<object> Tmpfs
        {
            get => _tmpfs ?? (_tmpfs = new InputMap<object>());
            set => _tmpfs = value;
        }

        [Input("ulimits")]
        private InputList<Inputs.ContainerUlimitsGetArgs>? _ulimits;

        /// <summary>
        /// See Ulimits below for
        /// details.
        /// </summary>
        public InputList<Inputs.ContainerUlimitsGetArgs> Ulimits
        {
            get => _ulimits ?? (_ulimits = new InputList<Inputs.ContainerUlimitsGetArgs>());
            set => _ulimits = value;
        }

        [Input("uploads")]
        private InputList<Inputs.ContainerUploadsGetArgs>? _uploads;

        /// <summary>
        /// See File Upload below for details.
        /// </summary>
        public InputList<Inputs.ContainerUploadsGetArgs> Uploads
        {
            get => _uploads ?? (_uploads = new InputList<Inputs.ContainerUploadsGetArgs>());
            set => _uploads = value;
        }

        /// <summary>
        /// User used for run the first process. Format is
        /// `user` or `user:group` which user and group can be passed literraly or
        /// by name.
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Input("usernsMode")]
        public Input<string>? UsernsMode { get; set; }

        [Input("volumes")]
        private InputList<Inputs.ContainerVolumesGetArgs>? _volumes;

        /// <summary>
        /// See Volumes below for details.
        /// </summary>
        public InputList<Inputs.ContainerVolumesGetArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Inputs.ContainerVolumesGetArgs>());
            set => _volumes = value;
        }

        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

        public ContainerState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class ContainerCapabilitiesArgs : Pulumi.ResourceArgs
    {
        [Input("adds")]
        private InputList<string>? _adds;

        /// <summary>
        /// list of linux capabilities to add.
        /// </summary>
        public InputList<string> Adds
        {
            get => _adds ?? (_adds = new InputList<string>());
            set => _adds = value;
        }

        [Input("drops")]
        private InputList<string>? _drops;

        /// <summary>
        /// list of linux capabilities to drop.
        /// </summary>
        public InputList<string> Drops
        {
            get => _drops ?? (_drops = new InputList<string>());
            set => _drops = value;
        }

        public ContainerCapabilitiesArgs()
        {
        }
    }

    public sealed class ContainerCapabilitiesGetArgs : Pulumi.ResourceArgs
    {
        [Input("adds")]
        private InputList<string>? _adds;

        /// <summary>
        /// list of linux capabilities to add.
        /// </summary>
        public InputList<string> Adds
        {
            get => _adds ?? (_adds = new InputList<string>());
            set => _adds = value;
        }

        [Input("drops")]
        private InputList<string>? _drops;

        /// <summary>
        /// list of linux capabilities to drop.
        /// </summary>
        public InputList<string> Drops
        {
            get => _drops ?? (_drops = new InputList<string>());
            set => _drops = value;
        }

        public ContainerCapabilitiesGetArgs()
        {
        }
    }

    public sealed class ContainerDevicesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The path in the container where the
        /// device will be binded.
        /// </summary>
        [Input("containerPath")]
        public Input<string>? ContainerPath { get; set; }

        /// <summary>
        /// The path on the host where the device
        /// is located.
        /// </summary>
        [Input("hostPath", required: true)]
        public Input<string> HostPath { get; set; } = null!;

        /// <summary>
        /// The cgroup permissions given to the
        /// container to access the device.
        /// Defaults to `rwm`.
        /// </summary>
        [Input("permissions")]
        public Input<string>? Permissions { get; set; }

        public ContainerDevicesArgs()
        {
        }
    }

    public sealed class ContainerDevicesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The path in the container where the
        /// device will be binded.
        /// </summary>
        [Input("containerPath")]
        public Input<string>? ContainerPath { get; set; }

        /// <summary>
        /// The path on the host where the device
        /// is located.
        /// </summary>
        [Input("hostPath", required: true)]
        public Input<string> HostPath { get; set; } = null!;

        /// <summary>
        /// The cgroup permissions given to the
        /// container to access the device.
        /// Defaults to `rwm`.
        /// </summary>
        [Input("permissions")]
        public Input<string>? Permissions { get; set; }

        public ContainerDevicesGetArgs()
        {
        }
    }

    public sealed class ContainerHealthcheckArgs : Pulumi.ResourceArgs
    {
        [Input("interval")]
        public Input<string>? Interval { get; set; }

        [Input("retries")]
        public Input<int>? Retries { get; set; }

        [Input("startPeriod")]
        public Input<string>? StartPeriod { get; set; }

        [Input("tests", required: true)]
        private InputList<string>? _tests;
        public InputList<string> Tests
        {
            get => _tests ?? (_tests = new InputList<string>());
            set => _tests = value;
        }

        [Input("timeout")]
        public Input<string>? Timeout { get; set; }

        public ContainerHealthcheckArgs()
        {
        }
    }

    public sealed class ContainerHealthcheckGetArgs : Pulumi.ResourceArgs
    {
        [Input("interval")]
        public Input<string>? Interval { get; set; }

        [Input("retries")]
        public Input<int>? Retries { get; set; }

        [Input("startPeriod")]
        public Input<string>? StartPeriod { get; set; }

        [Input("tests", required: true)]
        private InputList<string>? _tests;
        public InputList<string> Tests
        {
            get => _tests ?? (_tests = new InputList<string>());
            set => _tests = value;
        }

        [Input("timeout")]
        public Input<string>? Timeout { get; set; }

        public ContainerHealthcheckGetArgs()
        {
        }
    }

    public sealed class ContainerHostsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Hostname to add.
        /// </summary>
        [Input("host", required: true)]
        public Input<string> Host { get; set; } = null!;

        /// <summary>
        /// IP address this hostname should resolve to.
        /// </summary>
        [Input("ip", required: true)]
        public Input<string> Ip { get; set; } = null!;

        public ContainerHostsArgs()
        {
        }
    }

    public sealed class ContainerHostsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Hostname to add.
        /// </summary>
        [Input("host", required: true)]
        public Input<string> Host { get; set; } = null!;

        /// <summary>
        /// IP address this hostname should resolve to.
        /// </summary>
        [Input("ip", required: true)]
        public Input<string> Ip { get; set; } = null!;

        public ContainerHostsGetArgs()
        {
        }
    }

    public sealed class ContainerMountsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional configuration for the `bind` type.
        /// </summary>
        [Input("bindOptions")]
        public Input<ContainerMountsBindOptionsArgs>? BindOptions { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The mount source (e.g., a volume name, a host path)
        /// </summary>
        [Input("source")]
        public Input<string>? Source { get; set; }

        /// <summary>
        /// The container path.
        /// </summary>
        [Input("target", required: true)]
        public Input<string> Target { get; set; } = null!;

        /// <summary>
        /// Optional configuration for the `tmpf` type.
        /// </summary>
        [Input("tmpfsOptions")]
        public Input<ContainerMountsTmpfsOptionsArgs>? TmpfsOptions { get; set; }

        /// <summary>
        /// The mount type: valid values are `bind|volume|tmpfs`.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Optional configuration for the `volume` type.
        /// </summary>
        [Input("volumeOptions")]
        public Input<ContainerMountsVolumeOptionsArgs>? VolumeOptions { get; set; }

        public ContainerMountsArgs()
        {
        }
    }

    public sealed class ContainerMountsBindOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A propagation mode with the value.
        /// </summary>
        [Input("propagation")]
        public Input<string>? Propagation { get; set; }

        public ContainerMountsBindOptionsArgs()
        {
        }
    }

    public sealed class ContainerMountsBindOptionsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// A propagation mode with the value.
        /// </summary>
        [Input("propagation")]
        public Input<string>? Propagation { get; set; }

        public ContainerMountsBindOptionsGetArgs()
        {
        }
    }

    public sealed class ContainerMountsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional configuration for the `bind` type.
        /// </summary>
        [Input("bindOptions")]
        public Input<ContainerMountsBindOptionsGetArgs>? BindOptions { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The mount source (e.g., a volume name, a host path)
        /// </summary>
        [Input("source")]
        public Input<string>? Source { get; set; }

        /// <summary>
        /// The container path.
        /// </summary>
        [Input("target", required: true)]
        public Input<string> Target { get; set; } = null!;

        /// <summary>
        /// Optional configuration for the `tmpf` type.
        /// </summary>
        [Input("tmpfsOptions")]
        public Input<ContainerMountsTmpfsOptionsGetArgs>? TmpfsOptions { get; set; }

        /// <summary>
        /// The mount type: valid values are `bind|volume|tmpfs`.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Optional configuration for the `volume` type.
        /// </summary>
        [Input("volumeOptions")]
        public Input<ContainerMountsVolumeOptionsGetArgs>? VolumeOptions { get; set; }

        public ContainerMountsGetArgs()
        {
        }
    }

    public sealed class ContainerMountsTmpfsOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The permission mode for the tmpfs mount in an integer.
        /// </summary>
        [Input("mode")]
        public Input<int>? Mode { get; set; }

        /// <summary>
        /// The size for the tmpfs mount in bytes.
        /// </summary>
        [Input("sizeBytes")]
        public Input<int>? SizeBytes { get; set; }

        public ContainerMountsTmpfsOptionsArgs()
        {
        }
    }

    public sealed class ContainerMountsTmpfsOptionsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The permission mode for the tmpfs mount in an integer.
        /// </summary>
        [Input("mode")]
        public Input<int>? Mode { get; set; }

        /// <summary>
        /// The size for the tmpfs mount in bytes.
        /// </summary>
        [Input("sizeBytes")]
        public Input<int>? SizeBytes { get; set; }

        public ContainerMountsTmpfsOptionsGetArgs()
        {
        }
    }

    public sealed class ContainerMountsVolumeOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("driverName")]
        public Input<string>? DriverName { get; set; }

        [Input("driverOptions")]
        private InputMap<string>? _driverOptions;

        /// <summary>
        /// Options for the driver.
        /// </summary>
        public InputMap<string> DriverOptions
        {
            get => _driverOptions ?? (_driverOptions = new InputMap<string>());
            set => _driverOptions = value;
        }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Adding labels.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Whether to populate volume with data from the target.
        /// </summary>
        [Input("noCopy")]
        public Input<bool>? NoCopy { get; set; }

        public ContainerMountsVolumeOptionsArgs()
        {
        }
    }

    public sealed class ContainerMountsVolumeOptionsGetArgs : Pulumi.ResourceArgs
    {
        [Input("driverName")]
        public Input<string>? DriverName { get; set; }

        [Input("driverOptions")]
        private InputMap<string>? _driverOptions;

        /// <summary>
        /// Options for the driver.
        /// </summary>
        public InputMap<string> DriverOptions
        {
            get => _driverOptions ?? (_driverOptions = new InputMap<string>());
            set => _driverOptions = value;
        }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Adding labels.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Whether to populate volume with data from the target.
        /// </summary>
        [Input("noCopy")]
        public Input<bool>? NoCopy { get; set; }

        public ContainerMountsVolumeOptionsGetArgs()
        {
        }
    }

    public sealed class ContainerNetworkDatasGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The network gateway of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Input("gateway")]
        public Input<string>? Gateway { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP address of the container's first network it.
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP prefix length of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Input("ipPrefixLength")]
        public Input<int>? IpPrefixLength { get; set; }

        [Input("networkName")]
        public Input<string>? NetworkName { get; set; }

        public ContainerNetworkDatasGetArgs()
        {
        }
    }

    public sealed class ContainerNetworksAdvancedArgs : Pulumi.ResourceArgs
    {
        [Input("aliases")]
        private InputList<string>? _aliases;

        /// <summary>
        /// The network aliases of the container in the specific network.
        /// </summary>
        public InputList<string> Aliases
        {
            get => _aliases ?? (_aliases = new InputList<string>());
            set => _aliases = value;
        }

        /// <summary>
        /// The IPV4 address of the container in the specific network.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The IPV6 address of the container in the specific network.
        /// </summary>
        [Input("ipv6Address")]
        public Input<string>? Ipv6Address { get; set; }

        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        public ContainerNetworksAdvancedArgs()
        {
        }
    }

    public sealed class ContainerNetworksAdvancedGetArgs : Pulumi.ResourceArgs
    {
        [Input("aliases")]
        private InputList<string>? _aliases;

        /// <summary>
        /// The network aliases of the container in the specific network.
        /// </summary>
        public InputList<string> Aliases
        {
            get => _aliases ?? (_aliases = new InputList<string>());
            set => _aliases = value;
        }

        /// <summary>
        /// The IPV4 address of the container in the specific network.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The IPV6 address of the container in the specific network.
        /// </summary>
        [Input("ipv6Address")]
        public Input<string>? Ipv6Address { get; set; }

        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        public ContainerNetworksAdvancedGetArgs()
        {
        }
    }

    public sealed class ContainerPortsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Port exposed out of the container. If not given a free random port `&gt;= 32768` will be used.
        /// </summary>
        [Input("external")]
        public Input<int>? External { get; set; }

        /// <summary>
        /// Port within the container.
        /// </summary>
        [Input("internal", required: true)]
        public Input<int> Internal { get; set; } = null!;

        /// <summary>
        /// IP address this hostname should resolve to.
        /// </summary>
        [Input("ip")]
        public Input<string>? Ip { get; set; }

        /// <summary>
        /// Protocol that can be used over this port,
        /// defaults to `tcp`.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        public ContainerPortsArgs()
        {
        }
    }

    public sealed class ContainerPortsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Port exposed out of the container. If not given a free random port `&gt;= 32768` will be used.
        /// </summary>
        [Input("external")]
        public Input<int>? External { get; set; }

        /// <summary>
        /// Port within the container.
        /// </summary>
        [Input("internal", required: true)]
        public Input<int> Internal { get; set; } = null!;

        /// <summary>
        /// IP address this hostname should resolve to.
        /// </summary>
        [Input("ip")]
        public Input<string>? Ip { get; set; }

        /// <summary>
        /// Protocol that can be used over this port,
        /// defaults to `tcp`.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        public ContainerPortsGetArgs()
        {
        }
    }

    public sealed class ContainerUlimitsArgs : Pulumi.ResourceArgs
    {
        [Input("hard", required: true)]
        public Input<int> Hard { get; set; } = null!;

        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("soft", required: true)]
        public Input<int> Soft { get; set; } = null!;

        public ContainerUlimitsArgs()
        {
        }
    }

    public sealed class ContainerUlimitsGetArgs : Pulumi.ResourceArgs
    {
        [Input("hard", required: true)]
        public Input<int> Hard { get; set; } = null!;

        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("soft", required: true)]
        public Input<int> Soft { get; set; } = null!;

        public ContainerUlimitsGetArgs()
        {
        }
    }

    public sealed class ContainerUploadsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
        /// </summary>
        [Input("content")]
        public Input<string>? Content { get; set; }

        [Input("contentBase64")]
        public Input<string>? ContentBase64 { get; set; }

        /// <summary>
        /// If true, the file will be uploaded with user
        /// executable permission.
        /// Defaults to false.
        /// </summary>
        [Input("executable")]
        public Input<bool>? Executable { get; set; }

        /// <summary>
        /// path to a file in the container.
        /// </summary>
        [Input("file", required: true)]
        public Input<string> File { get; set; } = null!;

        public ContainerUploadsArgs()
        {
        }
    }

    public sealed class ContainerUploadsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
        /// </summary>
        [Input("content")]
        public Input<string>? Content { get; set; }

        [Input("contentBase64")]
        public Input<string>? ContentBase64 { get; set; }

        /// <summary>
        /// If true, the file will be uploaded with user
        /// executable permission.
        /// Defaults to false.
        /// </summary>
        [Input("executable")]
        public Input<bool>? Executable { get; set; }

        /// <summary>
        /// path to a file in the container.
        /// </summary>
        [Input("file", required: true)]
        public Input<string> File { get; set; } = null!;

        public ContainerUploadsGetArgs()
        {
        }
    }

    public sealed class ContainerVolumesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The path in the container where the
        /// device will be binded.
        /// </summary>
        [Input("containerPath")]
        public Input<string>? ContainerPath { get; set; }

        /// <summary>
        /// The container where the volume is
        /// coming from.
        /// </summary>
        [Input("fromContainer")]
        public Input<string>? FromContainer { get; set; }

        /// <summary>
        /// The path on the host where the device
        /// is located.
        /// </summary>
        [Input("hostPath")]
        public Input<string>? HostPath { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The name of the docker volume which
        /// should be mounted.
        /// </summary>
        [Input("volumeName")]
        public Input<string>? VolumeName { get; set; }

        public ContainerVolumesArgs()
        {
        }
    }

    public sealed class ContainerVolumesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The path in the container where the
        /// device will be binded.
        /// </summary>
        [Input("containerPath")]
        public Input<string>? ContainerPath { get; set; }

        /// <summary>
        /// The container where the volume is
        /// coming from.
        /// </summary>
        [Input("fromContainer")]
        public Input<string>? FromContainer { get; set; }

        /// <summary>
        /// The path on the host where the device
        /// is located.
        /// </summary>
        [Input("hostPath")]
        public Input<string>? HostPath { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The name of the docker volume which
        /// should be mounted.
        /// </summary>
        [Input("volumeName")]
        public Input<string>? VolumeName { get; set; }

        public ContainerVolumesGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class ContainerCapabilities
    {
        /// <summary>
        /// list of linux capabilities to add.
        /// </summary>
        public readonly ImmutableArray<string> Adds;
        /// <summary>
        /// list of linux capabilities to drop.
        /// </summary>
        public readonly ImmutableArray<string> Drops;

        [OutputConstructor]
        private ContainerCapabilities(
            ImmutableArray<string> adds,
            ImmutableArray<string> drops)
        {
            Adds = adds;
            Drops = drops;
        }
    }

    [OutputType]
    public sealed class ContainerDevices
    {
        /// <summary>
        /// The path in the container where the
        /// device will be binded.
        /// </summary>
        public readonly string? ContainerPath;
        /// <summary>
        /// The path on the host where the device
        /// is located.
        /// </summary>
        public readonly string HostPath;
        /// <summary>
        /// The cgroup permissions given to the
        /// container to access the device.
        /// Defaults to `rwm`.
        /// </summary>
        public readonly string? Permissions;

        [OutputConstructor]
        private ContainerDevices(
            string? containerPath,
            string hostPath,
            string? permissions)
        {
            ContainerPath = containerPath;
            HostPath = hostPath;
            Permissions = permissions;
        }
    }

    [OutputType]
    public sealed class ContainerHealthcheck
    {
        public readonly string? Interval;
        public readonly int? Retries;
        public readonly string? StartPeriod;
        public readonly ImmutableArray<string> Tests;
        public readonly string? Timeout;

        [OutputConstructor]
        private ContainerHealthcheck(
            string? interval,
            int? retries,
            string? startPeriod,
            ImmutableArray<string> tests,
            string? timeout)
        {
            Interval = interval;
            Retries = retries;
            StartPeriod = startPeriod;
            Tests = tests;
            Timeout = timeout;
        }
    }

    [OutputType]
    public sealed class ContainerHosts
    {
        /// <summary>
        /// Hostname to add.
        /// </summary>
        public readonly string Host;
        /// <summary>
        /// IP address this hostname should resolve to.
        /// </summary>
        public readonly string Ip;

        [OutputConstructor]
        private ContainerHosts(
            string host,
            string ip)
        {
            Host = host;
            Ip = ip;
        }
    }

    [OutputType]
    public sealed class ContainerMounts
    {
        /// <summary>
        /// Optional configuration for the `bind` type.
        /// </summary>
        public readonly ContainerMountsBindOptions? BindOptions;
        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        public readonly bool? ReadOnly;
        /// <summary>
        /// The mount source (e.g., a volume name, a host path)
        /// </summary>
        public readonly string? Source;
        /// <summary>
        /// The container path.
        /// </summary>
        public readonly string Target;
        /// <summary>
        /// Optional configuration for the `tmpf` type.
        /// </summary>
        public readonly ContainerMountsTmpfsOptions? TmpfsOptions;
        /// <summary>
        /// The mount type: valid values are `bind|volume|tmpfs`.
        /// </summary>
        public readonly string Type;
        /// <summary>
        /// Optional configuration for the `volume` type.
        /// </summary>
        public readonly ContainerMountsVolumeOptions? VolumeOptions;

        [OutputConstructor]
        private ContainerMounts(
            ContainerMountsBindOptions? bindOptions,
            bool? readOnly,
            string? source,
            string target,
            ContainerMountsTmpfsOptions? tmpfsOptions,
            string type,
            ContainerMountsVolumeOptions? volumeOptions)
        {
            BindOptions = bindOptions;
            ReadOnly = readOnly;
            Source = source;
            Target = target;
            TmpfsOptions = tmpfsOptions;
            Type = type;
            VolumeOptions = volumeOptions;
        }
    }

    [OutputType]
    public sealed class ContainerMountsBindOptions
    {
        /// <summary>
        /// A propagation mode with the value.
        /// </summary>
        public readonly string? Propagation;

        [OutputConstructor]
        private ContainerMountsBindOptions(string? propagation)
        {
            Propagation = propagation;
        }
    }

    [OutputType]
    public sealed class ContainerMountsTmpfsOptions
    {
        /// <summary>
        /// The permission mode for the tmpfs mount in an integer.
        /// </summary>
        public readonly int? Mode;
        /// <summary>
        /// The size for the tmpfs mount in bytes.
        /// </summary>
        public readonly int? SizeBytes;

        [OutputConstructor]
        private ContainerMountsTmpfsOptions(
            int? mode,
            int? sizeBytes)
        {
            Mode = mode;
            SizeBytes = sizeBytes;
        }
    }

    [OutputType]
    public sealed class ContainerMountsVolumeOptions
    {
        public readonly string? DriverName;
        /// <summary>
        /// Options for the driver.
        /// </summary>
        public readonly ImmutableDictionary<string, string>? DriverOptions;
        /// <summary>
        /// Adding labels.
        /// </summary>
        public readonly ImmutableDictionary<string, string>? Labels;
        /// <summary>
        /// Whether to populate volume with data from the target.
        /// </summary>
        public readonly bool? NoCopy;

        [OutputConstructor]
        private ContainerMountsVolumeOptions(
            string? driverName,
            ImmutableDictionary<string, string>? driverOptions,
            ImmutableDictionary<string, string>? labels,
            bool? noCopy)
        {
            DriverName = driverName;
            DriverOptions = driverOptions;
            Labels = labels;
            NoCopy = noCopy;
        }
    }

    [OutputType]
    public sealed class ContainerNetworkDatas
    {
        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The network gateway of the container as read from its
        /// NetworkSettings.
        /// </summary>
        public readonly string Gateway;
        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP address of the container's first network it.
        /// </summary>
        public readonly string IpAddress;
        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP prefix length of the container as read from its
        /// NetworkSettings.
        /// </summary>
        public readonly int IpPrefixLength;
        public readonly string NetworkName;

        [OutputConstructor]
        private ContainerNetworkDatas(
            string gateway,
            string ipAddress,
            int ipPrefixLength,
            string networkName)
        {
            Gateway = gateway;
            IpAddress = ipAddress;
            IpPrefixLength = ipPrefixLength;
            NetworkName = networkName;
        }
    }

    [OutputType]
    public sealed class ContainerNetworksAdvanced
    {
        /// <summary>
        /// The network aliases of the container in the specific network.
        /// </summary>
        public readonly ImmutableArray<string> Aliases;
        /// <summary>
        /// The IPV4 address of the container in the specific network.
        /// </summary>
        public readonly string? Ipv4Address;
        /// <summary>
        /// The IPV6 address of the container in the specific network.
        /// </summary>
        public readonly string? Ipv6Address;
        public readonly string Name;

        [OutputConstructor]
        private ContainerNetworksAdvanced(
            ImmutableArray<string> aliases,
            string? ipv4Address,
            string? ipv6Address,
            string name)
        {
            Aliases = aliases;
            Ipv4Address = ipv4Address;
            Ipv6Address = ipv6Address;
            Name = name;
        }
    }

    [OutputType]
    public sealed class ContainerPorts
    {
        /// <summary>
        /// Port exposed out of the container. If not given a free random port `&gt;= 32768` will be used.
        /// </summary>
        public readonly int External;
        /// <summary>
        /// Port within the container.
        /// </summary>
        public readonly int Internal;
        /// <summary>
        /// IP address this hostname should resolve to.
        /// </summary>
        public readonly string? Ip;
        /// <summary>
        /// Protocol that can be used over this port,
        /// defaults to `tcp`.
        /// </summary>
        public readonly string? Protocol;

        [OutputConstructor]
        private ContainerPorts(
            int external,
            int @internal,
            string? ip,
            string? protocol)
        {
            External = external;
            Internal = @internal;
            Ip = ip;
            Protocol = protocol;
        }
    }

    [OutputType]
    public sealed class ContainerUlimits
    {
        public readonly int Hard;
        public readonly string Name;
        public readonly int Soft;

        [OutputConstructor]
        private ContainerUlimits(
            int hard,
            string name,
            int soft)
        {
            Hard = hard;
            Name = name;
            Soft = soft;
        }
    }

    [OutputType]
    public sealed class ContainerUploads
    {
        /// <summary>
        /// Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
        /// </summary>
        public readonly string? Content;
        public readonly string? ContentBase64;
        /// <summary>
        /// If true, the file will be uploaded with user
        /// executable permission.
        /// Defaults to false.
        /// </summary>
        public readonly bool? Executable;
        /// <summary>
        /// path to a file in the container.
        /// </summary>
        public readonly string File;

        [OutputConstructor]
        private ContainerUploads(
            string? content,
            string? contentBase64,
            bool? executable,
            string file)
        {
            Content = content;
            ContentBase64 = contentBase64;
            Executable = executable;
            File = file;
        }
    }

    [OutputType]
    public sealed class ContainerVolumes
    {
        /// <summary>
        /// The path in the container where the
        /// device will be binded.
        /// </summary>
        public readonly string? ContainerPath;
        /// <summary>
        /// The container where the volume is
        /// coming from.
        /// </summary>
        public readonly string? FromContainer;
        /// <summary>
        /// The path on the host where the device
        /// is located.
        /// </summary>
        public readonly string? HostPath;
        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        public readonly bool? ReadOnly;
        /// <summary>
        /// The name of the docker volume which
        /// should be mounted.
        /// </summary>
        public readonly string? VolumeName;

        [OutputConstructor]
        private ContainerVolumes(
            string? containerPath,
            string? fromContainer,
            string? hostPath,
            bool? readOnly,
            string? volumeName)
        {
            ContainerPath = containerPath;
            FromContainer = fromContainer;
            HostPath = hostPath;
            ReadOnly = readOnly;
            VolumeName = volumeName;
        }
    }
    }
}
