// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Docker
{
    /// <summary>
    /// Manages the lifecycle of a Docker container.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Docker = Pulumi.Docker;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         // Find the latest Ubuntu precise image.
    ///         var ubuntuRemoteImage = new Docker.RemoteImage("ubuntuRemoteImage", new Docker.RemoteImageArgs
    ///         {
    ///             Name = "ubuntu:precise",
    ///         });
    ///         // Start a container
    ///         var ubuntuContainer = new Docker.Container("ubuntuContainer", new Docker.ContainerArgs
    ///         {
    ///             Image = ubuntuRemoteImage.Latest,
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// 
    /// ## Import
    /// 
    /// Docker containers can be imported using the long id, e.g. for a container named `foo`
    /// 
    /// ```sh
    ///  $ pulumi import docker:index/container:Container foo $(docker inspect -f {{.ID}} foo)
    /// ```
    /// 
    ///  [linkdoc] https://docs.docker.com/network/links/
    /// </summary>
    public partial class Container : Pulumi.CustomResource
    {
        /// <summary>
        /// If true attach to the container after its creation and waits the end of his execution.
        /// </summary>
        [Output("attach")]
        public Output<bool?> Attach { get; private set; } = null!;

        /// <summary>
        /// The network bridge of the container as read from its NetworkSettings.
        /// </summary>
        [Output("bridge")]
        public Output<string> Bridge { get; private set; } = null!;

        /// <summary>
        /// See Capabilities below for details.
        /// </summary>
        [Output("capabilities")]
        public Output<Outputs.ContainerCapabilities?> Capabilities { get; private set; } = null!;

        /// <summary>
        /// The command to use to start the
        /// container. For example, to run `/usr/bin/myprogram -f baz.conf` set the
        /// command to be `["/usr/bin/myprogram", "-f", "baz.conf"]`.
        /// </summary>
        [Output("command")]
        public Output<ImmutableArray<string>> Command { get; private set; } = null!;

        /// <summary>
        /// The logs of the container if its execution is done (`attach` must be disabled).
        /// </summary>
        [Output("containerLogs")]
        public Output<string> ContainerLogs { get; private set; } = null!;

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Output("cpuSet")]
        public Output<string?> CpuSet { get; private set; } = null!;

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Output("cpuShares")]
        public Output<int?> CpuShares { get; private set; } = null!;

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Output("destroyGraceSeconds")]
        public Output<int?> DestroyGraceSeconds { get; private set; } = null!;

        /// <summary>
        /// See Devices below for details.
        /// </summary>
        [Output("devices")]
        public Output<ImmutableArray<Outputs.ContainerDevice>> Devices { get; private set; } = null!;

        /// <summary>
        /// Set of DNS servers.
        /// </summary>
        [Output("dns")]
        public Output<ImmutableArray<string>> Dns { get; private set; } = null!;

        /// <summary>
        /// Set of DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        [Output("dnsOpts")]
        public Output<ImmutableArray<string>> DnsOpts { get; private set; } = null!;

        /// <summary>
        /// Set of DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        [Output("dnsSearches")]
        public Output<ImmutableArray<string>> DnsSearches { get; private set; } = null!;

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Output("domainname")]
        public Output<string?> Domainname { get; private set; } = null!;

        /// <summary>
        /// The command to use as the
        /// Entrypoint for the container. The Entrypoint allows you to configure a
        /// container to run as an executable. For example, to run `/usr/bin/myprogram`
        /// when starting a container, set the entrypoint to be
        /// `["/usr/bin/myprogram"]`.
        /// </summary>
        [Output("entrypoints")]
        public Output<ImmutableArray<string>> Entrypoints { get; private set; } = null!;

        /// <summary>
        /// Environment variables to set.
        /// </summary>
        [Output("envs")]
        public Output<ImmutableArray<string>> Envs { get; private set; } = null!;

        /// <summary>
        /// The exit code of the container if its execution is done (`must_run` must be disabled).
        /// </summary>
        [Output("exitCode")]
        public Output<int> ExitCode { get; private set; } = null!;

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The network gateway of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Output("gateway")]
        public Output<string> Gateway { get; private set; } = null!;

        /// <summary>
        /// Add additional groups to run as.
        /// </summary>
        [Output("groupAdds")]
        public Output<ImmutableArray<string>> GroupAdds { get; private set; } = null!;

        /// <summary>
        /// See Healthcheck below for details.
        /// </summary>
        [Output("healthcheck")]
        public Output<Outputs.ContainerHealthcheck?> Healthcheck { get; private set; } = null!;

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Output("hostname")]
        public Output<string> Hostname { get; private set; } = null!;

        /// <summary>
        /// Hostname to add.
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<Outputs.ContainerHost>> Hosts { get; private set; } = null!;

        /// <summary>
        /// The ID of the image to back this container.
        /// The easiest way to get this value is to use the `docker.RemoteImage` resource
        /// as is shown in the example above.
        /// </summary>
        [Output("image")]
        public Output<string> Image { get; private set; } = null!;

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP address of the container's first network it.
        /// </summary>
        [Output("ipAddress")]
        public Output<string> IpAddress { get; private set; } = null!;

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP prefix length of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Output("ipPrefixLength")]
        public Output<int> IpPrefixLength { get; private set; } = null!;

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Output("ipcMode")]
        public Output<string> IpcMode { get; private set; } = null!;

        /// <summary>
        /// Adding labels.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableArray<Outputs.ContainerLabel>> Labels { get; private set; } = null!;

        /// <summary>
        /// Set of links for link based
        /// connectivity between containers that are running on the same host.
        /// </summary>
        [Output("links")]
        public Output<ImmutableArray<string>> Links { get; private set; } = null!;

        /// <summary>
        /// The logging driver to use for the container.
        /// Defaults to "json-file".
        /// </summary>
        [Output("logDriver")]
        public Output<string> LogDriver { get; private set; } = null!;

        /// <summary>
        /// Key/value pairs to use as options for
        /// the logging driver.
        /// </summary>
        [Output("logOpts")]
        public Output<ImmutableDictionary<string, object>> LogOpts { get; private set; } = null!;

        /// <summary>
        /// Save the container logs (`attach` must be enabled).
        /// </summary>
        [Output("logs")]
        public Output<bool?> Logs { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of times to an attempt
        /// a restart when `restart` is set to "on-failure"
        /// </summary>
        [Output("maxRetryCount")]
        public Output<int?> MaxRetryCount { get; private set; } = null!;

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Output("memory")]
        public Output<int?> Memory { get; private set; } = null!;

        [Output("memorySwap")]
        public Output<int?> MemorySwap { get; private set; } = null!;

        /// <summary>
        /// See Mounts below for details.
        /// </summary>
        [Output("mounts")]
        public Output<ImmutableArray<Outputs.ContainerMount>> Mounts { get; private set; } = null!;

        [Output("mustRun")]
        public Output<bool?> MustRun { get; private set; } = null!;

        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Network aliases of the container for user-defined networks only. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Output("networkAliases")]
        public Output<ImmutableArray<string>> NetworkAliases { get; private set; } = null!;

        /// <summary>
        /// (Map of a block) The IP addresses of the container on each
        /// network. Key are the network names, values are the IP addresses.
        /// </summary>
        [Output("networkDatas")]
        public Output<ImmutableArray<Outputs.ContainerNetworkData>> NetworkDatas { get; private set; } = null!;

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Output("networkMode")]
        public Output<string?> NetworkMode { get; private set; } = null!;

        /// <summary>
        /// Id of the networks in which the
        /// container is. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Output("networks")]
        public Output<ImmutableArray<string>> Networks { get; private set; } = null!;

        /// <summary>
        /// See Networks Advanced below for details. If this block has priority to the deprecated `network_alias` and `network` properties.
        /// </summary>
        [Output("networksAdvanced")]
        public Output<ImmutableArray<Outputs.ContainerNetworksAdvanced>> NetworksAdvanced { get; private set; } = null!;

        /// <summary>
        /// The PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Output("pidMode")]
        public Output<string?> PidMode { get; private set; } = null!;

        /// <summary>
        /// See Ports below for details.
        /// </summary>
        [Output("ports")]
        public Output<ImmutableArray<Outputs.ContainerPort>> Ports { get; private set; } = null!;

        /// <summary>
        /// Run container in privileged mode.
        /// </summary>
        [Output("privileged")]
        public Output<bool?> Privileged { get; private set; } = null!;

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Output("publishAllPorts")]
        public Output<bool?> PublishAllPorts { get; private set; } = null!;

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Output("readOnly")]
        public Output<bool?> ReadOnly { get; private set; } = null!;

        /// <summary>
        /// The restart policy for the container. Must be
        /// one of "no", "on-failure", "always", "unless-stopped".
        /// </summary>
        [Output("restart")]
        public Output<string?> Restart { get; private set; } = null!;

        [Output("rm")]
        public Output<bool?> Rm { get; private set; } = null!;

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Output("shmSize")]
        public Output<int> ShmSize { get; private set; } = null!;

        /// <summary>
        /// If true, then the Docker container will be
        /// started after creation. If false, then the container is only created.
        /// </summary>
        [Output("start")]
        public Output<bool?> Start { get; private set; } = null!;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        [Output("sysctls")]
        public Output<ImmutableDictionary<string, object>?> Sysctls { get; private set; } = null!;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        [Output("tmpfs")]
        public Output<ImmutableDictionary<string, object>?> Tmpfs { get; private set; } = null!;

        /// <summary>
        /// See Ulimits below for
        /// details.
        /// </summary>
        [Output("ulimits")]
        public Output<ImmutableArray<Outputs.ContainerUlimit>> Ulimits { get; private set; } = null!;

        /// <summary>
        /// See File Upload below for details.
        /// </summary>
        [Output("uploads")]
        public Output<ImmutableArray<Outputs.ContainerUpload>> Uploads { get; private set; } = null!;

        /// <summary>
        /// User used for run the first process. Format is
        /// `user` or `user:group` which user and group can be passed literraly or
        /// by name.
        /// </summary>
        [Output("user")]
        public Output<string> User { get; private set; } = null!;

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Output("usernsMode")]
        public Output<string?> UsernsMode { get; private set; } = null!;

        /// <summary>
        /// See Volumes below for details.
        /// </summary>
        [Output("volumes")]
        public Output<ImmutableArray<Outputs.ContainerVolume>> Volumes { get; private set; } = null!;

        /// <summary>
        /// The working directory for commands to run in
        /// </summary>
        [Output("workingDir")]
        public Output<string> WorkingDir { get; private set; } = null!;


        /// <summary>
        /// Create a Container resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Container(string name, ContainerArgs args, CustomResourceOptions? options = null)
            : base("docker:index/container:Container", name, args ?? new ContainerArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Container(string name, Input<string> id, ContainerState? state = null, CustomResourceOptions? options = null)
            : base("docker:index/container:Container", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Container resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Container Get(string name, Input<string> id, ContainerState? state = null, CustomResourceOptions? options = null)
        {
            return new Container(name, id, state, options);
        }
    }

    public sealed class ContainerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// If true attach to the container after its creation and waits the end of his execution.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// See Capabilities below for details.
        /// </summary>
        [Input("capabilities")]
        public Input<Inputs.ContainerCapabilitiesArgs>? Capabilities { get; set; }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// The command to use to start the
        /// container. For example, to run `/usr/bin/myprogram -f baz.conf` set the
        /// command to be `["/usr/bin/myprogram", "-f", "baz.conf"]`.
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Input("cpuSet")]
        public Input<string>? CpuSet { get; set; }

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Input("destroyGraceSeconds")]
        public Input<int>? DestroyGraceSeconds { get; set; }

        [Input("devices")]
        private InputList<Inputs.ContainerDeviceArgs>? _devices;

        /// <summary>
        /// See Devices below for details.
        /// </summary>
        public InputList<Inputs.ContainerDeviceArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.ContainerDeviceArgs>());
            set => _devices = value;
        }

        [Input("dns")]
        private InputList<string>? _dns;

        /// <summary>
        /// Set of DNS servers.
        /// </summary>
        public InputList<string> Dns
        {
            get => _dns ?? (_dns = new InputList<string>());
            set => _dns = value;
        }

        [Input("dnsOpts")]
        private InputList<string>? _dnsOpts;

        /// <summary>
        /// Set of DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        public InputList<string> DnsOpts
        {
            get => _dnsOpts ?? (_dnsOpts = new InputList<string>());
            set => _dnsOpts = value;
        }

        [Input("dnsSearches")]
        private InputList<string>? _dnsSearches;

        /// <summary>
        /// Set of DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        public InputList<string> DnsSearches
        {
            get => _dnsSearches ?? (_dnsSearches = new InputList<string>());
            set => _dnsSearches = value;
        }

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Input("domainname")]
        public Input<string>? Domainname { get; set; }

        [Input("entrypoints")]
        private InputList<string>? _entrypoints;

        /// <summary>
        /// The command to use as the
        /// Entrypoint for the container. The Entrypoint allows you to configure a
        /// container to run as an executable. For example, to run `/usr/bin/myprogram`
        /// when starting a container, set the entrypoint to be
        /// `["/usr/bin/myprogram"]`.
        /// </summary>
        public InputList<string> Entrypoints
        {
            get => _entrypoints ?? (_entrypoints = new InputList<string>());
            set => _entrypoints = value;
        }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// Environment variables to set.
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        [Input("groupAdds")]
        private InputList<string>? _groupAdds;

        /// <summary>
        /// Add additional groups to run as.
        /// </summary>
        public InputList<string> GroupAdds
        {
            get => _groupAdds ?? (_groupAdds = new InputList<string>());
            set => _groupAdds = value;
        }

        /// <summary>
        /// See Healthcheck below for details.
        /// </summary>
        [Input("healthcheck")]
        public Input<Inputs.ContainerHealthcheckArgs>? Healthcheck { get; set; }

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        [Input("hosts")]
        private InputList<Inputs.ContainerHostArgs>? _hosts;

        /// <summary>
        /// Hostname to add.
        /// </summary>
        public InputList<Inputs.ContainerHostArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.ContainerHostArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// The ID of the image to back this container.
        /// The easiest way to get this value is to use the `docker.RemoteImage` resource
        /// as is shown in the example above.
        /// </summary>
        [Input("image", required: true)]
        public Input<string> Image { get; set; } = null!;

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("ipcMode")]
        public Input<string>? IpcMode { get; set; }

        [Input("labels")]
        private InputList<Inputs.ContainerLabelArgs>? _labels;

        /// <summary>
        /// Adding labels.
        /// </summary>
        public InputList<Inputs.ContainerLabelArgs> Labels
        {
            get => _labels ?? (_labels = new InputList<Inputs.ContainerLabelArgs>());
            set => _labels = value;
        }

        [Input("links")]
        private InputList<string>? _links;

        /// <summary>
        /// Set of links for link based
        /// connectivity between containers that are running on the same host.
        /// </summary>
        [Obsolete(@"The --link flag is a legacy feature of Docker. It may eventually be removed.")]
        public InputList<string> Links
        {
            get => _links ?? (_links = new InputList<string>());
            set => _links = value;
        }

        /// <summary>
        /// The logging driver to use for the container.
        /// Defaults to "json-file".
        /// </summary>
        [Input("logDriver")]
        public Input<string>? LogDriver { get; set; }

        [Input("logOpts")]
        private InputMap<object>? _logOpts;

        /// <summary>
        /// Key/value pairs to use as options for
        /// the logging driver.
        /// </summary>
        public InputMap<object> LogOpts
        {
            get => _logOpts ?? (_logOpts = new InputMap<object>());
            set => _logOpts = value;
        }

        /// <summary>
        /// Save the container logs (`attach` must be enabled).
        /// </summary>
        [Input("logs")]
        public Input<bool>? Logs { get; set; }

        /// <summary>
        /// The maximum amount of times to an attempt
        /// a restart when `restart` is set to "on-failure"
        /// </summary>
        [Input("maxRetryCount")]
        public Input<int>? MaxRetryCount { get; set; }

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        [Input("memorySwap")]
        public Input<int>? MemorySwap { get; set; }

        [Input("mounts")]
        private InputList<Inputs.ContainerMountArgs>? _mounts;

        /// <summary>
        /// See Mounts below for details.
        /// </summary>
        public InputList<Inputs.ContainerMountArgs> Mounts
        {
            get => _mounts ?? (_mounts = new InputList<Inputs.ContainerMountArgs>());
            set => _mounts = value;
        }

        [Input("mustRun")]
        public Input<bool>? MustRun { get; set; }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAliases")]
        private InputList<string>? _networkAliases;

        /// <summary>
        /// Network aliases of the container for user-defined networks only. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v2.0.0")]
        public InputList<string> NetworkAliases
        {
            get => _networkAliases ?? (_networkAliases = new InputList<string>());
            set => _networkAliases = value;
        }

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Input("networkMode")]
        public Input<string>? NetworkMode { get; set; }

        [Input("networks")]
        private InputList<string>? _networks;

        /// <summary>
        /// Id of the networks in which the
        /// container is. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v2.0.0")]
        public InputList<string> Networks
        {
            get => _networks ?? (_networks = new InputList<string>());
            set => _networks = value;
        }

        [Input("networksAdvanced")]
        private InputList<Inputs.ContainerNetworksAdvancedArgs>? _networksAdvanced;

        /// <summary>
        /// See Networks Advanced below for details. If this block has priority to the deprecated `network_alias` and `network` properties.
        /// </summary>
        public InputList<Inputs.ContainerNetworksAdvancedArgs> NetworksAdvanced
        {
            get => _networksAdvanced ?? (_networksAdvanced = new InputList<Inputs.ContainerNetworksAdvancedArgs>());
            set => _networksAdvanced = value;
        }

        /// <summary>
        /// The PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("pidMode")]
        public Input<string>? PidMode { get; set; }

        [Input("ports")]
        private InputList<Inputs.ContainerPortArgs>? _ports;

        /// <summary>
        /// See Ports below for details.
        /// </summary>
        public InputList<Inputs.ContainerPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Inputs.ContainerPortArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// Run container in privileged mode.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Input("publishAllPorts")]
        public Input<bool>? PublishAllPorts { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The restart policy for the container. Must be
        /// one of "no", "on-failure", "always", "unless-stopped".
        /// </summary>
        [Input("restart")]
        public Input<string>? Restart { get; set; }

        [Input("rm")]
        public Input<bool>? Rm { get; set; }

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Input("shmSize")]
        public Input<int>? ShmSize { get; set; }

        /// <summary>
        /// If true, then the Docker container will be
        /// started after creation. If false, then the container is only created.
        /// </summary>
        [Input("start")]
        public Input<bool>? Start { get; set; }

        [Input("sysctls")]
        private InputMap<object>? _sysctls;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        public InputMap<object> Sysctls
        {
            get => _sysctls ?? (_sysctls = new InputMap<object>());
            set => _sysctls = value;
        }

        [Input("tmpfs")]
        private InputMap<object>? _tmpfs;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        public InputMap<object> Tmpfs
        {
            get => _tmpfs ?? (_tmpfs = new InputMap<object>());
            set => _tmpfs = value;
        }

        [Input("ulimits")]
        private InputList<Inputs.ContainerUlimitArgs>? _ulimits;

        /// <summary>
        /// See Ulimits below for
        /// details.
        /// </summary>
        public InputList<Inputs.ContainerUlimitArgs> Ulimits
        {
            get => _ulimits ?? (_ulimits = new InputList<Inputs.ContainerUlimitArgs>());
            set => _ulimits = value;
        }

        [Input("uploads")]
        private InputList<Inputs.ContainerUploadArgs>? _uploads;

        /// <summary>
        /// See File Upload below for details.
        /// </summary>
        public InputList<Inputs.ContainerUploadArgs> Uploads
        {
            get => _uploads ?? (_uploads = new InputList<Inputs.ContainerUploadArgs>());
            set => _uploads = value;
        }

        /// <summary>
        /// User used for run the first process. Format is
        /// `user` or `user:group` which user and group can be passed literraly or
        /// by name.
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Input("usernsMode")]
        public Input<string>? UsernsMode { get; set; }

        [Input("volumes")]
        private InputList<Inputs.ContainerVolumeArgs>? _volumes;

        /// <summary>
        /// See Volumes below for details.
        /// </summary>
        public InputList<Inputs.ContainerVolumeArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Inputs.ContainerVolumeArgs>());
            set => _volumes = value;
        }

        /// <summary>
        /// The working directory for commands to run in
        /// </summary>
        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

        public ContainerArgs()
        {
        }
    }

    public sealed class ContainerState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// If true attach to the container after its creation and waits the end of his execution.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// The network bridge of the container as read from its NetworkSettings.
        /// </summary>
        [Input("bridge")]
        public Input<string>? Bridge { get; set; }

        /// <summary>
        /// See Capabilities below for details.
        /// </summary>
        [Input("capabilities")]
        public Input<Inputs.ContainerCapabilitiesGetArgs>? Capabilities { get; set; }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// The command to use to start the
        /// container. For example, to run `/usr/bin/myprogram -f baz.conf` set the
        /// command to be `["/usr/bin/myprogram", "-f", "baz.conf"]`.
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        /// <summary>
        /// The logs of the container if its execution is done (`attach` must be disabled).
        /// </summary>
        [Input("containerLogs")]
        public Input<string>? ContainerLogs { get; set; }

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Input("cpuSet")]
        public Input<string>? CpuSet { get; set; }

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Input("destroyGraceSeconds")]
        public Input<int>? DestroyGraceSeconds { get; set; }

        [Input("devices")]
        private InputList<Inputs.ContainerDeviceGetArgs>? _devices;

        /// <summary>
        /// See Devices below for details.
        /// </summary>
        public InputList<Inputs.ContainerDeviceGetArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.ContainerDeviceGetArgs>());
            set => _devices = value;
        }

        [Input("dns")]
        private InputList<string>? _dns;

        /// <summary>
        /// Set of DNS servers.
        /// </summary>
        public InputList<string> Dns
        {
            get => _dns ?? (_dns = new InputList<string>());
            set => _dns = value;
        }

        [Input("dnsOpts")]
        private InputList<string>? _dnsOpts;

        /// <summary>
        /// Set of DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        public InputList<string> DnsOpts
        {
            get => _dnsOpts ?? (_dnsOpts = new InputList<string>());
            set => _dnsOpts = value;
        }

        [Input("dnsSearches")]
        private InputList<string>? _dnsSearches;

        /// <summary>
        /// Set of DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        public InputList<string> DnsSearches
        {
            get => _dnsSearches ?? (_dnsSearches = new InputList<string>());
            set => _dnsSearches = value;
        }

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Input("domainname")]
        public Input<string>? Domainname { get; set; }

        [Input("entrypoints")]
        private InputList<string>? _entrypoints;

        /// <summary>
        /// The command to use as the
        /// Entrypoint for the container. The Entrypoint allows you to configure a
        /// container to run as an executable. For example, to run `/usr/bin/myprogram`
        /// when starting a container, set the entrypoint to be
        /// `["/usr/bin/myprogram"]`.
        /// </summary>
        public InputList<string> Entrypoints
        {
            get => _entrypoints ?? (_entrypoints = new InputList<string>());
            set => _entrypoints = value;
        }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// Environment variables to set.
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        /// <summary>
        /// The exit code of the container if its execution is done (`must_run` must be disabled).
        /// </summary>
        [Input("exitCode")]
        public Input<int>? ExitCode { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The network gateway of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Input("gateway")]
        public Input<string>? Gateway { get; set; }

        [Input("groupAdds")]
        private InputList<string>? _groupAdds;

        /// <summary>
        /// Add additional groups to run as.
        /// </summary>
        public InputList<string> GroupAdds
        {
            get => _groupAdds ?? (_groupAdds = new InputList<string>());
            set => _groupAdds = value;
        }

        /// <summary>
        /// See Healthcheck below for details.
        /// </summary>
        [Input("healthcheck")]
        public Input<Inputs.ContainerHealthcheckGetArgs>? Healthcheck { get; set; }

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        [Input("hosts")]
        private InputList<Inputs.ContainerHostGetArgs>? _hosts;

        /// <summary>
        /// Hostname to add.
        /// </summary>
        public InputList<Inputs.ContainerHostGetArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.ContainerHostGetArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// The ID of the image to back this container.
        /// The easiest way to get this value is to use the `docker.RemoteImage` resource
        /// as is shown in the example above.
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP address of the container's first network it.
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        /// <summary>
        /// *Deprecated:* Use `network_data` instead. The IP prefix length of the container as read from its
        /// NetworkSettings.
        /// </summary>
        [Input("ipPrefixLength")]
        public Input<int>? IpPrefixLength { get; set; }

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("ipcMode")]
        public Input<string>? IpcMode { get; set; }

        [Input("labels")]
        private InputList<Inputs.ContainerLabelGetArgs>? _labels;

        /// <summary>
        /// Adding labels.
        /// </summary>
        public InputList<Inputs.ContainerLabelGetArgs> Labels
        {
            get => _labels ?? (_labels = new InputList<Inputs.ContainerLabelGetArgs>());
            set => _labels = value;
        }

        [Input("links")]
        private InputList<string>? _links;

        /// <summary>
        /// Set of links for link based
        /// connectivity between containers that are running on the same host.
        /// </summary>
        [Obsolete(@"The --link flag is a legacy feature of Docker. It may eventually be removed.")]
        public InputList<string> Links
        {
            get => _links ?? (_links = new InputList<string>());
            set => _links = value;
        }

        /// <summary>
        /// The logging driver to use for the container.
        /// Defaults to "json-file".
        /// </summary>
        [Input("logDriver")]
        public Input<string>? LogDriver { get; set; }

        [Input("logOpts")]
        private InputMap<object>? _logOpts;

        /// <summary>
        /// Key/value pairs to use as options for
        /// the logging driver.
        /// </summary>
        public InputMap<object> LogOpts
        {
            get => _logOpts ?? (_logOpts = new InputMap<object>());
            set => _logOpts = value;
        }

        /// <summary>
        /// Save the container logs (`attach` must be enabled).
        /// </summary>
        [Input("logs")]
        public Input<bool>? Logs { get; set; }

        /// <summary>
        /// The maximum amount of times to an attempt
        /// a restart when `restart` is set to "on-failure"
        /// </summary>
        [Input("maxRetryCount")]
        public Input<int>? MaxRetryCount { get; set; }

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        [Input("memorySwap")]
        public Input<int>? MemorySwap { get; set; }

        [Input("mounts")]
        private InputList<Inputs.ContainerMountGetArgs>? _mounts;

        /// <summary>
        /// See Mounts below for details.
        /// </summary>
        public InputList<Inputs.ContainerMountGetArgs> Mounts
        {
            get => _mounts ?? (_mounts = new InputList<Inputs.ContainerMountGetArgs>());
            set => _mounts = value;
        }

        [Input("mustRun")]
        public Input<bool>? MustRun { get; set; }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAliases")]
        private InputList<string>? _networkAliases;

        /// <summary>
        /// Network aliases of the container for user-defined networks only. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v2.0.0")]
        public InputList<string> NetworkAliases
        {
            get => _networkAliases ?? (_networkAliases = new InputList<string>());
            set => _networkAliases = value;
        }

        [Input("networkDatas")]
        private InputList<Inputs.ContainerNetworkDataGetArgs>? _networkDatas;

        /// <summary>
        /// (Map of a block) The IP addresses of the container on each
        /// network. Key are the network names, values are the IP addresses.
        /// </summary>
        public InputList<Inputs.ContainerNetworkDataGetArgs> NetworkDatas
        {
            get => _networkDatas ?? (_networkDatas = new InputList<Inputs.ContainerNetworkDataGetArgs>());
            set => _networkDatas = value;
        }

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Input("networkMode")]
        public Input<string>? NetworkMode { get; set; }

        [Input("networks")]
        private InputList<string>? _networks;

        /// <summary>
        /// Id of the networks in which the
        /// container is. *Deprecated:* use `networks_advanced` instead.
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v2.0.0")]
        public InputList<string> Networks
        {
            get => _networks ?? (_networks = new InputList<string>());
            set => _networks = value;
        }

        [Input("networksAdvanced")]
        private InputList<Inputs.ContainerNetworksAdvancedGetArgs>? _networksAdvanced;

        /// <summary>
        /// See Networks Advanced below for details. If this block has priority to the deprecated `network_alias` and `network` properties.
        /// </summary>
        public InputList<Inputs.ContainerNetworksAdvancedGetArgs> NetworksAdvanced
        {
            get => _networksAdvanced ?? (_networksAdvanced = new InputList<Inputs.ContainerNetworksAdvancedGetArgs>());
            set => _networksAdvanced = value;
        }

        /// <summary>
        /// The PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("pidMode")]
        public Input<string>? PidMode { get; set; }

        [Input("ports")]
        private InputList<Inputs.ContainerPortGetArgs>? _ports;

        /// <summary>
        /// See Ports below for details.
        /// </summary>
        public InputList<Inputs.ContainerPortGetArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Inputs.ContainerPortGetArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// Run container in privileged mode.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Input("publishAllPorts")]
        public Input<bool>? PublishAllPorts { get; set; }

        /// <summary>
        /// If true, this volume will be readonly.
        /// Defaults to false.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// The restart policy for the container. Must be
        /// one of "no", "on-failure", "always", "unless-stopped".
        /// </summary>
        [Input("restart")]
        public Input<string>? Restart { get; set; }

        [Input("rm")]
        public Input<bool>? Rm { get; set; }

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Input("shmSize")]
        public Input<int>? ShmSize { get; set; }

        /// <summary>
        /// If true, then the Docker container will be
        /// started after creation. If false, then the container is only created.
        /// </summary>
        [Input("start")]
        public Input<bool>? Start { get; set; }

        [Input("sysctls")]
        private InputMap<object>? _sysctls;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        public InputMap<object> Sysctls
        {
            get => _sysctls ?? (_sysctls = new InputMap<object>());
            set => _sysctls = value;
        }

        [Input("tmpfs")]
        private InputMap<object>? _tmpfs;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        public InputMap<object> Tmpfs
        {
            get => _tmpfs ?? (_tmpfs = new InputMap<object>());
            set => _tmpfs = value;
        }

        [Input("ulimits")]
        private InputList<Inputs.ContainerUlimitGetArgs>? _ulimits;

        /// <summary>
        /// See Ulimits below for
        /// details.
        /// </summary>
        public InputList<Inputs.ContainerUlimitGetArgs> Ulimits
        {
            get => _ulimits ?? (_ulimits = new InputList<Inputs.ContainerUlimitGetArgs>());
            set => _ulimits = value;
        }

        [Input("uploads")]
        private InputList<Inputs.ContainerUploadGetArgs>? _uploads;

        /// <summary>
        /// See File Upload below for details.
        /// </summary>
        public InputList<Inputs.ContainerUploadGetArgs> Uploads
        {
            get => _uploads ?? (_uploads = new InputList<Inputs.ContainerUploadGetArgs>());
            set => _uploads = value;
        }

        /// <summary>
        /// User used for run the first process. Format is
        /// `user` or `user:group` which user and group can be passed literraly or
        /// by name.
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Input("usernsMode")]
        public Input<string>? UsernsMode { get; set; }

        [Input("volumes")]
        private InputList<Inputs.ContainerVolumeGetArgs>? _volumes;

        /// <summary>
        /// See Volumes below for details.
        /// </summary>
        public InputList<Inputs.ContainerVolumeGetArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Inputs.ContainerVolumeGetArgs>());
            set => _volumes = value;
        }

        /// <summary>
        /// The working directory for commands to run in
        /// </summary>
        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

        public ContainerState()
        {
        }
    }
}
