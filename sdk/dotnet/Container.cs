// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Docker
{
    /// <summary>
    /// &lt;!-- Bug: Type and Name are switched --&gt;
    /// Manages the lifecycle of a Docker container.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using Docker = Pulumi.Docker;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Find the latest Ubuntu precise image.
    ///     var ubuntuRemoteImage = new Docker.RemoteImage("ubuntuRemoteImage", new()
    ///     {
    ///         Name = "ubuntu:precise",
    ///     });
    /// 
    ///     // Start a container
    ///     var ubuntuContainer = new Docker.Container("ubuntuContainer", new()
    ///     {
    ///         Image = ubuntuRemoteImage.ImageId,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// ### Example Assuming you created a `container` as follows #!/bin/bash docker run --name foo -p8080:80 -d nginx
    /// 
    /// # prints the container ID
    /// 
    /// 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd you provide the definition for the resource as follows terraform resource "docker_container" "foo" {
    /// 
    ///  name
    /// 
    /// = "foo"
    /// 
    ///  image = "nginx"
    /// 
    ///  ports {
    /// 
    ///  internal = "80"
    /// 
    ///  external = "8080"
    /// 
    ///  } } then the import command is as follows #!/bin/bash
    /// 
    /// ```sh
    ///  $ pulumi import docker:index/container:Container foo 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd
    /// ```
    /// </summary>
    [DockerResourceType("docker:index/container:Container")]
    public partial class Container : global::Pulumi.CustomResource
    {
        /// <summary>
        /// If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
        /// </summary>
        [Output("attach")]
        public Output<bool?> Attach { get; private set; } = null!;

        /// <summary>
        /// The network bridge of the container as read from its NetworkSettings.
        /// </summary>
        [Output("bridge")]
        public Output<string> Bridge { get; private set; } = null!;

        /// <summary>
        /// Add or drop certrain linux capabilities.
        /// </summary>
        [Output("capabilities")]
        public Output<Outputs.ContainerCapabilities?> Capabilities { get; private set; } = null!;

        /// <summary>
        /// The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `["/usr/bin/myprogram","-","baz.con"]`.
        /// </summary>
        [Output("command")]
        public Output<ImmutableArray<string>> Command { get; private set; } = null!;

        /// <summary>
        /// The logs of the container if its execution is done (`attach` must be disabled).
        /// </summary>
        [Output("containerLogs")]
        public Output<string> ContainerLogs { get; private set; } = null!;

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Output("cpuSet")]
        public Output<string?> CpuSet { get; private set; } = null!;

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Output("cpuShares")]
        public Output<int?> CpuShares { get; private set; } = null!;

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Output("destroyGraceSeconds")]
        public Output<int?> DestroyGraceSeconds { get; private set; } = null!;

        /// <summary>
        /// Bind devices to the container.
        /// </summary>
        [Output("devices")]
        public Output<ImmutableArray<Outputs.ContainerDevice>> Devices { get; private set; } = null!;

        /// <summary>
        /// DNS servers to use.
        /// </summary>
        [Output("dns")]
        public Output<ImmutableArray<string>> Dns { get; private set; } = null!;

        /// <summary>
        /// DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        [Output("dnsOpts")]
        public Output<ImmutableArray<string>> DnsOpts { get; private set; } = null!;

        /// <summary>
        /// DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        [Output("dnsSearches")]
        public Output<ImmutableArray<string>> DnsSearches { get; private set; } = null!;

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Output("domainname")]
        public Output<string?> Domainname { get; private set; } = null!;

        /// <summary>
        /// The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `"/usr/bin/myprogra"]`.
        /// </summary>
        [Output("entrypoints")]
        public Output<ImmutableArray<string>> Entrypoints { get; private set; } = null!;

        /// <summary>
        /// Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
        /// </summary>
        [Output("envs")]
        public Output<ImmutableArray<string>> Envs { get; private set; } = null!;

        /// <summary>
        /// The exit code of the container if its execution is done (`must_run` must be disabled).
        /// </summary>
        [Output("exitCode")]
        public Output<int> ExitCode { get; private set; } = null!;

        /// <summary>
        /// The network gateway of the container.
        /// </summary>
        [Output("gateway")]
        public Output<string> Gateway { get; private set; } = null!;

        /// <summary>
        /// GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.
        /// </summary>
        [Output("gpus")]
        public Output<string?> Gpus { get; private set; } = null!;

        /// <summary>
        /// Additional groups for the container user
        /// </summary>
        [Output("groupAdds")]
        public Output<ImmutableArray<string>> GroupAdds { get; private set; } = null!;

        /// <summary>
        /// A test to perform to check that the container is healthy
        /// </summary>
        [Output("healthcheck")]
        public Output<Outputs.ContainerHealthcheck> Healthcheck { get; private set; } = null!;

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Output("hostname")]
        public Output<string> Hostname { get; private set; } = null!;

        /// <summary>
        /// Additional hosts to add to the container.
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<Outputs.ContainerHost>> Hosts { get; private set; } = null!;

        /// <summary>
        /// The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.
        /// </summary>
        [Output("image")]
        public Output<string> Image { get; private set; } = null!;

        /// <summary>
        /// Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.
        /// </summary>
        [Output("init")]
        public Output<bool> Init { get; private set; } = null!;

        /// <summary>
        /// The IP address of the container.
        /// </summary>
        [Output("ipAddress")]
        public Output<string> IpAddress { get; private set; } = null!;

        /// <summary>
        /// The IP prefix length of the container.
        /// </summary>
        [Output("ipPrefixLength")]
        public Output<int> IpPrefixLength { get; private set; } = null!;

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Output("ipcMode")]
        public Output<string> IpcMode { get; private set; } = null!;

        /// <summary>
        /// User-defined key/value metadata
        /// </summary>
        [Output("labels")]
        public Output<ImmutableArray<Outputs.ContainerLabel>> Labels { get; private set; } = null!;

        /// <summary>
        /// Set of links for link based connectivity between containers that are running on the same host.
        /// </summary>
        [Output("links")]
        public Output<ImmutableArray<string>> Links { get; private set; } = null!;

        /// <summary>
        /// The logging driver to use for the container.
        /// </summary>
        [Output("logDriver")]
        public Output<string> LogDriver { get; private set; } = null!;

        /// <summary>
        /// Key/value pairs to use as options for the logging driver.
        /// </summary>
        [Output("logOpts")]
        public Output<ImmutableDictionary<string, object>?> LogOpts { get; private set; } = null!;

        /// <summary>
        /// Save the container logs (`attach` must be enabled). Defaults to `false`.
        /// </summary>
        [Output("logs")]
        public Output<bool?> Logs { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.
        /// </summary>
        [Output("maxRetryCount")]
        public Output<int?> MaxRetryCount { get; private set; } = null!;

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Output("memory")]
        public Output<int?> Memory { get; private set; } = null!;

        /// <summary>
        /// The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform
        /// apply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.
        /// </summary>
        [Output("memorySwap")]
        public Output<int?> MemorySwap { get; private set; } = null!;

        /// <summary>
        /// Specification for mounts to be added to containers created as part of the service.
        /// </summary>
        [Output("mounts")]
        public Output<ImmutableArray<Outputs.ContainerMount>> Mounts { get; private set; } = null!;

        /// <summary>
        /// If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
        /// assumes it is successful. Defaults to `true`.
        /// </summary>
        [Output("mustRun")]
        public Output<bool?> MustRun { get; private set; } = null!;

        /// <summary>
        /// The name of the container.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Set an alias for the container in all specified networks
        /// </summary>
        [Output("networkAliases")]
        public Output<ImmutableArray<string>> NetworkAliases { get; private set; } = null!;

        /// <summary>
        /// The data of the networks the container is connected to.
        /// </summary>
        [Output("networkDatas")]
        public Output<ImmutableArray<Outputs.ContainerNetworkData>> NetworkDatas { get; private set; } = null!;

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Output("networkMode")]
        public Output<string?> NetworkMode { get; private set; } = null!;

        /// <summary>
        /// ID of the networks in which the container is.
        /// </summary>
        [Output("networks")]
        public Output<ImmutableArray<string>> Networks { get; private set; } = null!;

        /// <summary>
        /// The networks the container is attached to
        /// </summary>
        [Output("networksAdvanced")]
        public Output<ImmutableArray<Outputs.ContainerNetworksAdvanced>> NetworksAdvanced { get; private set; } = null!;

        /// <summary>
        /// he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Output("pidMode")]
        public Output<string?> PidMode { get; private set; } = null!;

        /// <summary>
        /// Publish a container's port(s) to the host.
        /// </summary>
        [Output("ports")]
        public Output<ImmutableArray<Outputs.ContainerPort>> Ports { get; private set; } = null!;

        /// <summary>
        /// If `true`, the container runs in privileged mode.
        /// </summary>
        [Output("privileged")]
        public Output<bool?> Privileged { get; private set; } = null!;

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Output("publishAllPorts")]
        public Output<bool?> PublishAllPorts { get; private set; } = null!;

        /// <summary>
        /// If `true`, the container will be started as readonly. Defaults to `false`.
        /// </summary>
        [Output("readOnly")]
        public Output<bool?> ReadOnly { get; private set; } = null!;

        /// <summary>
        /// If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
        /// </summary>
        [Output("removeVolumes")]
        public Output<bool?> RemoveVolumes { get; private set; } = null!;

        /// <summary>
        /// The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.
        /// </summary>
        [Output("restart")]
        public Output<string?> Restart { get; private set; } = null!;

        /// <summary>
        /// If `true`, then the container will be automatically removed when it exits. Defaults to `false`.
        /// </summary>
        [Output("rm")]
        public Output<bool?> Rm { get; private set; } = null!;

        /// <summary>
        /// Runtime to use for the container.
        /// </summary>
        [Output("runtime")]
        public Output<string> Runtime { get; private set; } = null!;

        /// <summary>
        /// List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
        /// </summary>
        [Output("securityOpts")]
        public Output<ImmutableArray<string>> SecurityOpts { get; private set; } = null!;

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Output("shmSize")]
        public Output<int> ShmSize { get; private set; } = null!;

        /// <summary>
        /// If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.
        /// </summary>
        [Output("start")]
        public Output<bool?> Start { get; private set; } = null!;

        /// <summary>
        /// If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
        /// </summary>
        [Output("stdinOpen")]
        public Output<bool?> StdinOpen { get; private set; } = null!;

        /// <summary>
        /// Signal to stop a container (default `SIGTERM`).
        /// </summary>
        [Output("stopSignal")]
        public Output<string> StopSignal { get; private set; } = null!;

        /// <summary>
        /// Timeout (in seconds) to stop a container.
        /// </summary>
        [Output("stopTimeout")]
        public Output<int> StopTimeout { get; private set; } = null!;

        /// <summary>
        /// Key/value pairs for the storage driver options, e.g. `size`: `120G`
        /// </summary>
        [Output("storageOpts")]
        public Output<ImmutableDictionary<string, object>?> StorageOpts { get; private set; } = null!;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        [Output("sysctls")]
        public Output<ImmutableDictionary<string, object>?> Sysctls { get; private set; } = null!;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        [Output("tmpfs")]
        public Output<ImmutableDictionary<string, object>?> Tmpfs { get; private set; } = null!;

        /// <summary>
        /// If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
        /// </summary>
        [Output("tty")]
        public Output<bool?> Tty { get; private set; } = null!;

        /// <summary>
        /// Ulimit options to add.
        /// </summary>
        [Output("ulimits")]
        public Output<ImmutableArray<Outputs.ContainerUlimit>> Ulimits { get; private set; } = null!;

        /// <summary>
        /// Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
        /// </summary>
        [Output("uploads")]
        public Output<ImmutableArray<Outputs.ContainerUpload>> Uploads { get; private set; } = null!;

        /// <summary>
        /// User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.
        /// </summary>
        [Output("user")]
        public Output<string?> User { get; private set; } = null!;

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Output("usernsMode")]
        public Output<string?> UsernsMode { get; private set; } = null!;

        /// <summary>
        /// Spec for mounting volumes in the container.
        /// </summary>
        [Output("volumes")]
        public Output<ImmutableArray<Outputs.ContainerVolume>> Volumes { get; private set; } = null!;

        /// <summary>
        /// The working directory for commands to run in.
        /// </summary>
        [Output("workingDir")]
        public Output<string?> WorkingDir { get; private set; } = null!;


        /// <summary>
        /// Create a Container resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Container(string name, ContainerArgs args, CustomResourceOptions? options = null)
            : base("docker:index/container:Container", name, args ?? new ContainerArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Container(string name, Input<string> id, ContainerState? state = null, CustomResourceOptions? options = null)
            : base("docker:index/container:Container", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Container resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Container Get(string name, Input<string> id, ContainerState? state = null, CustomResourceOptions? options = null)
        {
            return new Container(name, id, state, options);
        }
    }

    public sealed class ContainerArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// Add or drop certrain linux capabilities.
        /// </summary>
        [Input("capabilities")]
        public Input<Inputs.ContainerCapabilitiesArgs>? Capabilities { get; set; }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `["/usr/bin/myprogram","-","baz.con"]`.
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Input("cpuSet")]
        public Input<string>? CpuSet { get; set; }

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Input("destroyGraceSeconds")]
        public Input<int>? DestroyGraceSeconds { get; set; }

        [Input("devices")]
        private InputList<Inputs.ContainerDeviceArgs>? _devices;

        /// <summary>
        /// Bind devices to the container.
        /// </summary>
        public InputList<Inputs.ContainerDeviceArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.ContainerDeviceArgs>());
            set => _devices = value;
        }

        [Input("dns")]
        private InputList<string>? _dns;

        /// <summary>
        /// DNS servers to use.
        /// </summary>
        public InputList<string> Dns
        {
            get => _dns ?? (_dns = new InputList<string>());
            set => _dns = value;
        }

        [Input("dnsOpts")]
        private InputList<string>? _dnsOpts;

        /// <summary>
        /// DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        public InputList<string> DnsOpts
        {
            get => _dnsOpts ?? (_dnsOpts = new InputList<string>());
            set => _dnsOpts = value;
        }

        [Input("dnsSearches")]
        private InputList<string>? _dnsSearches;

        /// <summary>
        /// DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        public InputList<string> DnsSearches
        {
            get => _dnsSearches ?? (_dnsSearches = new InputList<string>());
            set => _dnsSearches = value;
        }

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Input("domainname")]
        public Input<string>? Domainname { get; set; }

        [Input("entrypoints")]
        private InputList<string>? _entrypoints;

        /// <summary>
        /// The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `"/usr/bin/myprogra"]`.
        /// </summary>
        public InputList<string> Entrypoints
        {
            get => _entrypoints ?? (_entrypoints = new InputList<string>());
            set => _entrypoints = value;
        }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        /// <summary>
        /// GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.
        /// </summary>
        [Input("gpus")]
        public Input<string>? Gpus { get; set; }

        [Input("groupAdds")]
        private InputList<string>? _groupAdds;

        /// <summary>
        /// Additional groups for the container user
        /// </summary>
        public InputList<string> GroupAdds
        {
            get => _groupAdds ?? (_groupAdds = new InputList<string>());
            set => _groupAdds = value;
        }

        /// <summary>
        /// A test to perform to check that the container is healthy
        /// </summary>
        [Input("healthcheck")]
        public Input<Inputs.ContainerHealthcheckArgs>? Healthcheck { get; set; }

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        [Input("hosts")]
        private InputList<Inputs.ContainerHostArgs>? _hosts;

        /// <summary>
        /// Additional hosts to add to the container.
        /// </summary>
        public InputList<Inputs.ContainerHostArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.ContainerHostArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.
        /// </summary>
        [Input("image", required: true)]
        public Input<string> Image { get; set; } = null!;

        /// <summary>
        /// Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.
        /// </summary>
        [Input("init")]
        public Input<bool>? Init { get; set; }

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("ipcMode")]
        public Input<string>? IpcMode { get; set; }

        [Input("labels")]
        private InputList<Inputs.ContainerLabelArgs>? _labels;

        /// <summary>
        /// User-defined key/value metadata
        /// </summary>
        public InputList<Inputs.ContainerLabelArgs> Labels
        {
            get => _labels ?? (_labels = new InputList<Inputs.ContainerLabelArgs>());
            set => _labels = value;
        }

        [Input("links")]
        private InputList<string>? _links;

        /// <summary>
        /// Set of links for link based connectivity between containers that are running on the same host.
        /// </summary>
        [Obsolete(@"The --link flag is a legacy feature of Docker. It may eventually be removed.")]
        public InputList<string> Links
        {
            get => _links ?? (_links = new InputList<string>());
            set => _links = value;
        }

        /// <summary>
        /// The logging driver to use for the container.
        /// </summary>
        [Input("logDriver")]
        public Input<string>? LogDriver { get; set; }

        [Input("logOpts")]
        private InputMap<object>? _logOpts;

        /// <summary>
        /// Key/value pairs to use as options for the logging driver.
        /// </summary>
        public InputMap<object> LogOpts
        {
            get => _logOpts ?? (_logOpts = new InputMap<object>());
            set => _logOpts = value;
        }

        /// <summary>
        /// Save the container logs (`attach` must be enabled). Defaults to `false`.
        /// </summary>
        [Input("logs")]
        public Input<bool>? Logs { get; set; }

        /// <summary>
        /// The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.
        /// </summary>
        [Input("maxRetryCount")]
        public Input<int>? MaxRetryCount { get; set; }

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform
        /// apply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.
        /// </summary>
        [Input("memorySwap")]
        public Input<int>? MemorySwap { get; set; }

        [Input("mounts")]
        private InputList<Inputs.ContainerMountArgs>? _mounts;

        /// <summary>
        /// Specification for mounts to be added to containers created as part of the service.
        /// </summary>
        public InputList<Inputs.ContainerMountArgs> Mounts
        {
            get => _mounts ?? (_mounts = new InputList<Inputs.ContainerMountArgs>());
            set => _mounts = value;
        }

        /// <summary>
        /// If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
        /// assumes it is successful. Defaults to `true`.
        /// </summary>
        [Input("mustRun")]
        public Input<bool>? MustRun { get; set; }

        /// <summary>
        /// The name of the container.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAliases")]
        private InputList<string>? _networkAliases;

        /// <summary>
        /// Set an alias for the container in all specified networks
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v3.0.0")]
        public InputList<string> NetworkAliases
        {
            get => _networkAliases ?? (_networkAliases = new InputList<string>());
            set => _networkAliases = value;
        }

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Input("networkMode")]
        public Input<string>? NetworkMode { get; set; }

        [Input("networks")]
        private InputList<string>? _networks;

        /// <summary>
        /// ID of the networks in which the container is.
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v3.0.0")]
        public InputList<string> Networks
        {
            get => _networks ?? (_networks = new InputList<string>());
            set => _networks = value;
        }

        [Input("networksAdvanced")]
        private InputList<Inputs.ContainerNetworksAdvancedArgs>? _networksAdvanced;

        /// <summary>
        /// The networks the container is attached to
        /// </summary>
        public InputList<Inputs.ContainerNetworksAdvancedArgs> NetworksAdvanced
        {
            get => _networksAdvanced ?? (_networksAdvanced = new InputList<Inputs.ContainerNetworksAdvancedArgs>());
            set => _networksAdvanced = value;
        }

        /// <summary>
        /// he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("pidMode")]
        public Input<string>? PidMode { get; set; }

        [Input("ports")]
        private InputList<Inputs.ContainerPortArgs>? _ports;

        /// <summary>
        /// Publish a container's port(s) to the host.
        /// </summary>
        public InputList<Inputs.ContainerPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Inputs.ContainerPortArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// If `true`, the container runs in privileged mode.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Input("publishAllPorts")]
        public Input<bool>? PublishAllPorts { get; set; }

        /// <summary>
        /// If `true`, the container will be started as readonly. Defaults to `false`.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
        /// </summary>
        [Input("removeVolumes")]
        public Input<bool>? RemoveVolumes { get; set; }

        /// <summary>
        /// The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.
        /// </summary>
        [Input("restart")]
        public Input<string>? Restart { get; set; }

        /// <summary>
        /// If `true`, then the container will be automatically removed when it exits. Defaults to `false`.
        /// </summary>
        [Input("rm")]
        public Input<bool>? Rm { get; set; }

        /// <summary>
        /// Runtime to use for the container.
        /// </summary>
        [Input("runtime")]
        public Input<string>? Runtime { get; set; }

        [Input("securityOpts")]
        private InputList<string>? _securityOpts;

        /// <summary>
        /// List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
        /// </summary>
        public InputList<string> SecurityOpts
        {
            get => _securityOpts ?? (_securityOpts = new InputList<string>());
            set => _securityOpts = value;
        }

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Input("shmSize")]
        public Input<int>? ShmSize { get; set; }

        /// <summary>
        /// If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.
        /// </summary>
        [Input("start")]
        public Input<bool>? Start { get; set; }

        /// <summary>
        /// If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
        /// </summary>
        [Input("stdinOpen")]
        public Input<bool>? StdinOpen { get; set; }

        /// <summary>
        /// Signal to stop a container (default `SIGTERM`).
        /// </summary>
        [Input("stopSignal")]
        public Input<string>? StopSignal { get; set; }

        /// <summary>
        /// Timeout (in seconds) to stop a container.
        /// </summary>
        [Input("stopTimeout")]
        public Input<int>? StopTimeout { get; set; }

        [Input("storageOpts")]
        private InputMap<object>? _storageOpts;

        /// <summary>
        /// Key/value pairs for the storage driver options, e.g. `size`: `120G`
        /// </summary>
        public InputMap<object> StorageOpts
        {
            get => _storageOpts ?? (_storageOpts = new InputMap<object>());
            set => _storageOpts = value;
        }

        [Input("sysctls")]
        private InputMap<object>? _sysctls;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        public InputMap<object> Sysctls
        {
            get => _sysctls ?? (_sysctls = new InputMap<object>());
            set => _sysctls = value;
        }

        [Input("tmpfs")]
        private InputMap<object>? _tmpfs;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        public InputMap<object> Tmpfs
        {
            get => _tmpfs ?? (_tmpfs = new InputMap<object>());
            set => _tmpfs = value;
        }

        /// <summary>
        /// If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
        /// </summary>
        [Input("tty")]
        public Input<bool>? Tty { get; set; }

        [Input("ulimits")]
        private InputList<Inputs.ContainerUlimitArgs>? _ulimits;

        /// <summary>
        /// Ulimit options to add.
        /// </summary>
        public InputList<Inputs.ContainerUlimitArgs> Ulimits
        {
            get => _ulimits ?? (_ulimits = new InputList<Inputs.ContainerUlimitArgs>());
            set => _ulimits = value;
        }

        [Input("uploads")]
        private InputList<Inputs.ContainerUploadArgs>? _uploads;

        /// <summary>
        /// Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
        /// </summary>
        public InputList<Inputs.ContainerUploadArgs> Uploads
        {
            get => _uploads ?? (_uploads = new InputList<Inputs.ContainerUploadArgs>());
            set => _uploads = value;
        }

        /// <summary>
        /// User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Input("usernsMode")]
        public Input<string>? UsernsMode { get; set; }

        [Input("volumes")]
        private InputList<Inputs.ContainerVolumeArgs>? _volumes;

        /// <summary>
        /// Spec for mounting volumes in the container.
        /// </summary>
        public InputList<Inputs.ContainerVolumeArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Inputs.ContainerVolumeArgs>());
            set => _volumes = value;
        }

        /// <summary>
        /// The working directory for commands to run in.
        /// </summary>
        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

        public ContainerArgs()
        {
        }
        public static new ContainerArgs Empty => new ContainerArgs();
    }

    public sealed class ContainerState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// The network bridge of the container as read from its NetworkSettings.
        /// </summary>
        [Input("bridge")]
        public Input<string>? Bridge { get; set; }

        /// <summary>
        /// Add or drop certrain linux capabilities.
        /// </summary>
        [Input("capabilities")]
        public Input<Inputs.ContainerCapabilitiesGetArgs>? Capabilities { get; set; }

        [Input("command")]
        private InputList<string>? _command;

        /// <summary>
        /// The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `["/usr/bin/myprogram","-","baz.con"]`.
        /// </summary>
        public InputList<string> Command
        {
            get => _command ?? (_command = new InputList<string>());
            set => _command = value;
        }

        /// <summary>
        /// The logs of the container if its execution is done (`attach` must be disabled).
        /// </summary>
        [Input("containerLogs")]
        public Input<string>? ContainerLogs { get; set; }

        /// <summary>
        /// A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
        /// </summary>
        [Input("cpuSet")]
        public Input<string>? CpuSet { get; set; }

        /// <summary>
        /// CPU shares (relative weight) for the container.
        /// </summary>
        [Input("cpuShares")]
        public Input<int>? CpuShares { get; set; }

        /// <summary>
        /// If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
        /// </summary>
        [Input("destroyGraceSeconds")]
        public Input<int>? DestroyGraceSeconds { get; set; }

        [Input("devices")]
        private InputList<Inputs.ContainerDeviceGetArgs>? _devices;

        /// <summary>
        /// Bind devices to the container.
        /// </summary>
        public InputList<Inputs.ContainerDeviceGetArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.ContainerDeviceGetArgs>());
            set => _devices = value;
        }

        [Input("dns")]
        private InputList<string>? _dns;

        /// <summary>
        /// DNS servers to use.
        /// </summary>
        public InputList<string> Dns
        {
            get => _dns ?? (_dns = new InputList<string>());
            set => _dns = value;
        }

        [Input("dnsOpts")]
        private InputList<string>? _dnsOpts;

        /// <summary>
        /// DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
        /// </summary>
        public InputList<string> DnsOpts
        {
            get => _dnsOpts ?? (_dnsOpts = new InputList<string>());
            set => _dnsOpts = value;
        }

        [Input("dnsSearches")]
        private InputList<string>? _dnsSearches;

        /// <summary>
        /// DNS search domains that are used when bare unqualified hostnames are used inside of the container.
        /// </summary>
        public InputList<string> DnsSearches
        {
            get => _dnsSearches ?? (_dnsSearches = new InputList<string>());
            set => _dnsSearches = value;
        }

        /// <summary>
        /// Domain name of the container.
        /// </summary>
        [Input("domainname")]
        public Input<string>? Domainname { get; set; }

        [Input("entrypoints")]
        private InputList<string>? _entrypoints;

        /// <summary>
        /// The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `"/usr/bin/myprogra"]`.
        /// </summary>
        public InputList<string> Entrypoints
        {
            get => _entrypoints ?? (_entrypoints = new InputList<string>());
            set => _entrypoints = value;
        }

        [Input("envs")]
        private InputList<string>? _envs;

        /// <summary>
        /// Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
        /// </summary>
        public InputList<string> Envs
        {
            get => _envs ?? (_envs = new InputList<string>());
            set => _envs = value;
        }

        /// <summary>
        /// The exit code of the container if its execution is done (`must_run` must be disabled).
        /// </summary>
        [Input("exitCode")]
        public Input<int>? ExitCode { get; set; }

        /// <summary>
        /// The network gateway of the container.
        /// </summary>
        [Input("gateway")]
        public Input<string>? Gateway { get; set; }

        /// <summary>
        /// GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.
        /// </summary>
        [Input("gpus")]
        public Input<string>? Gpus { get; set; }

        [Input("groupAdds")]
        private InputList<string>? _groupAdds;

        /// <summary>
        /// Additional groups for the container user
        /// </summary>
        public InputList<string> GroupAdds
        {
            get => _groupAdds ?? (_groupAdds = new InputList<string>());
            set => _groupAdds = value;
        }

        /// <summary>
        /// A test to perform to check that the container is healthy
        /// </summary>
        [Input("healthcheck")]
        public Input<Inputs.ContainerHealthcheckGetArgs>? Healthcheck { get; set; }

        /// <summary>
        /// Hostname of the container.
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        [Input("hosts")]
        private InputList<Inputs.ContainerHostGetArgs>? _hosts;

        /// <summary>
        /// Additional hosts to add to the container.
        /// </summary>
        public InputList<Inputs.ContainerHostGetArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.ContainerHostGetArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        /// <summary>
        /// Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.
        /// </summary>
        [Input("init")]
        public Input<bool>? Init { get; set; }

        /// <summary>
        /// The IP address of the container.
        /// </summary>
        [Input("ipAddress")]
        public Input<string>? IpAddress { get; set; }

        /// <summary>
        /// The IP prefix length of the container.
        /// </summary>
        [Input("ipPrefixLength")]
        public Input<int>? IpPrefixLength { get; set; }

        /// <summary>
        /// IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("ipcMode")]
        public Input<string>? IpcMode { get; set; }

        [Input("labels")]
        private InputList<Inputs.ContainerLabelGetArgs>? _labels;

        /// <summary>
        /// User-defined key/value metadata
        /// </summary>
        public InputList<Inputs.ContainerLabelGetArgs> Labels
        {
            get => _labels ?? (_labels = new InputList<Inputs.ContainerLabelGetArgs>());
            set => _labels = value;
        }

        [Input("links")]
        private InputList<string>? _links;

        /// <summary>
        /// Set of links for link based connectivity between containers that are running on the same host.
        /// </summary>
        [Obsolete(@"The --link flag is a legacy feature of Docker. It may eventually be removed.")]
        public InputList<string> Links
        {
            get => _links ?? (_links = new InputList<string>());
            set => _links = value;
        }

        /// <summary>
        /// The logging driver to use for the container.
        /// </summary>
        [Input("logDriver")]
        public Input<string>? LogDriver { get; set; }

        [Input("logOpts")]
        private InputMap<object>? _logOpts;

        /// <summary>
        /// Key/value pairs to use as options for the logging driver.
        /// </summary>
        public InputMap<object> LogOpts
        {
            get => _logOpts ?? (_logOpts = new InputMap<object>());
            set => _logOpts = value;
        }

        /// <summary>
        /// Save the container logs (`attach` must be enabled). Defaults to `false`.
        /// </summary>
        [Input("logs")]
        public Input<bool>? Logs { get; set; }

        /// <summary>
        /// The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.
        /// </summary>
        [Input("maxRetryCount")]
        public Input<int>? MaxRetryCount { get; set; }

        /// <summary>
        /// The memory limit for the container in MBs.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform
        /// apply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.
        /// </summary>
        [Input("memorySwap")]
        public Input<int>? MemorySwap { get; set; }

        [Input("mounts")]
        private InputList<Inputs.ContainerMountGetArgs>? _mounts;

        /// <summary>
        /// Specification for mounts to be added to containers created as part of the service.
        /// </summary>
        public InputList<Inputs.ContainerMountGetArgs> Mounts
        {
            get => _mounts ?? (_mounts = new InputList<Inputs.ContainerMountGetArgs>());
            set => _mounts = value;
        }

        /// <summary>
        /// If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
        /// assumes it is successful. Defaults to `true`.
        /// </summary>
        [Input("mustRun")]
        public Input<bool>? MustRun { get; set; }

        /// <summary>
        /// The name of the container.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAliases")]
        private InputList<string>? _networkAliases;

        /// <summary>
        /// Set an alias for the container in all specified networks
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v3.0.0")]
        public InputList<string> NetworkAliases
        {
            get => _networkAliases ?? (_networkAliases = new InputList<string>());
            set => _networkAliases = value;
        }

        [Input("networkDatas")]
        private InputList<Inputs.ContainerNetworkDataGetArgs>? _networkDatas;

        /// <summary>
        /// The data of the networks the container is connected to.
        /// </summary>
        public InputList<Inputs.ContainerNetworkDataGetArgs> NetworkDatas
        {
            get => _networkDatas ?? (_networkDatas = new InputList<Inputs.ContainerNetworkDataGetArgs>());
            set => _networkDatas = value;
        }

        /// <summary>
        /// Network mode of the container.
        /// </summary>
        [Input("networkMode")]
        public Input<string>? NetworkMode { get; set; }

        [Input("networks")]
        private InputList<string>? _networks;

        /// <summary>
        /// ID of the networks in which the container is.
        /// </summary>
        [Obsolete(@"Use networks_advanced instead. Will be removed in v3.0.0")]
        public InputList<string> Networks
        {
            get => _networks ?? (_networks = new InputList<string>());
            set => _networks = value;
        }

        [Input("networksAdvanced")]
        private InputList<Inputs.ContainerNetworksAdvancedGetArgs>? _networksAdvanced;

        /// <summary>
        /// The networks the container is attached to
        /// </summary>
        public InputList<Inputs.ContainerNetworksAdvancedGetArgs> NetworksAdvanced
        {
            get => _networksAdvanced ?? (_networksAdvanced = new InputList<Inputs.ContainerNetworksAdvancedGetArgs>());
            set => _networksAdvanced = value;
        }

        /// <summary>
        /// he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
        /// </summary>
        [Input("pidMode")]
        public Input<string>? PidMode { get; set; }

        [Input("ports")]
        private InputList<Inputs.ContainerPortGetArgs>? _ports;

        /// <summary>
        /// Publish a container's port(s) to the host.
        /// </summary>
        public InputList<Inputs.ContainerPortGetArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Inputs.ContainerPortGetArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// If `true`, the container runs in privileged mode.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// Publish all ports of the container.
        /// </summary>
        [Input("publishAllPorts")]
        public Input<bool>? PublishAllPorts { get; set; }

        /// <summary>
        /// If `true`, the container will be started as readonly. Defaults to `false`.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
        /// </summary>
        [Input("removeVolumes")]
        public Input<bool>? RemoveVolumes { get; set; }

        /// <summary>
        /// The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.
        /// </summary>
        [Input("restart")]
        public Input<string>? Restart { get; set; }

        /// <summary>
        /// If `true`, then the container will be automatically removed when it exits. Defaults to `false`.
        /// </summary>
        [Input("rm")]
        public Input<bool>? Rm { get; set; }

        /// <summary>
        /// Runtime to use for the container.
        /// </summary>
        [Input("runtime")]
        public Input<string>? Runtime { get; set; }

        [Input("securityOpts")]
        private InputList<string>? _securityOpts;

        /// <summary>
        /// List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
        /// </summary>
        public InputList<string> SecurityOpts
        {
            get => _securityOpts ?? (_securityOpts = new InputList<string>());
            set => _securityOpts = value;
        }

        /// <summary>
        /// Size of `/dev/shm` in MBs.
        /// </summary>
        [Input("shmSize")]
        public Input<int>? ShmSize { get; set; }

        /// <summary>
        /// If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.
        /// </summary>
        [Input("start")]
        public Input<bool>? Start { get; set; }

        /// <summary>
        /// If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
        /// </summary>
        [Input("stdinOpen")]
        public Input<bool>? StdinOpen { get; set; }

        /// <summary>
        /// Signal to stop a container (default `SIGTERM`).
        /// </summary>
        [Input("stopSignal")]
        public Input<string>? StopSignal { get; set; }

        /// <summary>
        /// Timeout (in seconds) to stop a container.
        /// </summary>
        [Input("stopTimeout")]
        public Input<int>? StopTimeout { get; set; }

        [Input("storageOpts")]
        private InputMap<object>? _storageOpts;

        /// <summary>
        /// Key/value pairs for the storage driver options, e.g. `size`: `120G`
        /// </summary>
        public InputMap<object> StorageOpts
        {
            get => _storageOpts ?? (_storageOpts = new InputMap<object>());
            set => _storageOpts = value;
        }

        [Input("sysctls")]
        private InputMap<object>? _sysctls;

        /// <summary>
        /// A map of kernel parameters (sysctls) to set in the container.
        /// </summary>
        public InputMap<object> Sysctls
        {
            get => _sysctls ?? (_sysctls = new InputMap<object>());
            set => _sysctls = value;
        }

        [Input("tmpfs")]
        private InputMap<object>? _tmpfs;

        /// <summary>
        /// A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
        /// </summary>
        public InputMap<object> Tmpfs
        {
            get => _tmpfs ?? (_tmpfs = new InputMap<object>());
            set => _tmpfs = value;
        }

        /// <summary>
        /// If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
        /// </summary>
        [Input("tty")]
        public Input<bool>? Tty { get; set; }

        [Input("ulimits")]
        private InputList<Inputs.ContainerUlimitGetArgs>? _ulimits;

        /// <summary>
        /// Ulimit options to add.
        /// </summary>
        public InputList<Inputs.ContainerUlimitGetArgs> Ulimits
        {
            get => _ulimits ?? (_ulimits = new InputList<Inputs.ContainerUlimitGetArgs>());
            set => _ulimits = value;
        }

        [Input("uploads")]
        private InputList<Inputs.ContainerUploadGetArgs>? _uploads;

        /// <summary>
        /// Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
        /// </summary>
        public InputList<Inputs.ContainerUploadGetArgs> Uploads
        {
            get => _uploads ?? (_uploads = new InputList<Inputs.ContainerUploadGetArgs>());
            set => _uploads = value;
        }

        /// <summary>
        /// User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.
        /// </summary>
        [Input("user")]
        public Input<string>? User { get; set; }

        /// <summary>
        /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
        /// </summary>
        [Input("usernsMode")]
        public Input<string>? UsernsMode { get; set; }

        [Input("volumes")]
        private InputList<Inputs.ContainerVolumeGetArgs>? _volumes;

        /// <summary>
        /// Spec for mounting volumes in the container.
        /// </summary>
        public InputList<Inputs.ContainerVolumeGetArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Inputs.ContainerVolumeGetArgs>());
            set => _volumes = value;
        }

        /// <summary>
        /// The working directory for commands to run in.
        /// </summary>
        [Input("workingDir")]
        public Input<string>? WorkingDir { get; set; }

        public ContainerState()
        {
        }
        public static new ContainerState Empty => new ContainerState();
    }
}
