// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.docker;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.docker.inputs.ContainerCapabilitiesArgs;
import com.pulumi.docker.inputs.ContainerDeviceArgs;
import com.pulumi.docker.inputs.ContainerHealthcheckArgs;
import com.pulumi.docker.inputs.ContainerHostArgs;
import com.pulumi.docker.inputs.ContainerLabelArgs;
import com.pulumi.docker.inputs.ContainerMountArgs;
import com.pulumi.docker.inputs.ContainerNetworksAdvancedArgs;
import com.pulumi.docker.inputs.ContainerPortArgs;
import com.pulumi.docker.inputs.ContainerUlimitArgs;
import com.pulumi.docker.inputs.ContainerUploadArgs;
import com.pulumi.docker.inputs.ContainerVolumeArgs;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ContainerArgs extends com.pulumi.resources.ResourceArgs {

    public static final ContainerArgs Empty = new ContainerArgs();

    /**
     * If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
     * 
     */
    @Import(name="attach")
    private @Nullable Output<Boolean> attach;

    /**
     * @return If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> attach() {
        return Optional.ofNullable(this.attach);
    }

    /**
     * Add or drop certrain linux capabilities.
     * 
     */
    @Import(name="capabilities")
    private @Nullable Output<ContainerCapabilitiesArgs> capabilities;

    /**
     * @return Add or drop certrain linux capabilities.
     * 
     */
    public Optional<Output<ContainerCapabilitiesArgs>> capabilities() {
        return Optional.ofNullable(this.capabilities);
    }

    /**
     * Cgroup namespace mode to use for the container. Possible values are: `private`, `host`.
     * 
     */
    @Import(name="cgroupnsMode")
    private @Nullable Output<String> cgroupnsMode;

    /**
     * @return Cgroup namespace mode to use for the container. Possible values are: `private`, `host`.
     * 
     */
    public Optional<Output<String>> cgroupnsMode() {
        return Optional.ofNullable(this.cgroupnsMode);
    }

    /**
     * The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[&#34;/usr/bin/myprogram&#34;,&#34;-f&#34;,&#34;baz.con&#34;]`.
     * 
     */
    @Import(name="command")
    private @Nullable Output<List<String>> command;

    /**
     * @return The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[&#34;/usr/bin/myprogram&#34;,&#34;-f&#34;,&#34;baz.con&#34;]`.
     * 
     */
    public Optional<Output<List<String>>> command() {
        return Optional.ofNullable(this.command);
    }

    /**
     * The total number of milliseconds to wait for the container to reach status &#39;running&#39;
     * 
     */
    @Import(name="containerReadRefreshTimeoutMilliseconds")
    private @Nullable Output<Integer> containerReadRefreshTimeoutMilliseconds;

    /**
     * @return The total number of milliseconds to wait for the container to reach status &#39;running&#39;
     * 
     */
    public Optional<Output<Integer>> containerReadRefreshTimeoutMilliseconds() {
        return Optional.ofNullable(this.containerReadRefreshTimeoutMilliseconds);
    }

    /**
     * A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
     * 
     */
    @Import(name="cpuSet")
    private @Nullable Output<String> cpuSet;

    /**
     * @return A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
     * 
     */
    public Optional<Output<String>> cpuSet() {
        return Optional.ofNullable(this.cpuSet);
    }

    /**
     * CPU shares (relative weight) for the container.
     * 
     */
    @Import(name="cpuShares")
    private @Nullable Output<Integer> cpuShares;

    /**
     * @return CPU shares (relative weight) for the container.
     * 
     */
    public Optional<Output<Integer>> cpuShares() {
        return Optional.ofNullable(this.cpuShares);
    }

    /**
     * If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
     * 
     */
    @Import(name="destroyGraceSeconds")
    private @Nullable Output<Integer> destroyGraceSeconds;

    /**
     * @return If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
     * 
     */
    public Optional<Output<Integer>> destroyGraceSeconds() {
        return Optional.ofNullable(this.destroyGraceSeconds);
    }

    /**
     * Bind devices to the container.
     * 
     */
    @Import(name="devices")
    private @Nullable Output<List<ContainerDeviceArgs>> devices;

    /**
     * @return Bind devices to the container.
     * 
     */
    public Optional<Output<List<ContainerDeviceArgs>>> devices() {
        return Optional.ofNullable(this.devices);
    }

    /**
     * DNS servers to use.
     * 
     */
    @Import(name="dns")
    private @Nullable Output<List<String>> dns;

    /**
     * @return DNS servers to use.
     * 
     */
    public Optional<Output<List<String>>> dns() {
        return Optional.ofNullable(this.dns);
    }

    /**
     * DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
     * 
     */
    @Import(name="dnsOpts")
    private @Nullable Output<List<String>> dnsOpts;

    /**
     * @return DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
     * 
     */
    public Optional<Output<List<String>>> dnsOpts() {
        return Optional.ofNullable(this.dnsOpts);
    }

    /**
     * DNS search domains that are used when bare unqualified hostnames are used inside of the container.
     * 
     */
    @Import(name="dnsSearches")
    private @Nullable Output<List<String>> dnsSearches;

    /**
     * @return DNS search domains that are used when bare unqualified hostnames are used inside of the container.
     * 
     */
    public Optional<Output<List<String>>> dnsSearches() {
        return Optional.ofNullable(this.dnsSearches);
    }

    /**
     * Domain name of the container.
     * 
     */
    @Import(name="domainname")
    private @Nullable Output<String> domainname;

    /**
     * @return Domain name of the container.
     * 
     */
    public Optional<Output<String>> domainname() {
        return Optional.ofNullable(this.domainname);
    }

    /**
     * The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `&#34;/usr/bin/myprogra&#34;]`.
     * 
     */
    @Import(name="entrypoints")
    private @Nullable Output<List<String>> entrypoints;

    /**
     * @return The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `&#34;/usr/bin/myprogra&#34;]`.
     * 
     */
    public Optional<Output<List<String>>> entrypoints() {
        return Optional.ofNullable(this.entrypoints);
    }

    /**
     * Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
     * 
     */
    @Import(name="envs")
    private @Nullable Output<List<String>> envs;

    /**
     * @return Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
     * 
     */
    public Optional<Output<List<String>>> envs() {
        return Optional.ofNullable(this.envs);
    }

    /**
     * GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.
     * 
     */
    @Import(name="gpus")
    private @Nullable Output<String> gpus;

    /**
     * @return GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.
     * 
     */
    public Optional<Output<String>> gpus() {
        return Optional.ofNullable(this.gpus);
    }

    /**
     * Additional groups for the container user
     * 
     */
    @Import(name="groupAdds")
    private @Nullable Output<List<String>> groupAdds;

    /**
     * @return Additional groups for the container user
     * 
     */
    public Optional<Output<List<String>>> groupAdds() {
        return Optional.ofNullable(this.groupAdds);
    }

    /**
     * A test to perform to check that the container is healthy
     * 
     */
    @Import(name="healthcheck")
    private @Nullable Output<ContainerHealthcheckArgs> healthcheck;

    /**
     * @return A test to perform to check that the container is healthy
     * 
     */
    public Optional<Output<ContainerHealthcheckArgs>> healthcheck() {
        return Optional.ofNullable(this.healthcheck);
    }

    /**
     * Hostname of the container.
     * 
     */
    @Import(name="hostname")
    private @Nullable Output<String> hostname;

    /**
     * @return Hostname of the container.
     * 
     */
    public Optional<Output<String>> hostname() {
        return Optional.ofNullable(this.hostname);
    }

    /**
     * Additional hosts to add to the container.
     * 
     */
    @Import(name="hosts")
    private @Nullable Output<List<ContainerHostArgs>> hosts;

    /**
     * @return Additional hosts to add to the container.
     * 
     */
    public Optional<Output<List<ContainerHostArgs>>> hosts() {
        return Optional.ofNullable(this.hosts);
    }

    /**
     * The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.
     * 
     */
    @Import(name="image", required=true)
    private Output<String> image;

    /**
     * @return The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.
     * 
     */
    public Output<String> image() {
        return this.image;
    }

    /**
     * Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.
     * 
     */
    @Import(name="init")
    private @Nullable Output<Boolean> init;

    /**
     * @return Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.
     * 
     */
    public Optional<Output<Boolean>> init() {
        return Optional.ofNullable(this.init);
    }

    /**
     * IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
     * 
     */
    @Import(name="ipcMode")
    private @Nullable Output<String> ipcMode;

    /**
     * @return IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
     * 
     */
    public Optional<Output<String>> ipcMode() {
        return Optional.ofNullable(this.ipcMode);
    }

    /**
     * User-defined key/value metadata
     * 
     */
    @Import(name="labels")
    private @Nullable Output<List<ContainerLabelArgs>> labels;

    /**
     * @return User-defined key/value metadata
     * 
     */
    public Optional<Output<List<ContainerLabelArgs>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The logging driver to use for the container.
     * 
     */
    @Import(name="logDriver")
    private @Nullable Output<String> logDriver;

    /**
     * @return The logging driver to use for the container.
     * 
     */
    public Optional<Output<String>> logDriver() {
        return Optional.ofNullable(this.logDriver);
    }

    /**
     * Key/value pairs to use as options for the logging driver.
     * 
     */
    @Import(name="logOpts")
    private @Nullable Output<Map<String,Object>> logOpts;

    /**
     * @return Key/value pairs to use as options for the logging driver.
     * 
     */
    public Optional<Output<Map<String,Object>>> logOpts() {
        return Optional.ofNullable(this.logOpts);
    }

    /**
     * Save the container logs (`attach` must be enabled). Defaults to `false`.
     * 
     */
    @Import(name="logs")
    private @Nullable Output<Boolean> logs;

    /**
     * @return Save the container logs (`attach` must be enabled). Defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> logs() {
        return Optional.ofNullable(this.logs);
    }

    /**
     * The maximum amount of times to an attempt a restart when `restart` is set to &#39;on-failure&#39;.
     * 
     */
    @Import(name="maxRetryCount")
    private @Nullable Output<Integer> maxRetryCount;

    /**
     * @return The maximum amount of times to an attempt a restart when `restart` is set to &#39;on-failure&#39;.
     * 
     */
    public Optional<Output<Integer>> maxRetryCount() {
        return Optional.ofNullable(this.maxRetryCount);
    }

    /**
     * The memory limit for the container in MBs.
     * 
     */
    @Import(name="memory")
    private @Nullable Output<Integer> memory;

    /**
     * @return The memory limit for the container in MBs.
     * 
     */
    public Optional<Output<Integer>> memory() {
        return Optional.ofNullable(this.memory);
    }

    /**
     * The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `pulumi up` if the target host doesn&#39;t support memory swap, when that is the case docker will use a soft limitation.
     * 
     */
    @Import(name="memorySwap")
    private @Nullable Output<Integer> memorySwap;

    /**
     * @return The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `pulumi up` if the target host doesn&#39;t support memory swap, when that is the case docker will use a soft limitation.
     * 
     */
    public Optional<Output<Integer>> memorySwap() {
        return Optional.ofNullable(this.memorySwap);
    }

    /**
     * Specification for mounts to be added to containers created as part of the service.
     * 
     */
    @Import(name="mounts")
    private @Nullable Output<List<ContainerMountArgs>> mounts;

    /**
     * @return Specification for mounts to be added to containers created as part of the service.
     * 
     */
    public Optional<Output<List<ContainerMountArgs>>> mounts() {
        return Optional.ofNullable(this.mounts);
    }

    /**
     * If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
     * assumes it is successful. Defaults to `true`.
     * 
     */
    @Import(name="mustRun")
    private @Nullable Output<Boolean> mustRun;

    /**
     * @return If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
     * assumes it is successful. Defaults to `true`.
     * 
     */
    public Optional<Output<Boolean>> mustRun() {
        return Optional.ofNullable(this.mustRun);
    }

    /**
     * The name of the container.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the container.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Network mode of the container.
     * 
     */
    @Import(name="networkMode")
    private @Nullable Output<String> networkMode;

    /**
     * @return Network mode of the container.
     * 
     */
    public Optional<Output<String>> networkMode() {
        return Optional.ofNullable(this.networkMode);
    }

    /**
     * The networks the container is attached to
     * 
     */
    @Import(name="networksAdvanced")
    private @Nullable Output<List<ContainerNetworksAdvancedArgs>> networksAdvanced;

    /**
     * @return The networks the container is attached to
     * 
     */
    public Optional<Output<List<ContainerNetworksAdvancedArgs>>> networksAdvanced() {
        return Optional.ofNullable(this.networksAdvanced);
    }

    /**
     * he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
     * 
     */
    @Import(name="pidMode")
    private @Nullable Output<String> pidMode;

    /**
     * @return he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
     * 
     */
    public Optional<Output<String>> pidMode() {
        return Optional.ofNullable(this.pidMode);
    }

    /**
     * Publish a container&#39;s port(s) to the host.
     * 
     */
    @Import(name="ports")
    private @Nullable Output<List<ContainerPortArgs>> ports;

    /**
     * @return Publish a container&#39;s port(s) to the host.
     * 
     */
    public Optional<Output<List<ContainerPortArgs>>> ports() {
        return Optional.ofNullable(this.ports);
    }

    /**
     * If `true`, the container runs in privileged mode.
     * 
     */
    @Import(name="privileged")
    private @Nullable Output<Boolean> privileged;

    /**
     * @return If `true`, the container runs in privileged mode.
     * 
     */
    public Optional<Output<Boolean>> privileged() {
        return Optional.ofNullable(this.privileged);
    }

    /**
     * Publish all ports of the container.
     * 
     */
    @Import(name="publishAllPorts")
    private @Nullable Output<Boolean> publishAllPorts;

    /**
     * @return Publish all ports of the container.
     * 
     */
    public Optional<Output<Boolean>> publishAllPorts() {
        return Optional.ofNullable(this.publishAllPorts);
    }

    /**
     * If `true`, the container will be started as readonly. Defaults to `false`.
     * 
     */
    @Import(name="readOnly")
    private @Nullable Output<Boolean> readOnly;

    /**
     * @return If `true`, the container will be started as readonly. Defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> readOnly() {
        return Optional.ofNullable(this.readOnly);
    }

    /**
     * If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
     * 
     */
    @Import(name="removeVolumes")
    private @Nullable Output<Boolean> removeVolumes;

    /**
     * @return If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
     * 
     */
    public Optional<Output<Boolean>> removeVolumes() {
        return Optional.ofNullable(this.removeVolumes);
    }

    /**
     * The restart policy for the container. Must be one of &#39;no&#39;, &#39;on-failure&#39;, &#39;always&#39;, &#39;unless-stopped&#39;. Defaults to `no`.
     * 
     */
    @Import(name="restart")
    private @Nullable Output<String> restart;

    /**
     * @return The restart policy for the container. Must be one of &#39;no&#39;, &#39;on-failure&#39;, &#39;always&#39;, &#39;unless-stopped&#39;. Defaults to `no`.
     * 
     */
    public Optional<Output<String>> restart() {
        return Optional.ofNullable(this.restart);
    }

    /**
     * If `true`, then the container will be automatically removed when it exits. Defaults to `false`.
     * 
     */
    @Import(name="rm")
    private @Nullable Output<Boolean> rm;

    /**
     * @return If `true`, then the container will be automatically removed when it exits. Defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> rm() {
        return Optional.ofNullable(this.rm);
    }

    /**
     * Runtime to use for the container.
     * 
     */
    @Import(name="runtime")
    private @Nullable Output<String> runtime;

    /**
     * @return Runtime to use for the container.
     * 
     */
    public Optional<Output<String>> runtime() {
        return Optional.ofNullable(this.runtime);
    }

    /**
     * List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
     * 
     */
    @Import(name="securityOpts")
    private @Nullable Output<List<String>> securityOpts;

    /**
     * @return List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
     * 
     */
    public Optional<Output<List<String>>> securityOpts() {
        return Optional.ofNullable(this.securityOpts);
    }

    /**
     * Size of `/dev/shm` in MBs.
     * 
     */
    @Import(name="shmSize")
    private @Nullable Output<Integer> shmSize;

    /**
     * @return Size of `/dev/shm` in MBs.
     * 
     */
    public Optional<Output<Integer>> shmSize() {
        return Optional.ofNullable(this.shmSize);
    }

    /**
     * If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.
     * 
     */
    @Import(name="start")
    private @Nullable Output<Boolean> start;

    /**
     * @return If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.
     * 
     */
    public Optional<Output<Boolean>> start() {
        return Optional.ofNullable(this.start);
    }

    /**
     * If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
     * 
     */
    @Import(name="stdinOpen")
    private @Nullable Output<Boolean> stdinOpen;

    /**
     * @return If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> stdinOpen() {
        return Optional.ofNullable(this.stdinOpen);
    }

    /**
     * Signal to stop a container (default `SIGTERM`).
     * 
     */
    @Import(name="stopSignal")
    private @Nullable Output<String> stopSignal;

    /**
     * @return Signal to stop a container (default `SIGTERM`).
     * 
     */
    public Optional<Output<String>> stopSignal() {
        return Optional.ofNullable(this.stopSignal);
    }

    /**
     * Timeout (in seconds) to stop a container.
     * 
     */
    @Import(name="stopTimeout")
    private @Nullable Output<Integer> stopTimeout;

    /**
     * @return Timeout (in seconds) to stop a container.
     * 
     */
    public Optional<Output<Integer>> stopTimeout() {
        return Optional.ofNullable(this.stopTimeout);
    }

    /**
     * Key/value pairs for the storage driver options, e.g. `size`: `120G`
     * 
     */
    @Import(name="storageOpts")
    private @Nullable Output<Map<String,Object>> storageOpts;

    /**
     * @return Key/value pairs for the storage driver options, e.g. `size`: `120G`
     * 
     */
    public Optional<Output<Map<String,Object>>> storageOpts() {
        return Optional.ofNullable(this.storageOpts);
    }

    /**
     * A map of kernel parameters (sysctls) to set in the container.
     * 
     */
    @Import(name="sysctls")
    private @Nullable Output<Map<String,Object>> sysctls;

    /**
     * @return A map of kernel parameters (sysctls) to set in the container.
     * 
     */
    public Optional<Output<Map<String,Object>>> sysctls() {
        return Optional.ofNullable(this.sysctls);
    }

    /**
     * A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
     * 
     */
    @Import(name="tmpfs")
    private @Nullable Output<Map<String,Object>> tmpfs;

    /**
     * @return A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
     * 
     */
    public Optional<Output<Map<String,Object>>> tmpfs() {
        return Optional.ofNullable(this.tmpfs);
    }

    /**
     * If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
     * 
     */
    @Import(name="tty")
    private @Nullable Output<Boolean> tty;

    /**
     * @return If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> tty() {
        return Optional.ofNullable(this.tty);
    }

    /**
     * Ulimit options to add.
     * 
     */
    @Import(name="ulimits")
    private @Nullable Output<List<ContainerUlimitArgs>> ulimits;

    /**
     * @return Ulimit options to add.
     * 
     */
    public Optional<Output<List<ContainerUlimitArgs>>> ulimits() {
        return Optional.ofNullable(this.ulimits);
    }

    /**
     * Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
     * 
     */
    @Import(name="uploads")
    private @Nullable Output<List<ContainerUploadArgs>> uploads;

    /**
     * @return Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
     * 
     */
    public Optional<Output<List<ContainerUploadArgs>>> uploads() {
        return Optional.ofNullable(this.uploads);
    }

    /**
     * User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.
     * 
     */
    @Import(name="user")
    private @Nullable Output<String> user;

    /**
     * @return User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.
     * 
     */
    public Optional<Output<String>> user() {
        return Optional.ofNullable(this.user);
    }

    /**
     * Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
     * 
     */
    @Import(name="usernsMode")
    private @Nullable Output<String> usernsMode;

    /**
     * @return Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
     * 
     */
    public Optional<Output<String>> usernsMode() {
        return Optional.ofNullable(this.usernsMode);
    }

    /**
     * Spec for mounting volumes in the container.
     * 
     */
    @Import(name="volumes")
    private @Nullable Output<List<ContainerVolumeArgs>> volumes;

    /**
     * @return Spec for mounting volumes in the container.
     * 
     */
    public Optional<Output<List<ContainerVolumeArgs>>> volumes() {
        return Optional.ofNullable(this.volumes);
    }

    /**
     * If `true`, then the Docker container is waited for being healthy state after creation. If `false`, then the container health state is not checked. Defaults to `false`.
     * 
     */
    @Import(name="wait")
    private @Nullable Output<Boolean> wait;

    /**
     * @return If `true`, then the Docker container is waited for being healthy state after creation. If `false`, then the container health state is not checked. Defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> wait_() {
        return Optional.ofNullable(this.wait);
    }

    /**
     * The timeout in seconds to wait the container to be healthy after creation. Defaults to `60`.
     * 
     */
    @Import(name="waitTimeout")
    private @Nullable Output<Integer> waitTimeout;

    /**
     * @return The timeout in seconds to wait the container to be healthy after creation. Defaults to `60`.
     * 
     */
    public Optional<Output<Integer>> waitTimeout() {
        return Optional.ofNullable(this.waitTimeout);
    }

    /**
     * The working directory for commands to run in.
     * 
     */
    @Import(name="workingDir")
    private @Nullable Output<String> workingDir;

    /**
     * @return The working directory for commands to run in.
     * 
     */
    public Optional<Output<String>> workingDir() {
        return Optional.ofNullable(this.workingDir);
    }

    private ContainerArgs() {}

    private ContainerArgs(ContainerArgs $) {
        this.attach = $.attach;
        this.capabilities = $.capabilities;
        this.cgroupnsMode = $.cgroupnsMode;
        this.command = $.command;
        this.containerReadRefreshTimeoutMilliseconds = $.containerReadRefreshTimeoutMilliseconds;
        this.cpuSet = $.cpuSet;
        this.cpuShares = $.cpuShares;
        this.destroyGraceSeconds = $.destroyGraceSeconds;
        this.devices = $.devices;
        this.dns = $.dns;
        this.dnsOpts = $.dnsOpts;
        this.dnsSearches = $.dnsSearches;
        this.domainname = $.domainname;
        this.entrypoints = $.entrypoints;
        this.envs = $.envs;
        this.gpus = $.gpus;
        this.groupAdds = $.groupAdds;
        this.healthcheck = $.healthcheck;
        this.hostname = $.hostname;
        this.hosts = $.hosts;
        this.image = $.image;
        this.init = $.init;
        this.ipcMode = $.ipcMode;
        this.labels = $.labels;
        this.logDriver = $.logDriver;
        this.logOpts = $.logOpts;
        this.logs = $.logs;
        this.maxRetryCount = $.maxRetryCount;
        this.memory = $.memory;
        this.memorySwap = $.memorySwap;
        this.mounts = $.mounts;
        this.mustRun = $.mustRun;
        this.name = $.name;
        this.networkMode = $.networkMode;
        this.networksAdvanced = $.networksAdvanced;
        this.pidMode = $.pidMode;
        this.ports = $.ports;
        this.privileged = $.privileged;
        this.publishAllPorts = $.publishAllPorts;
        this.readOnly = $.readOnly;
        this.removeVolumes = $.removeVolumes;
        this.restart = $.restart;
        this.rm = $.rm;
        this.runtime = $.runtime;
        this.securityOpts = $.securityOpts;
        this.shmSize = $.shmSize;
        this.start = $.start;
        this.stdinOpen = $.stdinOpen;
        this.stopSignal = $.stopSignal;
        this.stopTimeout = $.stopTimeout;
        this.storageOpts = $.storageOpts;
        this.sysctls = $.sysctls;
        this.tmpfs = $.tmpfs;
        this.tty = $.tty;
        this.ulimits = $.ulimits;
        this.uploads = $.uploads;
        this.user = $.user;
        this.usernsMode = $.usernsMode;
        this.volumes = $.volumes;
        this.wait = $.wait;
        this.waitTimeout = $.waitTimeout;
        this.workingDir = $.workingDir;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ContainerArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ContainerArgs $;

        public Builder() {
            $ = new ContainerArgs();
        }

        public Builder(ContainerArgs defaults) {
            $ = new ContainerArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param attach If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder attach(@Nullable Output<Boolean> attach) {
            $.attach = attach;
            return this;
        }

        /**
         * @param attach If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder attach(Boolean attach) {
            return attach(Output.of(attach));
        }

        /**
         * @param capabilities Add or drop certrain linux capabilities.
         * 
         * @return builder
         * 
         */
        public Builder capabilities(@Nullable Output<ContainerCapabilitiesArgs> capabilities) {
            $.capabilities = capabilities;
            return this;
        }

        /**
         * @param capabilities Add or drop certrain linux capabilities.
         * 
         * @return builder
         * 
         */
        public Builder capabilities(ContainerCapabilitiesArgs capabilities) {
            return capabilities(Output.of(capabilities));
        }

        /**
         * @param cgroupnsMode Cgroup namespace mode to use for the container. Possible values are: `private`, `host`.
         * 
         * @return builder
         * 
         */
        public Builder cgroupnsMode(@Nullable Output<String> cgroupnsMode) {
            $.cgroupnsMode = cgroupnsMode;
            return this;
        }

        /**
         * @param cgroupnsMode Cgroup namespace mode to use for the container. Possible values are: `private`, `host`.
         * 
         * @return builder
         * 
         */
        public Builder cgroupnsMode(String cgroupnsMode) {
            return cgroupnsMode(Output.of(cgroupnsMode));
        }

        /**
         * @param command The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[&#34;/usr/bin/myprogram&#34;,&#34;-f&#34;,&#34;baz.con&#34;]`.
         * 
         * @return builder
         * 
         */
        public Builder command(@Nullable Output<List<String>> command) {
            $.command = command;
            return this;
        }

        /**
         * @param command The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[&#34;/usr/bin/myprogram&#34;,&#34;-f&#34;,&#34;baz.con&#34;]`.
         * 
         * @return builder
         * 
         */
        public Builder command(List<String> command) {
            return command(Output.of(command));
        }

        /**
         * @param command The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[&#34;/usr/bin/myprogram&#34;,&#34;-f&#34;,&#34;baz.con&#34;]`.
         * 
         * @return builder
         * 
         */
        public Builder command(String... command) {
            return command(List.of(command));
        }

        /**
         * @param containerReadRefreshTimeoutMilliseconds The total number of milliseconds to wait for the container to reach status &#39;running&#39;
         * 
         * @return builder
         * 
         */
        public Builder containerReadRefreshTimeoutMilliseconds(@Nullable Output<Integer> containerReadRefreshTimeoutMilliseconds) {
            $.containerReadRefreshTimeoutMilliseconds = containerReadRefreshTimeoutMilliseconds;
            return this;
        }

        /**
         * @param containerReadRefreshTimeoutMilliseconds The total number of milliseconds to wait for the container to reach status &#39;running&#39;
         * 
         * @return builder
         * 
         */
        public Builder containerReadRefreshTimeoutMilliseconds(Integer containerReadRefreshTimeoutMilliseconds) {
            return containerReadRefreshTimeoutMilliseconds(Output.of(containerReadRefreshTimeoutMilliseconds));
        }

        /**
         * @param cpuSet A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
         * 
         * @return builder
         * 
         */
        public Builder cpuSet(@Nullable Output<String> cpuSet) {
            $.cpuSet = cpuSet;
            return this;
        }

        /**
         * @param cpuSet A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
         * 
         * @return builder
         * 
         */
        public Builder cpuSet(String cpuSet) {
            return cpuSet(Output.of(cpuSet));
        }

        /**
         * @param cpuShares CPU shares (relative weight) for the container.
         * 
         * @return builder
         * 
         */
        public Builder cpuShares(@Nullable Output<Integer> cpuShares) {
            $.cpuShares = cpuShares;
            return this;
        }

        /**
         * @param cpuShares CPU shares (relative weight) for the container.
         * 
         * @return builder
         * 
         */
        public Builder cpuShares(Integer cpuShares) {
            return cpuShares(Output.of(cpuShares));
        }

        /**
         * @param destroyGraceSeconds If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
         * 
         * @return builder
         * 
         */
        public Builder destroyGraceSeconds(@Nullable Output<Integer> destroyGraceSeconds) {
            $.destroyGraceSeconds = destroyGraceSeconds;
            return this;
        }

        /**
         * @param destroyGraceSeconds If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.
         * 
         * @return builder
         * 
         */
        public Builder destroyGraceSeconds(Integer destroyGraceSeconds) {
            return destroyGraceSeconds(Output.of(destroyGraceSeconds));
        }

        /**
         * @param devices Bind devices to the container.
         * 
         * @return builder
         * 
         */
        public Builder devices(@Nullable Output<List<ContainerDeviceArgs>> devices) {
            $.devices = devices;
            return this;
        }

        /**
         * @param devices Bind devices to the container.
         * 
         * @return builder
         * 
         */
        public Builder devices(List<ContainerDeviceArgs> devices) {
            return devices(Output.of(devices));
        }

        /**
         * @param devices Bind devices to the container.
         * 
         * @return builder
         * 
         */
        public Builder devices(ContainerDeviceArgs... devices) {
            return devices(List.of(devices));
        }

        /**
         * @param dns DNS servers to use.
         * 
         * @return builder
         * 
         */
        public Builder dns(@Nullable Output<List<String>> dns) {
            $.dns = dns;
            return this;
        }

        /**
         * @param dns DNS servers to use.
         * 
         * @return builder
         * 
         */
        public Builder dns(List<String> dns) {
            return dns(Output.of(dns));
        }

        /**
         * @param dns DNS servers to use.
         * 
         * @return builder
         * 
         */
        public Builder dns(String... dns) {
            return dns(List.of(dns));
        }

        /**
         * @param dnsOpts DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
         * 
         * @return builder
         * 
         */
        public Builder dnsOpts(@Nullable Output<List<String>> dnsOpts) {
            $.dnsOpts = dnsOpts;
            return this;
        }

        /**
         * @param dnsOpts DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
         * 
         * @return builder
         * 
         */
        public Builder dnsOpts(List<String> dnsOpts) {
            return dnsOpts(Output.of(dnsOpts));
        }

        /**
         * @param dnsOpts DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
         * 
         * @return builder
         * 
         */
        public Builder dnsOpts(String... dnsOpts) {
            return dnsOpts(List.of(dnsOpts));
        }

        /**
         * @param dnsSearches DNS search domains that are used when bare unqualified hostnames are used inside of the container.
         * 
         * @return builder
         * 
         */
        public Builder dnsSearches(@Nullable Output<List<String>> dnsSearches) {
            $.dnsSearches = dnsSearches;
            return this;
        }

        /**
         * @param dnsSearches DNS search domains that are used when bare unqualified hostnames are used inside of the container.
         * 
         * @return builder
         * 
         */
        public Builder dnsSearches(List<String> dnsSearches) {
            return dnsSearches(Output.of(dnsSearches));
        }

        /**
         * @param dnsSearches DNS search domains that are used when bare unqualified hostnames are used inside of the container.
         * 
         * @return builder
         * 
         */
        public Builder dnsSearches(String... dnsSearches) {
            return dnsSearches(List.of(dnsSearches));
        }

        /**
         * @param domainname Domain name of the container.
         * 
         * @return builder
         * 
         */
        public Builder domainname(@Nullable Output<String> domainname) {
            $.domainname = domainname;
            return this;
        }

        /**
         * @param domainname Domain name of the container.
         * 
         * @return builder
         * 
         */
        public Builder domainname(String domainname) {
            return domainname(Output.of(domainname));
        }

        /**
         * @param entrypoints The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `&#34;/usr/bin/myprogra&#34;]`.
         * 
         * @return builder
         * 
         */
        public Builder entrypoints(@Nullable Output<List<String>> entrypoints) {
            $.entrypoints = entrypoints;
            return this;
        }

        /**
         * @param entrypoints The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `&#34;/usr/bin/myprogra&#34;]`.
         * 
         * @return builder
         * 
         */
        public Builder entrypoints(List<String> entrypoints) {
            return entrypoints(Output.of(entrypoints));
        }

        /**
         * @param entrypoints The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `&#34;/usr/bin/myprogra&#34;]`.
         * 
         * @return builder
         * 
         */
        public Builder entrypoints(String... entrypoints) {
            return entrypoints(List.of(entrypoints));
        }

        /**
         * @param envs Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
         * 
         * @return builder
         * 
         */
        public Builder envs(@Nullable Output<List<String>> envs) {
            $.envs = envs;
            return this;
        }

        /**
         * @param envs Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
         * 
         * @return builder
         * 
         */
        public Builder envs(List<String> envs) {
            return envs(Output.of(envs));
        }

        /**
         * @param envs Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
         * 
         * @return builder
         * 
         */
        public Builder envs(String... envs) {
            return envs(List.of(envs));
        }

        /**
         * @param gpus GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.
         * 
         * @return builder
         * 
         */
        public Builder gpus(@Nullable Output<String> gpus) {
            $.gpus = gpus;
            return this;
        }

        /**
         * @param gpus GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.
         * 
         * @return builder
         * 
         */
        public Builder gpus(String gpus) {
            return gpus(Output.of(gpus));
        }

        /**
         * @param groupAdds Additional groups for the container user
         * 
         * @return builder
         * 
         */
        public Builder groupAdds(@Nullable Output<List<String>> groupAdds) {
            $.groupAdds = groupAdds;
            return this;
        }

        /**
         * @param groupAdds Additional groups for the container user
         * 
         * @return builder
         * 
         */
        public Builder groupAdds(List<String> groupAdds) {
            return groupAdds(Output.of(groupAdds));
        }

        /**
         * @param groupAdds Additional groups for the container user
         * 
         * @return builder
         * 
         */
        public Builder groupAdds(String... groupAdds) {
            return groupAdds(List.of(groupAdds));
        }

        /**
         * @param healthcheck A test to perform to check that the container is healthy
         * 
         * @return builder
         * 
         */
        public Builder healthcheck(@Nullable Output<ContainerHealthcheckArgs> healthcheck) {
            $.healthcheck = healthcheck;
            return this;
        }

        /**
         * @param healthcheck A test to perform to check that the container is healthy
         * 
         * @return builder
         * 
         */
        public Builder healthcheck(ContainerHealthcheckArgs healthcheck) {
            return healthcheck(Output.of(healthcheck));
        }

        /**
         * @param hostname Hostname of the container.
         * 
         * @return builder
         * 
         */
        public Builder hostname(@Nullable Output<String> hostname) {
            $.hostname = hostname;
            return this;
        }

        /**
         * @param hostname Hostname of the container.
         * 
         * @return builder
         * 
         */
        public Builder hostname(String hostname) {
            return hostname(Output.of(hostname));
        }

        /**
         * @param hosts Additional hosts to add to the container.
         * 
         * @return builder
         * 
         */
        public Builder hosts(@Nullable Output<List<ContainerHostArgs>> hosts) {
            $.hosts = hosts;
            return this;
        }

        /**
         * @param hosts Additional hosts to add to the container.
         * 
         * @return builder
         * 
         */
        public Builder hosts(List<ContainerHostArgs> hosts) {
            return hosts(Output.of(hosts));
        }

        /**
         * @param hosts Additional hosts to add to the container.
         * 
         * @return builder
         * 
         */
        public Builder hosts(ContainerHostArgs... hosts) {
            return hosts(List.of(hosts));
        }

        /**
         * @param image The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.
         * 
         * @return builder
         * 
         */
        public Builder image(Output<String> image) {
            $.image = image;
            return this;
        }

        /**
         * @param image The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.
         * 
         * @return builder
         * 
         */
        public Builder image(String image) {
            return image(Output.of(image));
        }

        /**
         * @param init Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.
         * 
         * @return builder
         * 
         */
        public Builder init(@Nullable Output<Boolean> init) {
            $.init = init;
            return this;
        }

        /**
         * @param init Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.
         * 
         * @return builder
         * 
         */
        public Builder init(Boolean init) {
            return init(Output.of(init));
        }

        /**
         * @param ipcMode IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
         * 
         * @return builder
         * 
         */
        public Builder ipcMode(@Nullable Output<String> ipcMode) {
            $.ipcMode = ipcMode;
            return this;
        }

        /**
         * @param ipcMode IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or `host`.
         * 
         * @return builder
         * 
         */
        public Builder ipcMode(String ipcMode) {
            return ipcMode(Output.of(ipcMode));
        }

        /**
         * @param labels User-defined key/value metadata
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<List<ContainerLabelArgs>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels User-defined key/value metadata
         * 
         * @return builder
         * 
         */
        public Builder labels(List<ContainerLabelArgs> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param labels User-defined key/value metadata
         * 
         * @return builder
         * 
         */
        public Builder labels(ContainerLabelArgs... labels) {
            return labels(List.of(labels));
        }

        /**
         * @param logDriver The logging driver to use for the container.
         * 
         * @return builder
         * 
         */
        public Builder logDriver(@Nullable Output<String> logDriver) {
            $.logDriver = logDriver;
            return this;
        }

        /**
         * @param logDriver The logging driver to use for the container.
         * 
         * @return builder
         * 
         */
        public Builder logDriver(String logDriver) {
            return logDriver(Output.of(logDriver));
        }

        /**
         * @param logOpts Key/value pairs to use as options for the logging driver.
         * 
         * @return builder
         * 
         */
        public Builder logOpts(@Nullable Output<Map<String,Object>> logOpts) {
            $.logOpts = logOpts;
            return this;
        }

        /**
         * @param logOpts Key/value pairs to use as options for the logging driver.
         * 
         * @return builder
         * 
         */
        public Builder logOpts(Map<String,Object> logOpts) {
            return logOpts(Output.of(logOpts));
        }

        /**
         * @param logs Save the container logs (`attach` must be enabled). Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder logs(@Nullable Output<Boolean> logs) {
            $.logs = logs;
            return this;
        }

        /**
         * @param logs Save the container logs (`attach` must be enabled). Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder logs(Boolean logs) {
            return logs(Output.of(logs));
        }

        /**
         * @param maxRetryCount The maximum amount of times to an attempt a restart when `restart` is set to &#39;on-failure&#39;.
         * 
         * @return builder
         * 
         */
        public Builder maxRetryCount(@Nullable Output<Integer> maxRetryCount) {
            $.maxRetryCount = maxRetryCount;
            return this;
        }

        /**
         * @param maxRetryCount The maximum amount of times to an attempt a restart when `restart` is set to &#39;on-failure&#39;.
         * 
         * @return builder
         * 
         */
        public Builder maxRetryCount(Integer maxRetryCount) {
            return maxRetryCount(Output.of(maxRetryCount));
        }

        /**
         * @param memory The memory limit for the container in MBs.
         * 
         * @return builder
         * 
         */
        public Builder memory(@Nullable Output<Integer> memory) {
            $.memory = memory;
            return this;
        }

        /**
         * @param memory The memory limit for the container in MBs.
         * 
         * @return builder
         * 
         */
        public Builder memory(Integer memory) {
            return memory(Output.of(memory));
        }

        /**
         * @param memorySwap The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `pulumi up` if the target host doesn&#39;t support memory swap, when that is the case docker will use a soft limitation.
         * 
         * @return builder
         * 
         */
        public Builder memorySwap(@Nullable Output<Integer> memorySwap) {
            $.memorySwap = memorySwap;
            return this;
        }

        /**
         * @param memorySwap The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `pulumi up` if the target host doesn&#39;t support memory swap, when that is the case docker will use a soft limitation.
         * 
         * @return builder
         * 
         */
        public Builder memorySwap(Integer memorySwap) {
            return memorySwap(Output.of(memorySwap));
        }

        /**
         * @param mounts Specification for mounts to be added to containers created as part of the service.
         * 
         * @return builder
         * 
         */
        public Builder mounts(@Nullable Output<List<ContainerMountArgs>> mounts) {
            $.mounts = mounts;
            return this;
        }

        /**
         * @param mounts Specification for mounts to be added to containers created as part of the service.
         * 
         * @return builder
         * 
         */
        public Builder mounts(List<ContainerMountArgs> mounts) {
            return mounts(Output.of(mounts));
        }

        /**
         * @param mounts Specification for mounts to be added to containers created as part of the service.
         * 
         * @return builder
         * 
         */
        public Builder mounts(ContainerMountArgs... mounts) {
            return mounts(List.of(mounts));
        }

        /**
         * @param mustRun If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
         * assumes it is successful. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder mustRun(@Nullable Output<Boolean> mustRun) {
            $.mustRun = mustRun;
            return this;
        }

        /**
         * @param mustRun If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
         * assumes it is successful. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder mustRun(Boolean mustRun) {
            return mustRun(Output.of(mustRun));
        }

        /**
         * @param name The name of the container.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the container.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkMode Network mode of the container.
         * 
         * @return builder
         * 
         */
        public Builder networkMode(@Nullable Output<String> networkMode) {
            $.networkMode = networkMode;
            return this;
        }

        /**
         * @param networkMode Network mode of the container.
         * 
         * @return builder
         * 
         */
        public Builder networkMode(String networkMode) {
            return networkMode(Output.of(networkMode));
        }

        /**
         * @param networksAdvanced The networks the container is attached to
         * 
         * @return builder
         * 
         */
        public Builder networksAdvanced(@Nullable Output<List<ContainerNetworksAdvancedArgs>> networksAdvanced) {
            $.networksAdvanced = networksAdvanced;
            return this;
        }

        /**
         * @param networksAdvanced The networks the container is attached to
         * 
         * @return builder
         * 
         */
        public Builder networksAdvanced(List<ContainerNetworksAdvancedArgs> networksAdvanced) {
            return networksAdvanced(Output.of(networksAdvanced));
        }

        /**
         * @param networksAdvanced The networks the container is attached to
         * 
         * @return builder
         * 
         */
        public Builder networksAdvanced(ContainerNetworksAdvancedArgs... networksAdvanced) {
            return networksAdvanced(List.of(networksAdvanced));
        }

        /**
         * @param pidMode he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
         * 
         * @return builder
         * 
         */
        public Builder pidMode(@Nullable Output<String> pidMode) {
            $.pidMode = pidMode;
            return this;
        }

        /**
         * @param pidMode he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
         * 
         * @return builder
         * 
         */
        public Builder pidMode(String pidMode) {
            return pidMode(Output.of(pidMode));
        }

        /**
         * @param ports Publish a container&#39;s port(s) to the host.
         * 
         * @return builder
         * 
         */
        public Builder ports(@Nullable Output<List<ContainerPortArgs>> ports) {
            $.ports = ports;
            return this;
        }

        /**
         * @param ports Publish a container&#39;s port(s) to the host.
         * 
         * @return builder
         * 
         */
        public Builder ports(List<ContainerPortArgs> ports) {
            return ports(Output.of(ports));
        }

        /**
         * @param ports Publish a container&#39;s port(s) to the host.
         * 
         * @return builder
         * 
         */
        public Builder ports(ContainerPortArgs... ports) {
            return ports(List.of(ports));
        }

        /**
         * @param privileged If `true`, the container runs in privileged mode.
         * 
         * @return builder
         * 
         */
        public Builder privileged(@Nullable Output<Boolean> privileged) {
            $.privileged = privileged;
            return this;
        }

        /**
         * @param privileged If `true`, the container runs in privileged mode.
         * 
         * @return builder
         * 
         */
        public Builder privileged(Boolean privileged) {
            return privileged(Output.of(privileged));
        }

        /**
         * @param publishAllPorts Publish all ports of the container.
         * 
         * @return builder
         * 
         */
        public Builder publishAllPorts(@Nullable Output<Boolean> publishAllPorts) {
            $.publishAllPorts = publishAllPorts;
            return this;
        }

        /**
         * @param publishAllPorts Publish all ports of the container.
         * 
         * @return builder
         * 
         */
        public Builder publishAllPorts(Boolean publishAllPorts) {
            return publishAllPorts(Output.of(publishAllPorts));
        }

        /**
         * @param readOnly If `true`, the container will be started as readonly. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder readOnly(@Nullable Output<Boolean> readOnly) {
            $.readOnly = readOnly;
            return this;
        }

        /**
         * @param readOnly If `true`, the container will be started as readonly. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder readOnly(Boolean readOnly) {
            return readOnly(Output.of(readOnly));
        }

        /**
         * @param removeVolumes If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder removeVolumes(@Nullable Output<Boolean> removeVolumes) {
            $.removeVolumes = removeVolumes;
            return this;
        }

        /**
         * @param removeVolumes If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder removeVolumes(Boolean removeVolumes) {
            return removeVolumes(Output.of(removeVolumes));
        }

        /**
         * @param restart The restart policy for the container. Must be one of &#39;no&#39;, &#39;on-failure&#39;, &#39;always&#39;, &#39;unless-stopped&#39;. Defaults to `no`.
         * 
         * @return builder
         * 
         */
        public Builder restart(@Nullable Output<String> restart) {
            $.restart = restart;
            return this;
        }

        /**
         * @param restart The restart policy for the container. Must be one of &#39;no&#39;, &#39;on-failure&#39;, &#39;always&#39;, &#39;unless-stopped&#39;. Defaults to `no`.
         * 
         * @return builder
         * 
         */
        public Builder restart(String restart) {
            return restart(Output.of(restart));
        }

        /**
         * @param rm If `true`, then the container will be automatically removed when it exits. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder rm(@Nullable Output<Boolean> rm) {
            $.rm = rm;
            return this;
        }

        /**
         * @param rm If `true`, then the container will be automatically removed when it exits. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder rm(Boolean rm) {
            return rm(Output.of(rm));
        }

        /**
         * @param runtime Runtime to use for the container.
         * 
         * @return builder
         * 
         */
        public Builder runtime(@Nullable Output<String> runtime) {
            $.runtime = runtime;
            return this;
        }

        /**
         * @param runtime Runtime to use for the container.
         * 
         * @return builder
         * 
         */
        public Builder runtime(String runtime) {
            return runtime(Output.of(runtime));
        }

        /**
         * @param securityOpts List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
         * 
         * @return builder
         * 
         */
        public Builder securityOpts(@Nullable Output<List<String>> securityOpts) {
            $.securityOpts = securityOpts;
            return this;
        }

        /**
         * @param securityOpts List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
         * 
         * @return builder
         * 
         */
        public Builder securityOpts(List<String> securityOpts) {
            return securityOpts(Output.of(securityOpts));
        }

        /**
         * @param securityOpts List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.
         * 
         * @return builder
         * 
         */
        public Builder securityOpts(String... securityOpts) {
            return securityOpts(List.of(securityOpts));
        }

        /**
         * @param shmSize Size of `/dev/shm` in MBs.
         * 
         * @return builder
         * 
         */
        public Builder shmSize(@Nullable Output<Integer> shmSize) {
            $.shmSize = shmSize;
            return this;
        }

        /**
         * @param shmSize Size of `/dev/shm` in MBs.
         * 
         * @return builder
         * 
         */
        public Builder shmSize(Integer shmSize) {
            return shmSize(Output.of(shmSize));
        }

        /**
         * @param start If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder start(@Nullable Output<Boolean> start) {
            $.start = start;
            return this;
        }

        /**
         * @param start If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder start(Boolean start) {
            return start(Output.of(start));
        }

        /**
         * @param stdinOpen If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder stdinOpen(@Nullable Output<Boolean> stdinOpen) {
            $.stdinOpen = stdinOpen;
            return this;
        }

        /**
         * @param stdinOpen If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder stdinOpen(Boolean stdinOpen) {
            return stdinOpen(Output.of(stdinOpen));
        }

        /**
         * @param stopSignal Signal to stop a container (default `SIGTERM`).
         * 
         * @return builder
         * 
         */
        public Builder stopSignal(@Nullable Output<String> stopSignal) {
            $.stopSignal = stopSignal;
            return this;
        }

        /**
         * @param stopSignal Signal to stop a container (default `SIGTERM`).
         * 
         * @return builder
         * 
         */
        public Builder stopSignal(String stopSignal) {
            return stopSignal(Output.of(stopSignal));
        }

        /**
         * @param stopTimeout Timeout (in seconds) to stop a container.
         * 
         * @return builder
         * 
         */
        public Builder stopTimeout(@Nullable Output<Integer> stopTimeout) {
            $.stopTimeout = stopTimeout;
            return this;
        }

        /**
         * @param stopTimeout Timeout (in seconds) to stop a container.
         * 
         * @return builder
         * 
         */
        public Builder stopTimeout(Integer stopTimeout) {
            return stopTimeout(Output.of(stopTimeout));
        }

        /**
         * @param storageOpts Key/value pairs for the storage driver options, e.g. `size`: `120G`
         * 
         * @return builder
         * 
         */
        public Builder storageOpts(@Nullable Output<Map<String,Object>> storageOpts) {
            $.storageOpts = storageOpts;
            return this;
        }

        /**
         * @param storageOpts Key/value pairs for the storage driver options, e.g. `size`: `120G`
         * 
         * @return builder
         * 
         */
        public Builder storageOpts(Map<String,Object> storageOpts) {
            return storageOpts(Output.of(storageOpts));
        }

        /**
         * @param sysctls A map of kernel parameters (sysctls) to set in the container.
         * 
         * @return builder
         * 
         */
        public Builder sysctls(@Nullable Output<Map<String,Object>> sysctls) {
            $.sysctls = sysctls;
            return this;
        }

        /**
         * @param sysctls A map of kernel parameters (sysctls) to set in the container.
         * 
         * @return builder
         * 
         */
        public Builder sysctls(Map<String,Object> sysctls) {
            return sysctls(Output.of(sysctls));
        }

        /**
         * @param tmpfs A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
         * 
         * @return builder
         * 
         */
        public Builder tmpfs(@Nullable Output<Map<String,Object>> tmpfs) {
            $.tmpfs = tmpfs;
            return this;
        }

        /**
         * @param tmpfs A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
         * 
         * @return builder
         * 
         */
        public Builder tmpfs(Map<String,Object> tmpfs) {
            return tmpfs(Output.of(tmpfs));
        }

        /**
         * @param tty If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder tty(@Nullable Output<Boolean> tty) {
            $.tty = tty;
            return this;
        }

        /**
         * @param tty If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder tty(Boolean tty) {
            return tty(Output.of(tty));
        }

        /**
         * @param ulimits Ulimit options to add.
         * 
         * @return builder
         * 
         */
        public Builder ulimits(@Nullable Output<List<ContainerUlimitArgs>> ulimits) {
            $.ulimits = ulimits;
            return this;
        }

        /**
         * @param ulimits Ulimit options to add.
         * 
         * @return builder
         * 
         */
        public Builder ulimits(List<ContainerUlimitArgs> ulimits) {
            return ulimits(Output.of(ulimits));
        }

        /**
         * @param ulimits Ulimit options to add.
         * 
         * @return builder
         * 
         */
        public Builder ulimits(ContainerUlimitArgs... ulimits) {
            return ulimits(List.of(ulimits));
        }

        /**
         * @param uploads Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
         * 
         * @return builder
         * 
         */
        public Builder uploads(@Nullable Output<List<ContainerUploadArgs>> uploads) {
            $.uploads = uploads;
            return this;
        }

        /**
         * @param uploads Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
         * 
         * @return builder
         * 
         */
        public Builder uploads(List<ContainerUploadArgs> uploads) {
            return uploads(Output.of(uploads));
        }

        /**
         * @param uploads Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.
         * 
         * @return builder
         * 
         */
        public Builder uploads(ContainerUploadArgs... uploads) {
            return uploads(List.of(uploads));
        }

        /**
         * @param user User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.
         * 
         * @return builder
         * 
         */
        public Builder user(@Nullable Output<String> user) {
            $.user = user;
            return this;
        }

        /**
         * @param user User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.
         * 
         * @return builder
         * 
         */
        public Builder user(String user) {
            return user(Output.of(user));
        }

        /**
         * @param usernsMode Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
         * 
         * @return builder
         * 
         */
        public Builder usernsMode(@Nullable Output<String> usernsMode) {
            $.usernsMode = usernsMode;
            return this;
        }

        /**
         * @param usernsMode Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
         * 
         * @return builder
         * 
         */
        public Builder usernsMode(String usernsMode) {
            return usernsMode(Output.of(usernsMode));
        }

        /**
         * @param volumes Spec for mounting volumes in the container.
         * 
         * @return builder
         * 
         */
        public Builder volumes(@Nullable Output<List<ContainerVolumeArgs>> volumes) {
            $.volumes = volumes;
            return this;
        }

        /**
         * @param volumes Spec for mounting volumes in the container.
         * 
         * @return builder
         * 
         */
        public Builder volumes(List<ContainerVolumeArgs> volumes) {
            return volumes(Output.of(volumes));
        }

        /**
         * @param volumes Spec for mounting volumes in the container.
         * 
         * @return builder
         * 
         */
        public Builder volumes(ContainerVolumeArgs... volumes) {
            return volumes(List.of(volumes));
        }

        /**
         * @param wait If `true`, then the Docker container is waited for being healthy state after creation. If `false`, then the container health state is not checked. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder wait_(@Nullable Output<Boolean> wait) {
            $.wait = wait;
            return this;
        }

        /**
         * @param wait If `true`, then the Docker container is waited for being healthy state after creation. If `false`, then the container health state is not checked. Defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder wait_(Boolean wait) {
            return wait_(Output.of(wait));
        }

        /**
         * @param waitTimeout The timeout in seconds to wait the container to be healthy after creation. Defaults to `60`.
         * 
         * @return builder
         * 
         */
        public Builder waitTimeout(@Nullable Output<Integer> waitTimeout) {
            $.waitTimeout = waitTimeout;
            return this;
        }

        /**
         * @param waitTimeout The timeout in seconds to wait the container to be healthy after creation. Defaults to `60`.
         * 
         * @return builder
         * 
         */
        public Builder waitTimeout(Integer waitTimeout) {
            return waitTimeout(Output.of(waitTimeout));
        }

        /**
         * @param workingDir The working directory for commands to run in.
         * 
         * @return builder
         * 
         */
        public Builder workingDir(@Nullable Output<String> workingDir) {
            $.workingDir = workingDir;
            return this;
        }

        /**
         * @param workingDir The working directory for commands to run in.
         * 
         * @return builder
         * 
         */
        public Builder workingDir(String workingDir) {
            return workingDir(Output.of(workingDir));
        }

        public ContainerArgs build() {
            if ($.image == null) {
                throw new MissingRequiredPropertyException("ContainerArgs", "image");
            }
            return $;
        }
    }

}
