// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.docker;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.docker.RemoteImageArgs;
import com.pulumi.docker.Utilities;
import com.pulumi.docker.inputs.RemoteImageState;
import com.pulumi.docker.outputs.RemoteImageBuild;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * &lt;!-- Bug: Type and Name are switched --&gt;
 * Manages the lifecycle of a docker image in your docker host. It can be used to build a new docker image or to pull an existing one from a registry.
 *  This resource will *not* pull new layers of the image automatically unless used in conjunction with docker.RegistryImage data source to update the `pullTriggers` field.
 * 
 * ## Example Usage
 * 
 * ### Basic
 * 
 * Finds and downloads the latest `ubuntu:precise` image but does not check
 * for further updates of the image
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.docker.RemoteImage;
 * import com.pulumi.docker.RemoteImageArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var ubuntu = new RemoteImage("ubuntu", RemoteImageArgs.builder()
 *             .name("ubuntu:precise")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Dynamic updates
 * 
 * To be able to update an image dynamically when the `sha256` sum changes,
 * you need to use it in combination with `docker.RegistryImage` as follows:
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.docker.DockerFunctions;
 * import com.pulumi.docker.inputs.GetRegistryImageArgs;
 * import com.pulumi.docker.RemoteImage;
 * import com.pulumi.docker.RemoteImageArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var ubuntu = DockerFunctions.getRegistryImage(GetRegistryImageArgs.builder()
 *             .name("ubuntu:precise")
 *             .build());
 * 
 *         var ubuntuRemoteImage = new RemoteImage("ubuntuRemoteImage", RemoteImageArgs.builder()
 *             .name(ubuntu.name())
 *             .pullTriggers(ubuntu.sha256Digest())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Build
 * 
 * You can also use the resource to build an image. If you want to use a buildx builder with all of its features, please read the section below.
 * 
 * &gt; **Note**: The default timeout for the building is 20 minutes. If you need to increase this, you can use operation timeouts.
 * 
 * In this case the image &#34;zoo&#34; and &#34;zoo:develop&#34; are built.
 * The `context` and `dockerfile` arguments are relative to the local Terraform process (`path.cwd`).
 * There is no need to copy the files to remote hosts before creating the resource.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.docker.RemoteImage;
 * import com.pulumi.docker.RemoteImageArgs;
 * import com.pulumi.docker.inputs.RemoteImageBuildArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var zoo = new RemoteImage("zoo", RemoteImageArgs.builder()
 *             .name("zoo")
 *             .build(RemoteImageBuildArgs.builder()
 *                 .context(".")
 *                 .tags("zoo:develop")
 *                 .buildArgs(Map.of("foo", "zoo"))
 *                 .label(Map.of("author", "zoo"))
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * You can use the `triggers` argument to specify when the image should be rebuild. This is for example helpful when you want to rebuild the docker image whenever the source code changes.
 * 
 */
@ResourceType(type="docker:index/remoteImage:RemoteImage")
public class RemoteImage extends com.pulumi.resources.CustomResource {
    /**
     * Configuration to build an image. Requires the `Use containerd for pulling and storing images` option to be disabled in the Docker Host(https://github.com/kreuzwerker/terraform-provider-docker/issues/534). Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.
     * 
     */
    @Export(name="build", refs={RemoteImageBuild.class}, tree="[0]")
    private Output</* @Nullable */ RemoteImageBuild> build;

    /**
     * @return Configuration to build an image. Requires the `Use containerd for pulling and storing images` option to be disabled in the Docker Host(https://github.com/kreuzwerker/terraform-provider-docker/issues/534). Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.
     * 
     */
    public Output<Optional<RemoteImageBuild>> build() {
        return Codegen.optional(this.build);
    }
    /**
     * If true, then the image is removed forcibly when the resource is destroyed.
     * 
     */
    @Export(name="forceRemove", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceRemove;

    /**
     * @return If true, then the image is removed forcibly when the resource is destroyed.
     * 
     */
    public Output<Optional<Boolean>> forceRemove() {
        return Codegen.optional(this.forceRemove);
    }
    /**
     * The ID of the image (as seen when executing `docker inspect` on the image). Can be used to reference the image via its ID in other resources.
     * 
     */
    @Export(name="imageId", refs={String.class}, tree="[0]")
    private Output<String> imageId;

    /**
     * @return The ID of the image (as seen when executing `docker inspect` on the image). Can be used to reference the image via its ID in other resources.
     * 
     */
    public Output<String> imageId() {
        return this.imageId;
    }
    /**
     * If true, then the Docker image won&#39;t be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.
     * 
     */
    @Export(name="keepLocally", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> keepLocally;

    /**
     * @return If true, then the Docker image won&#39;t be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.
     * 
     */
    public Output<Optional<Boolean>> keepLocally() {
        return Codegen.optional(this.keepLocally);
    }
    /**
     * The name of the Docker image, including any tags or SHA256 repo digests.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the Docker image, including any tags or SHA256 repo digests.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The platform to use when pulling the image. Defaults to the platform of the current machine.
     * 
     */
    @Export(name="platform", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> platform;

    /**
     * @return The platform to use when pulling the image. Defaults to the platform of the current machine.
     * 
     */
    public Output<Optional<String>> platform() {
        return Codegen.optional(this.platform);
    }
    /**
     * List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.
     * 
     */
    @Export(name="pullTriggers", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> pullTriggers;

    /**
     * @return List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.
     * 
     */
    public Output<Optional<List<String>>> pullTriggers() {
        return Codegen.optional(this.pullTriggers);
    }
    /**
     * The image sha256 digest in the form of `repo[:tag]{@literal @}sha256:&lt;hash&gt;`. This may not be populated when building an image, because it is read from the local Docker client and so may be available only when the image was either pulled from the repo or pushed to the repo (perhaps using `docker.RegistryImage`) in a previous run.
     * 
     */
    @Export(name="repoDigest", refs={String.class}, tree="[0]")
    private Output<String> repoDigest;

    /**
     * @return The image sha256 digest in the form of `repo[:tag]{@literal @}sha256:&lt;hash&gt;`. This may not be populated when building an image, because it is read from the local Docker client and so may be available only when the image was either pulled from the repo or pushed to the repo (perhaps using `docker.RegistryImage`) in a previous run.
     * 
     */
    public Output<String> repoDigest() {
        return this.repoDigest;
    }
    /**
     * A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change
     * 
     */
    @Export(name="triggers", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> triggers;

    /**
     * @return A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change
     * 
     */
    public Output<Optional<Map<String,String>>> triggers() {
        return Codegen.optional(this.triggers);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public RemoteImage(java.lang.String name) {
        this(name, RemoteImageArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public RemoteImage(java.lang.String name, RemoteImageArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public RemoteImage(java.lang.String name, RemoteImageArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("docker:index/remoteImage:RemoteImage", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private RemoteImage(java.lang.String name, Output<java.lang.String> id, @Nullable RemoteImageState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("docker:index/remoteImage:RemoteImage", name, state, makeResourceOptions(options, id), false);
    }

    private static RemoteImageArgs makeArgs(RemoteImageArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? RemoteImageArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static RemoteImage get(java.lang.String name, Output<java.lang.String> id, @Nullable RemoteImageState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new RemoteImage(name, id, state, options);
    }
}
