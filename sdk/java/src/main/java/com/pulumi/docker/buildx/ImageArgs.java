// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.docker.buildx;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.docker.buildx.enums.Platform;
import com.pulumi.docker.buildx.inputs.BuildContextArgs;
import com.pulumi.docker.buildx.inputs.BuilderConfigArgs;
import com.pulumi.docker.buildx.inputs.CacheFromEntryArgs;
import com.pulumi.docker.buildx.inputs.CacheToEntryArgs;
import com.pulumi.docker.buildx.inputs.DockerfileArgs;
import com.pulumi.docker.buildx.inputs.ExportEntryArgs;
import com.pulumi.docker.buildx.inputs.RegistryAuthArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ImageArgs extends com.pulumi.resources.ResourceArgs {

    public static final ImageArgs Empty = new ImageArgs();

    /**
     * `ARG` names and values to set during the build.
     * 
     * These variables are accessed like environment variables inside `RUN`
     * instructions.
     * 
     * Build arguments are persisted in the image, so you should use `secrets`
     * if these arguments are sensitive.
     * 
     */
    @Import(name="buildArgs")
    private @Nullable Output<Map<String,String>> buildArgs;

    /**
     * @return `ARG` names and values to set during the build.
     * 
     * These variables are accessed like environment variables inside `RUN`
     * instructions.
     * 
     * Build arguments are persisted in the image, so you should use `secrets`
     * if these arguments are sensitive.
     * 
     */
    public Optional<Output<Map<String,String>>> buildArgs() {
        return Optional.ofNullable(this.buildArgs);
    }

    /**
     * When `true`, attempt to build the image during previews. The image will
     * not be pushed to registries, however caches will still populated.
     * 
     */
    @Import(name="buildOnPreview")
    private @Nullable Output<Boolean> buildOnPreview;

    /**
     * @return When `true`, attempt to build the image during previews. The image will
     * not be pushed to registries, however caches will still populated.
     * 
     */
    public Optional<Output<Boolean>> buildOnPreview() {
        return Optional.ofNullable(this.buildOnPreview);
    }

    /**
     * Builder configuration.
     * 
     */
    @Import(name="builder")
    private @Nullable Output<BuilderConfigArgs> builder;

    /**
     * @return Builder configuration.
     * 
     */
    public Optional<Output<BuilderConfigArgs>> builder_() {
        return Optional.ofNullable(this.builder);
    }

    /**
     * External cache configuration.
     * 
     */
    @Import(name="cacheFrom")
    private @Nullable Output<List<CacheFromEntryArgs>> cacheFrom;

    /**
     * @return External cache configuration.
     * 
     */
    public Optional<Output<List<CacheFromEntryArgs>>> cacheFrom() {
        return Optional.ofNullable(this.cacheFrom);
    }

    /**
     * Cache export configuration.
     * 
     */
    @Import(name="cacheTo")
    private @Nullable Output<List<CacheToEntryArgs>> cacheTo;

    /**
     * @return Cache export configuration.
     * 
     */
    public Optional<Output<List<CacheToEntryArgs>>> cacheTo() {
        return Optional.ofNullable(this.cacheTo);
    }

    /**
     * Build context settings.
     * 
     */
    @Import(name="context")
    private @Nullable Output<BuildContextArgs> context;

    /**
     * @return Build context settings.
     * 
     */
    public Optional<Output<BuildContextArgs>> context() {
        return Optional.ofNullable(this.context);
    }

    /**
     * Dockerfile settings.
     * 
     */
    @Import(name="dockerfile")
    private @Nullable Output<DockerfileArgs> dockerfile;

    /**
     * @return Dockerfile settings.
     * 
     */
    public Optional<Output<DockerfileArgs>> dockerfile() {
        return Optional.ofNullable(this.dockerfile);
    }

    /**
     * Controls where images are persisted after building.
     * 
     * Images are only stored in the local cache unless `exports` are
     * explicitly configured.
     * 
     */
    @Import(name="exports")
    private @Nullable Output<List<ExportEntryArgs>> exports;

    /**
     * @return Controls where images are persisted after building.
     * 
     * Images are only stored in the local cache unless `exports` are
     * explicitly configured.
     * 
     */
    public Optional<Output<List<ExportEntryArgs>>> exports() {
        return Optional.ofNullable(this.exports);
    }

    /**
     * Attach arbitrary key/value metadata to the image.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return Attach arbitrary key/value metadata to the image.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * Set target platform(s) for the build. Defaults to the host&#39;s platform
     * 
     */
    @Import(name="platforms")
    private @Nullable Output<List<Platform>> platforms;

    /**
     * @return Set target platform(s) for the build. Defaults to the host&#39;s platform
     * 
     */
    public Optional<Output<List<Platform>>> platforms() {
        return Optional.ofNullable(this.platforms);
    }

    /**
     * Always pull referenced images.
     * 
     */
    @Import(name="pull")
    private @Nullable Output<Boolean> pull;

    /**
     * @return Always pull referenced images.
     * 
     */
    public Optional<Output<Boolean>> pull() {
        return Optional.ofNullable(this.pull);
    }

    /**
     * Registry credentials. Required if reading or exporting to private
     * repositories.
     * 
     */
    @Import(name="registries")
    private @Nullable Output<List<RegistryAuthArgs>> registries;

    /**
     * @return Registry credentials. Required if reading or exporting to private
     * repositories.
     * 
     */
    public Optional<Output<List<RegistryAuthArgs>>> registries() {
        return Optional.ofNullable(this.registries);
    }

    /**
     * A mapping of secret names to their corresponding values.
     * 
     * Unlike the Docker CLI, these can be passed by value and do not need to
     * exist on-disk or in environment variables.
     * 
     * Build arguments and environment variables are persistent in the final
     * image, so you should use this for sensitive values.
     * 
     */
    @Import(name="secrets")
    private @Nullable Output<Map<String,String>> secrets;

    /**
     * @return A mapping of secret names to their corresponding values.
     * 
     * Unlike the Docker CLI, these can be passed by value and do not need to
     * exist on-disk or in environment variables.
     * 
     * Build arguments and environment variables are persistent in the final
     * image, so you should use this for sensitive values.
     * 
     */
    public Optional<Output<Map<String,String>>> secrets() {
        return Optional.ofNullable(this.secrets);
    }

    /**
     * Name and optionally a tag (format: `name:tag`).
     * 
     * If exporting to a registry, the name should include the fully qualified
     * registry address (e.g. `docker.io/pulumi/pulumi:latest`).
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return Name and optionally a tag (format: `name:tag`).
     * 
     * If exporting to a registry, the name should include the fully qualified
     * registry address (e.g. `docker.io/pulumi/pulumi:latest`).
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Set the target build stage(s) to build.
     * 
     * If not specified all targets will be built by default.
     * 
     */
    @Import(name="targets")
    private @Nullable Output<List<String>> targets;

    /**
     * @return Set the target build stage(s) to build.
     * 
     * If not specified all targets will be built by default.
     * 
     */
    public Optional<Output<List<String>>> targets() {
        return Optional.ofNullable(this.targets);
    }

    private ImageArgs() {}

    private ImageArgs(ImageArgs $) {
        this.buildArgs = $.buildArgs;
        this.buildOnPreview = $.buildOnPreview;
        this.builder = $.builder;
        this.cacheFrom = $.cacheFrom;
        this.cacheTo = $.cacheTo;
        this.context = $.context;
        this.dockerfile = $.dockerfile;
        this.exports = $.exports;
        this.labels = $.labels;
        this.platforms = $.platforms;
        this.pull = $.pull;
        this.registries = $.registries;
        this.secrets = $.secrets;
        this.tags = $.tags;
        this.targets = $.targets;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ImageArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ImageArgs $;

        public Builder() {
            $ = new ImageArgs();
        }

        public Builder(ImageArgs defaults) {
            $ = new ImageArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param buildArgs `ARG` names and values to set during the build.
         * 
         * These variables are accessed like environment variables inside `RUN`
         * instructions.
         * 
         * Build arguments are persisted in the image, so you should use `secrets`
         * if these arguments are sensitive.
         * 
         * @return builder
         * 
         */
        public Builder buildArgs(@Nullable Output<Map<String,String>> buildArgs) {
            $.buildArgs = buildArgs;
            return this;
        }

        /**
         * @param buildArgs `ARG` names and values to set during the build.
         * 
         * These variables are accessed like environment variables inside `RUN`
         * instructions.
         * 
         * Build arguments are persisted in the image, so you should use `secrets`
         * if these arguments are sensitive.
         * 
         * @return builder
         * 
         */
        public Builder buildArgs(Map<String,String> buildArgs) {
            return buildArgs(Output.of(buildArgs));
        }

        /**
         * @param buildOnPreview When `true`, attempt to build the image during previews. The image will
         * not be pushed to registries, however caches will still populated.
         * 
         * @return builder
         * 
         */
        public Builder buildOnPreview(@Nullable Output<Boolean> buildOnPreview) {
            $.buildOnPreview = buildOnPreview;
            return this;
        }

        /**
         * @param buildOnPreview When `true`, attempt to build the image during previews. The image will
         * not be pushed to registries, however caches will still populated.
         * 
         * @return builder
         * 
         */
        public Builder buildOnPreview(Boolean buildOnPreview) {
            return buildOnPreview(Output.of(buildOnPreview));
        }

        /**
         * @param builder Builder configuration.
         * 
         * @return builder
         * 
         */
        public Builder builder_(@Nullable Output<BuilderConfigArgs> builder) {
            $.builder = builder;
            return this;
        }

        /**
         * @param builder Builder configuration.
         * 
         * @return builder
         * 
         */
        public Builder builder_(BuilderConfigArgs builder) {
            return builder_(Output.of(builder));
        }

        /**
         * @param cacheFrom External cache configuration.
         * 
         * @return builder
         * 
         */
        public Builder cacheFrom(@Nullable Output<List<CacheFromEntryArgs>> cacheFrom) {
            $.cacheFrom = cacheFrom;
            return this;
        }

        /**
         * @param cacheFrom External cache configuration.
         * 
         * @return builder
         * 
         */
        public Builder cacheFrom(List<CacheFromEntryArgs> cacheFrom) {
            return cacheFrom(Output.of(cacheFrom));
        }

        /**
         * @param cacheFrom External cache configuration.
         * 
         * @return builder
         * 
         */
        public Builder cacheFrom(CacheFromEntryArgs... cacheFrom) {
            return cacheFrom(List.of(cacheFrom));
        }

        /**
         * @param cacheTo Cache export configuration.
         * 
         * @return builder
         * 
         */
        public Builder cacheTo(@Nullable Output<List<CacheToEntryArgs>> cacheTo) {
            $.cacheTo = cacheTo;
            return this;
        }

        /**
         * @param cacheTo Cache export configuration.
         * 
         * @return builder
         * 
         */
        public Builder cacheTo(List<CacheToEntryArgs> cacheTo) {
            return cacheTo(Output.of(cacheTo));
        }

        /**
         * @param cacheTo Cache export configuration.
         * 
         * @return builder
         * 
         */
        public Builder cacheTo(CacheToEntryArgs... cacheTo) {
            return cacheTo(List.of(cacheTo));
        }

        /**
         * @param context Build context settings.
         * 
         * @return builder
         * 
         */
        public Builder context(@Nullable Output<BuildContextArgs> context) {
            $.context = context;
            return this;
        }

        /**
         * @param context Build context settings.
         * 
         * @return builder
         * 
         */
        public Builder context(BuildContextArgs context) {
            return context(Output.of(context));
        }

        /**
         * @param dockerfile Dockerfile settings.
         * 
         * @return builder
         * 
         */
        public Builder dockerfile(@Nullable Output<DockerfileArgs> dockerfile) {
            $.dockerfile = dockerfile;
            return this;
        }

        /**
         * @param dockerfile Dockerfile settings.
         * 
         * @return builder
         * 
         */
        public Builder dockerfile(DockerfileArgs dockerfile) {
            return dockerfile(Output.of(dockerfile));
        }

        /**
         * @param exports Controls where images are persisted after building.
         * 
         * Images are only stored in the local cache unless `exports` are
         * explicitly configured.
         * 
         * @return builder
         * 
         */
        public Builder exports(@Nullable Output<List<ExportEntryArgs>> exports) {
            $.exports = exports;
            return this;
        }

        /**
         * @param exports Controls where images are persisted after building.
         * 
         * Images are only stored in the local cache unless `exports` are
         * explicitly configured.
         * 
         * @return builder
         * 
         */
        public Builder exports(List<ExportEntryArgs> exports) {
            return exports(Output.of(exports));
        }

        /**
         * @param exports Controls where images are persisted after building.
         * 
         * Images are only stored in the local cache unless `exports` are
         * explicitly configured.
         * 
         * @return builder
         * 
         */
        public Builder exports(ExportEntryArgs... exports) {
            return exports(List.of(exports));
        }

        /**
         * @param labels Attach arbitrary key/value metadata to the image.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels Attach arbitrary key/value metadata to the image.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param platforms Set target platform(s) for the build. Defaults to the host&#39;s platform
         * 
         * @return builder
         * 
         */
        public Builder platforms(@Nullable Output<List<Platform>> platforms) {
            $.platforms = platforms;
            return this;
        }

        /**
         * @param platforms Set target platform(s) for the build. Defaults to the host&#39;s platform
         * 
         * @return builder
         * 
         */
        public Builder platforms(List<Platform> platforms) {
            return platforms(Output.of(platforms));
        }

        /**
         * @param platforms Set target platform(s) for the build. Defaults to the host&#39;s platform
         * 
         * @return builder
         * 
         */
        public Builder platforms(Platform... platforms) {
            return platforms(List.of(platforms));
        }

        /**
         * @param pull Always pull referenced images.
         * 
         * @return builder
         * 
         */
        public Builder pull(@Nullable Output<Boolean> pull) {
            $.pull = pull;
            return this;
        }

        /**
         * @param pull Always pull referenced images.
         * 
         * @return builder
         * 
         */
        public Builder pull(Boolean pull) {
            return pull(Output.of(pull));
        }

        /**
         * @param registries Registry credentials. Required if reading or exporting to private
         * repositories.
         * 
         * @return builder
         * 
         */
        public Builder registries(@Nullable Output<List<RegistryAuthArgs>> registries) {
            $.registries = registries;
            return this;
        }

        /**
         * @param registries Registry credentials. Required if reading or exporting to private
         * repositories.
         * 
         * @return builder
         * 
         */
        public Builder registries(List<RegistryAuthArgs> registries) {
            return registries(Output.of(registries));
        }

        /**
         * @param registries Registry credentials. Required if reading or exporting to private
         * repositories.
         * 
         * @return builder
         * 
         */
        public Builder registries(RegistryAuthArgs... registries) {
            return registries(List.of(registries));
        }

        /**
         * @param secrets A mapping of secret names to their corresponding values.
         * 
         * Unlike the Docker CLI, these can be passed by value and do not need to
         * exist on-disk or in environment variables.
         * 
         * Build arguments and environment variables are persistent in the final
         * image, so you should use this for sensitive values.
         * 
         * @return builder
         * 
         */
        public Builder secrets(@Nullable Output<Map<String,String>> secrets) {
            $.secrets = secrets;
            return this;
        }

        /**
         * @param secrets A mapping of secret names to their corresponding values.
         * 
         * Unlike the Docker CLI, these can be passed by value and do not need to
         * exist on-disk or in environment variables.
         * 
         * Build arguments and environment variables are persistent in the final
         * image, so you should use this for sensitive values.
         * 
         * @return builder
         * 
         */
        public Builder secrets(Map<String,String> secrets) {
            return secrets(Output.of(secrets));
        }

        /**
         * @param tags Name and optionally a tag (format: `name:tag`).
         * 
         * If exporting to a registry, the name should include the fully qualified
         * registry address (e.g. `docker.io/pulumi/pulumi:latest`).
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Name and optionally a tag (format: `name:tag`).
         * 
         * If exporting to a registry, the name should include the fully qualified
         * registry address (e.g. `docker.io/pulumi/pulumi:latest`).
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags Name and optionally a tag (format: `name:tag`).
         * 
         * If exporting to a registry, the name should include the fully qualified
         * registry address (e.g. `docker.io/pulumi/pulumi:latest`).
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param targets Set the target build stage(s) to build.
         * 
         * If not specified all targets will be built by default.
         * 
         * @return builder
         * 
         */
        public Builder targets(@Nullable Output<List<String>> targets) {
            $.targets = targets;
            return this;
        }

        /**
         * @param targets Set the target build stage(s) to build.
         * 
         * If not specified all targets will be built by default.
         * 
         * @return builder
         * 
         */
        public Builder targets(List<String> targets) {
            return targets(Output.of(targets));
        }

        /**
         * @param targets Set the target build stage(s) to build.
         * 
         * If not specified all targets will be built by default.
         * 
         * @return builder
         * 
         */
        public Builder targets(String... targets) {
            return targets(List.of(targets));
        }

        public ImageArgs build() {
            return $;
        }
    }

}
