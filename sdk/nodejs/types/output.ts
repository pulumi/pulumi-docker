// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";

export interface ContainerCapabilities {
    /**
     * List of linux capabilities to add.
     */
    adds?: string[];
    /**
     * List of linux capabilities to drop.
     */
    drops?: string[];
}

export interface ContainerDevice {
    /**
     * The path in the container where the device will be bound.
     */
    containerPath?: string;
    /**
     * The path on the host where the device is located.
     */
    hostPath: string;
    /**
     * The cgroup permissions given to the container to access the device. Defaults to `rwm`.
     */
    permissions?: string;
}

export interface ContainerHealthcheck {
    /**
     * Time between running the check (ms|s|m|h). Defaults to `0s`.
     */
    interval?: string;
    /**
     * Consecutive failures needed to report unhealthy. Defaults to `0`.
     */
    retries?: number;
    /**
     * Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.
     */
    startPeriod?: string;
    /**
     * Command to run to check health. For example, to run `curl -f localhost/health` set the command to be `["CMD", "curl", "-f", "localhost/health"]`.
     */
    tests: string[];
    /**
     * Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.
     */
    timeout?: string;
}

export interface ContainerHost {
    /**
     * Hostname to add
     */
    host: string;
    /**
     * IP address this hostname should resolve to.
     */
    ip: string;
}

export interface ContainerLabel {
    /**
     * Name of the label
     */
    label: string;
    /**
     * Value of the label
     */
    value: string;
}

export interface ContainerMount {
    /**
     * Optional configuration for the bind type.
     */
    bindOptions?: outputs.ContainerMountBindOptions;
    /**
     * Whether the mount should be read-only.
     */
    readOnly?: boolean;
    /**
     * Mount source (e.g. a volume name, a host path).
     */
    source?: string;
    /**
     * Container path
     */
    target: string;
    /**
     * Optional configuration for the tmpfs type.
     */
    tmpfsOptions?: outputs.ContainerMountTmpfsOptions;
    /**
     * The mount type
     */
    type: string;
    /**
     * Optional configuration for the volume type.
     */
    volumeOptions?: outputs.ContainerMountVolumeOptions;
}

export interface ContainerMountBindOptions {
    /**
     * A propagation mode with the value.
     */
    propagation?: string;
}

export interface ContainerMountTmpfsOptions {
    /**
     * The permission mode for the tmpfs mount in an integer.
     */
    mode?: number;
    /**
     * The size for the tmpfs mount in bytes.
     */
    sizeBytes?: number;
}

export interface ContainerMountVolumeOptions {
    /**
     * Name of the driver to use to create the volume.
     */
    driverName?: string;
    /**
     * key/value map of driver specific options.
     */
    driverOptions?: {[key: string]: string};
    /**
     * User-defined key/value metadata.
     */
    labels?: outputs.ContainerMountVolumeOptionsLabel[];
    /**
     * Populate volume with data from the target.
     */
    noCopy?: boolean;
}

export interface ContainerMountVolumeOptionsLabel {
    /**
     * Name of the label
     */
    label: string;
    /**
     * Value of the label
     */
    value: string;
}

export interface ContainerNetworkData {
    gateway: string;
    globalIpv6Address: string;
    globalIpv6PrefixLength: number;
    ipAddress: string;
    ipPrefixLength: number;
    ipv6Gateway: string;
    macAddress: string;
    networkName: string;
}

export interface ContainerNetworksAdvanced {
    /**
     * The network aliases of the container in the specific network.
     */
    aliases?: string[];
    /**
     * The IPV4 address of the container in the specific network.
     */
    ipv4Address?: string;
    /**
     * The IPV6 address of the container in the specific network.
     */
    ipv6Address?: string;
    /**
     * The name or id of the network to use. You can use `name` or `id` attribute from a `docker.Network` resource.
     */
    name: string;
}

export interface ContainerPort {
    /**
     * Port exposed out of the container. If not given a free random port `>= 32768` will be used.
     */
    external: number;
    /**
     * Port within the container.
     */
    internal: number;
    /**
     * IP address/mask that can access this port. Defaults to `0.0.0.0`.
     */
    ip?: string;
    /**
     * Protocol that can be used over this port. Defaults to `tcp`.
     */
    protocol?: string;
}

export interface ContainerUlimit {
    /**
     * The hard limit
     */
    hard: number;
    /**
     * The name of the ulimit
     */
    name: string;
    /**
     * The soft limit
     */
    soft: number;
}

export interface ContainerUpload {
    /**
     * Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text. Conflicts with `contentBase64` & `source`
     */
    content?: string;
    /**
     * Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for larger binary content such as the result of the `base64encode` interpolation function. See here for the reason. Conflicts with `content` & `source`
     */
    contentBase64?: string;
    /**
     * If `true`, the file will be uploaded with user executable permission. Defaults to `false`.
     */
    executable?: boolean;
    /**
     * Path to the file in the container where is upload goes to
     */
    file: string;
    /**
     * A filename that references a file which will be uploaded as the object content. This allows for large file uploads that do not get stored in state. Conflicts with `content` & `contentBase64`
     */
    source?: string;
    /**
     * If using `source`, this will force an update if the file content has updated but the filename has not.
     */
    sourceHash?: string;
}

export interface ContainerVolume {
    /**
     * The path in the container where the volume will be mounted.
     */
    containerPath?: string;
    /**
     * The container where the volume is coming from.
     */
    fromContainer?: string;
    /**
     * The path on the host where the volume is coming from.
     */
    hostPath?: string;
    /**
     * If `true`, this volume will be readonly. Defaults to `false`.
     */
    readOnly?: boolean;
    /**
     * The name of the docker volume which should be mounted.
     */
    volumeName?: string;
}

export interface GetNetworkIpamConfig {
    auxAddress?: {[key: string]: any};
    gateway?: string;
    ipRange?: string;
    subnet?: string;
}

export interface NetworkIpamConfig {
    /**
     * Auxiliary IPv4 or IPv6 addresses used by Network driver
     */
    auxAddress?: {[key: string]: any};
    /**
     * The IP address of the gateway
     */
    gateway?: string;
    /**
     * The ip range in CIDR form
     */
    ipRange?: string;
    /**
     * The subnet in CIDR form
     */
    subnet?: string;
}

export interface NetworkLabel {
    /**
     * Name of the label
     */
    label: string;
    /**
     * Value of the label
     */
    value: string;
}

export interface PluginGrantPermission {
    /**
     * The name of the permission
     */
    name: string;
    /**
     * The value of the permission
     */
    values: string[];
}

export interface RemoteImageBuild {
    /**
     * The configuration for the authentication
     */
    authConfigs?: outputs.RemoteImageBuildAuthConfig[];
    /**
     * Set build-time variables
     */
    buildArg?: {[key: string]: string};
    /**
     * Pairs for build-time variables in the form TODO
     */
    buildArgs?: {[key: string]: string};
    /**
     * BuildID is an optional identifier that can be passed together with the build request. The same identifier can be used to gracefully cancel the build with the cancel request.
     */
    buildId?: string;
    /**
     * Images to consider as cache sources
     */
    cacheFroms?: string[];
    /**
     * Optional parent cgroup for the container
     */
    cgroupParent?: string;
    /**
     * Value to specify the build context. Currently, only a `PATH` context is supported. You can use the helper function '${path.cwd}/context-dir'. Please see https://docs.docker.com/build/building/context/ for more information about build contexts.
     */
    context: string;
    /**
     * The length of a CPU period in microseconds
     */
    cpuPeriod?: number;
    /**
     * Microseconds of CPU time that the container can get in a CPU period
     */
    cpuQuota?: number;
    /**
     * CPUs in which to allow execution (e.g., `0-3`, `0`, `1`)
     */
    cpuSetCpus?: string;
    /**
     * MEMs in which to allow execution (`0-3`, `0`, `1`)
     */
    cpuSetMems?: string;
    /**
     * CPU shares (relative weight)
     */
    cpuShares?: number;
    /**
     * Name of the Dockerfile. Defaults to `Dockerfile`.
     */
    dockerfile?: string;
    /**
     * A list of hostnames/IP mappings to add to the containerâ€™s /etc/hosts file. Specified in the form ["hostname:IP"]
     */
    extraHosts?: string[];
    /**
     * Always remove intermediate containers
     */
    forceRemove?: boolean;
    /**
     * Isolation represents the isolation technology of a container. The supported values are
     */
    isolation?: string;
    /**
     * Set metadata for an image
     */
    label?: {[key: string]: string};
    /**
     * User-defined key/value metadata
     */
    labels?: {[key: string]: string};
    /**
     * Set memory limit for build
     */
    memory?: number;
    /**
     * Total memory (memory + swap), -1 to enable unlimited swap
     */
    memorySwap?: number;
    /**
     * Set the networking mode for the RUN instructions during build
     */
    networkMode?: string;
    /**
     * Do not use the cache when building the image
     */
    noCache?: boolean;
    /**
     * Set platform if server is multi-platform capable
     */
    platform?: string;
    /**
     * Attempt to pull the image even if an older image exists locally
     */
    pullParent?: boolean;
    /**
     * A Git repository URI or HTTP/HTTPS context URI
     */
    remoteContext?: string;
    /**
     * Remove intermediate containers after a successful build. Defaults to `true`.
     */
    remove?: boolean;
    /**
     * The security options
     */
    securityOpts?: string[];
    /**
     * Set an ID for the build session
     */
    sessionId?: string;
    /**
     * Size of /dev/shm in bytes. The size must be greater than 0
     */
    shmSize?: number;
    /**
     * If true the new layers are squashed into a new image with a single new layer
     */
    squash?: boolean;
    /**
     * Suppress the build output and print image ID on success
     */
    suppressOutput?: boolean;
    /**
     * Name and optionally a tag in the 'name:tag' format
     */
    tags?: string[];
    /**
     * Set the target build stage to build
     */
    target?: string;
    /**
     * Configuration for ulimits
     */
    ulimits?: outputs.RemoteImageBuildUlimit[];
    /**
     * Version of the underlying builder to use
     */
    version?: string;
}

export interface RemoteImageBuildAuthConfig {
    /**
     * the auth token
     */
    auth?: string;
    /**
     * the user emal
     */
    email?: string;
    /**
     * hostname of the registry
     */
    hostName: string;
    /**
     * the identity token
     */
    identityToken?: string;
    /**
     * the registry password
     */
    password?: string;
    /**
     * the registry token
     */
    registryToken?: string;
    /**
     * the server address
     */
    serverAddress?: string;
    /**
     * the registry user name
     */
    userName?: string;
}

export interface RemoteImageBuildUlimit {
    /**
     * soft limit
     */
    hard: number;
    /**
     * type of ulimit, e.g. `nofile`
     */
    name: string;
    /**
     * hard limit
     */
    soft: number;
}

export interface SecretLabel {
    /**
     * Name of the label
     */
    label: string;
    /**
     * Value of the label
     */
    value: string;
}

export interface ServiceAuth {
    password?: string;
    serverAddress: string;
    username?: string;
}

export interface ServiceConvergeConfig {
    delay?: string;
    timeout?: string;
}

export interface ServiceEndpointSpec {
    mode: string;
    ports?: outputs.ServiceEndpointSpecPort[];
}

export interface ServiceEndpointSpecPort {
    name?: string;
    protocol?: string;
    publishMode?: string;
    publishedPort: number;
    targetPort: number;
}

export interface ServiceLabel {
    label: string;
    value: string;
}

export interface ServiceMode {
    global?: boolean;
    replicated: outputs.ServiceModeReplicated;
}

export interface ServiceModeReplicated {
    replicas?: number;
}

export interface ServiceRollbackConfig {
    delay?: string;
    failureAction?: string;
    maxFailureRatio?: string;
    monitor?: string;
    order?: string;
    parallelism?: number;
}

export interface ServiceTaskSpec {
    containerSpec: outputs.ServiceTaskSpecContainerSpec;
    forceUpdate: number;
    logDriver?: outputs.ServiceTaskSpecLogDriver;
    networksAdvanceds?: outputs.ServiceTaskSpecNetworksAdvanced[];
    placement: outputs.ServiceTaskSpecPlacement;
    resources: outputs.ServiceTaskSpecResources;
    restartPolicy: outputs.ServiceTaskSpecRestartPolicy;
    runtime: string;
}

export interface ServiceTaskSpecContainerSpec {
    args?: string[];
    commands?: string[];
    configs?: outputs.ServiceTaskSpecContainerSpecConfig[];
    dir?: string;
    dnsConfig: outputs.ServiceTaskSpecContainerSpecDnsConfig;
    env?: {[key: string]: string};
    groups?: string[];
    healthcheck: outputs.ServiceTaskSpecContainerSpecHealthcheck;
    hostname?: string;
    hosts?: outputs.ServiceTaskSpecContainerSpecHost[];
    image: string;
    isolation?: string;
    labels?: outputs.ServiceTaskSpecContainerSpecLabel[];
    mounts?: outputs.ServiceTaskSpecContainerSpecMount[];
    privileges?: outputs.ServiceTaskSpecContainerSpecPrivileges;
    readOnly?: boolean;
    secrets?: outputs.ServiceTaskSpecContainerSpecSecret[];
    stopGracePeriod: string;
    stopSignal?: string;
    sysctl?: {[key: string]: any};
    user?: string;
}

export interface ServiceTaskSpecContainerSpecConfig {
    configId: string;
    configName?: string;
    fileGid?: string;
    fileMode?: number;
    fileName: string;
    fileUid?: string;
}

export interface ServiceTaskSpecContainerSpecDnsConfig {
    nameservers: string[];
    options?: string[];
    searches?: string[];
}

export interface ServiceTaskSpecContainerSpecHealthcheck {
    interval?: string;
    retries?: number;
    startPeriod?: string;
    tests: string[];
    timeout?: string;
}

export interface ServiceTaskSpecContainerSpecHost {
    host: string;
    ip: string;
}

export interface ServiceTaskSpecContainerSpecLabel {
    label: string;
    value: string;
}

export interface ServiceTaskSpecContainerSpecMount {
    bindOptions?: outputs.ServiceTaskSpecContainerSpecMountBindOptions;
    readOnly?: boolean;
    source?: string;
    target: string;
    tmpfsOptions?: outputs.ServiceTaskSpecContainerSpecMountTmpfsOptions;
    type: string;
    volumeOptions?: outputs.ServiceTaskSpecContainerSpecMountVolumeOptions;
}

export interface ServiceTaskSpecContainerSpecMountBindOptions {
    propagation?: string;
}

export interface ServiceTaskSpecContainerSpecMountTmpfsOptions {
    mode?: number;
    sizeBytes?: number;
}

export interface ServiceTaskSpecContainerSpecMountVolumeOptions {
    driverName?: string;
    driverOptions?: {[key: string]: string};
    labels?: outputs.ServiceTaskSpecContainerSpecMountVolumeOptionsLabel[];
    noCopy?: boolean;
}

export interface ServiceTaskSpecContainerSpecMountVolumeOptionsLabel {
    label: string;
    value: string;
}

export interface ServiceTaskSpecContainerSpecPrivileges {
    credentialSpec?: outputs.ServiceTaskSpecContainerSpecPrivilegesCredentialSpec;
    seLinuxContext?: outputs.ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext;
}

export interface ServiceTaskSpecContainerSpecPrivilegesCredentialSpec {
    file?: string;
    registry?: string;
}

export interface ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext {
    disable?: boolean;
    level?: string;
    role?: string;
    type?: string;
    user?: string;
}

export interface ServiceTaskSpecContainerSpecSecret {
    fileGid?: string;
    fileMode?: number;
    fileName: string;
    fileUid?: string;
    secretId: string;
    secretName?: string;
}

export interface ServiceTaskSpecLogDriver {
    name: string;
    options?: {[key: string]: string};
}

export interface ServiceTaskSpecNetworksAdvanced {
    aliases?: string[];
    driverOpts?: string[];
    name: string;
}

export interface ServiceTaskSpecPlacement {
    constraints?: string[];
    maxReplicas?: number;
    platforms?: outputs.ServiceTaskSpecPlacementPlatform[];
    prefs?: string[];
}

export interface ServiceTaskSpecPlacementPlatform {
    architecture: string;
    os: string;
}

export interface ServiceTaskSpecResources {
    limits?: outputs.ServiceTaskSpecResourcesLimits;
    reservation?: outputs.ServiceTaskSpecResourcesReservation;
}

export interface ServiceTaskSpecResourcesLimits {
    memoryBytes?: number;
    nanoCpus?: number;
}

export interface ServiceTaskSpecResourcesReservation {
    genericResources?: outputs.ServiceTaskSpecResourcesReservationGenericResources;
    memoryBytes?: number;
    nanoCpus?: number;
}

export interface ServiceTaskSpecResourcesReservationGenericResources {
    discreteResourcesSpecs?: string[];
    namedResourcesSpecs?: string[];
}

export interface ServiceTaskSpecRestartPolicy {
    condition?: string;
    delay?: string;
    maxAttempts?: number;
    window?: string;
}

export interface ServiceUpdateConfig {
    delay?: string;
    failureAction?: string;
    maxFailureRatio?: string;
    monitor?: string;
    order?: string;
    parallelism?: number;
}

export interface VolumeLabel {
    /**
     * Name of the label
     */
    label: string;
    /**
     * Value of the label
     */
    value: string;
}

export namespace config {
    export interface RegistryAuth {
        address: string;
        authDisabled?: boolean;
        configFile?: string;
        configFileContent?: string;
        password?: string;
        username?: string;
    }

}
