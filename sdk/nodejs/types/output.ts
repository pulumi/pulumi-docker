// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ContainerCapabilities {
    adds?: string[];
    drops?: string[];
}

export interface ContainerDevice {
    containerPath?: string;
    hostPath: string;
    permissions?: string;
}

export interface ContainerHealthcheck {
    interval?: string;
    retries?: number;
    startPeriod?: string;
    tests: string[];
    timeout?: string;
}

export interface ContainerHost {
    host: string;
    ip: string;
}

export interface ContainerLabel {
    label: string;
    value: string;
}

export interface ContainerMount {
    bindOptions?: outputs.ContainerMountBindOptions;
    readOnly?: boolean;
    source?: string;
    target: string;
    tmpfsOptions?: outputs.ContainerMountTmpfsOptions;
    type: string;
    volumeOptions?: outputs.ContainerMountVolumeOptions;
}

export interface ContainerMountBindOptions {
    propagation?: string;
}

export interface ContainerMountTmpfsOptions {
    mode?: number;
    sizeBytes?: number;
}

export interface ContainerMountVolumeOptions {
    driverName?: string;
    driverOptions?: {[key: string]: string};
    labels?: outputs.ContainerMountVolumeOptionsLabel[];
    noCopy?: boolean;
}

export interface ContainerMountVolumeOptionsLabel {
    label: string;
    value: string;
}

export interface ContainerNetworkData {
    /**
     * @deprecated Use `network_data` instead. The network gateway of the container as read from its NetworkSettings.
     */
    gateway: string;
    globalIpv6Address: string;
    globalIpv6PrefixLength: number;
    /**
     * @deprecated Use `network_data` instead. The IP address of the container's first network it.
     */
    ipAddress: string;
    /**
     * @deprecated Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings.
     */
    ipPrefixLength: number;
    ipv6Gateway: string;
    networkName: string;
}

export interface ContainerNetworksAdvanced {
    aliases?: string[];
    ipv4Address?: string;
    ipv6Address?: string;
    name: string;
}

export interface ContainerPort {
    external: number;
    internal: number;
    ip?: string;
    protocol?: string;
}

export interface ContainerUlimit {
    hard: number;
    name: string;
    soft: number;
}

export interface ContainerUpload {
    content?: string;
    contentBase64?: string;
    executable?: boolean;
    file: string;
    source?: string;
    sourceHash?: string;
}

export interface ContainerVolume {
    containerPath?: string;
    fromContainer?: string;
    hostPath?: string;
    readOnly?: boolean;
    volumeName?: string;
}

export interface GetNetworkIpamConfig {
    auxAddress?: {[key: string]: any};
    gateway?: string;
    ipRange?: string;
    subnet?: string;
}

export interface NetworkIpamConfig {
    auxAddress?: {[key: string]: any};
    gateway?: string;
    ipRange?: string;
    subnet?: string;
}

export interface NetworkLabel {
    label: string;
    value: string;
}

export interface PluginGrantPermission {
    name: string;
    values: string[];
}

export interface ProviderRegistryAuth {
    address?: string;
    configFile?: string;
    configFileContent?: string;
    password?: string;
    username?: string;
}

export interface RegistryImageBuild {
    authConfigs?: outputs.RegistryImageBuildAuthConfig[];
    buildArgs?: {[key: string]: string};
    buildId?: string;
    cacheFroms?: string[];
    cgroupParent?: string;
    context: string;
    cpuPeriod?: number;
    cpuQuota?: number;
    cpuSetCpus?: string;
    cpuSetMems?: string;
    cpuShares?: number;
    dockerfile?: string;
    extraHosts?: string[];
    forceRemove?: boolean;
    isolation?: string;
    labels?: {[key: string]: string};
    memory?: number;
    memorySwap?: number;
    networkMode?: string;
    noCache?: boolean;
    platform?: string;
    pullParent?: boolean;
    remoteContext?: string;
    remove?: boolean;
    securityOpts?: string[];
    sessionId?: string;
    shmSize?: number;
    squash?: boolean;
    suppressOutput?: boolean;
    target?: string;
    ulimits?: outputs.RegistryImageBuildUlimit[];
    version?: string;
}

export interface RegistryImageBuildAuthConfig {
    auth?: string;
    email?: string;
    hostName: string;
    identityToken?: string;
    password?: string;
    registryToken?: string;
    serverAddress?: string;
    userName?: string;
}

export interface RegistryImageBuildUlimit {
    hard: number;
    name: string;
    soft: number;
}

export interface RemoteImageBuild {
    buildArg?: {[key: string]: string};
    dockerfile?: string;
    forceRemove?: boolean;
    label?: {[key: string]: string};
    noCache?: boolean;
    path: string;
    remove?: boolean;
    tags?: string[];
    target?: string;
}

export interface SecretLabel {
    label: string;
    value: string;
}

export interface ServiceAuth {
    password?: string;
    serverAddress: string;
    username?: string;
}

export interface ServiceConvergeConfig {
    delay?: string;
    timeout?: string;
}

export interface ServiceEndpointSpec {
    mode: string;
    ports?: outputs.ServiceEndpointSpecPort[];
}

export interface ServiceEndpointSpecPort {
    name?: string;
    protocol?: string;
    publishMode?: string;
    publishedPort: number;
    targetPort: number;
}

export interface ServiceLabel {
    label: string;
    value: string;
}

export interface ServiceMode {
    global?: boolean;
    replicated: outputs.ServiceModeReplicated;
}

export interface ServiceModeReplicated {
    replicas?: number;
}

export interface ServiceRollbackConfig {
    delay?: string;
    failureAction?: string;
    maxFailureRatio?: string;
    monitor?: string;
    order?: string;
    parallelism?: number;
}

export interface ServiceTaskSpec {
    containerSpec: outputs.ServiceTaskSpecContainerSpec;
    forceUpdate: number;
    logDriver?: outputs.ServiceTaskSpecLogDriver;
    networks?: string[];
    placement: outputs.ServiceTaskSpecPlacement;
    resources: outputs.ServiceTaskSpecResources;
    restartPolicy: outputs.ServiceTaskSpecRestartPolicy;
    runtime: string;
}

export interface ServiceTaskSpecContainerSpec {
    args?: string[];
    commands?: string[];
    configs?: outputs.ServiceTaskSpecContainerSpecConfig[];
    dir?: string;
    dnsConfig: outputs.ServiceTaskSpecContainerSpecDnsConfig;
    env?: {[key: string]: string};
    groups?: string[];
    healthcheck: outputs.ServiceTaskSpecContainerSpecHealthcheck;
    hostname?: string;
    hosts?: outputs.ServiceTaskSpecContainerSpecHost[];
    image: string;
    isolation?: string;
    labels?: outputs.ServiceTaskSpecContainerSpecLabel[];
    mounts?: outputs.ServiceTaskSpecContainerSpecMount[];
    privileges?: outputs.ServiceTaskSpecContainerSpecPrivileges;
    readOnly?: boolean;
    secrets?: outputs.ServiceTaskSpecContainerSpecSecret[];
    stopGracePeriod: string;
    stopSignal?: string;
    user?: string;
}

export interface ServiceTaskSpecContainerSpecConfig {
    configId: string;
    configName?: string;
    fileGid?: string;
    fileMode?: number;
    fileName: string;
    fileUid?: string;
}

export interface ServiceTaskSpecContainerSpecDnsConfig {
    nameservers: string[];
    options?: string[];
    searches?: string[];
}

export interface ServiceTaskSpecContainerSpecHealthcheck {
    interval?: string;
    retries?: number;
    startPeriod?: string;
    tests: string[];
    timeout?: string;
}

export interface ServiceTaskSpecContainerSpecHost {
    host: string;
    ip: string;
}

export interface ServiceTaskSpecContainerSpecLabel {
    label: string;
    value: string;
}

export interface ServiceTaskSpecContainerSpecMount {
    bindOptions?: outputs.ServiceTaskSpecContainerSpecMountBindOptions;
    readOnly?: boolean;
    source?: string;
    target: string;
    tmpfsOptions?: outputs.ServiceTaskSpecContainerSpecMountTmpfsOptions;
    type: string;
    volumeOptions?: outputs.ServiceTaskSpecContainerSpecMountVolumeOptions;
}

export interface ServiceTaskSpecContainerSpecMountBindOptions {
    propagation?: string;
}

export interface ServiceTaskSpecContainerSpecMountTmpfsOptions {
    mode?: number;
    sizeBytes?: number;
}

export interface ServiceTaskSpecContainerSpecMountVolumeOptions {
    driverName?: string;
    driverOptions?: {[key: string]: string};
    labels?: outputs.ServiceTaskSpecContainerSpecMountVolumeOptionsLabel[];
    noCopy?: boolean;
}

export interface ServiceTaskSpecContainerSpecMountVolumeOptionsLabel {
    label: string;
    value: string;
}

export interface ServiceTaskSpecContainerSpecPrivileges {
    credentialSpec?: outputs.ServiceTaskSpecContainerSpecPrivilegesCredentialSpec;
    seLinuxContext?: outputs.ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext;
}

export interface ServiceTaskSpecContainerSpecPrivilegesCredentialSpec {
    file?: string;
    registry?: string;
}

export interface ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext {
    disable?: boolean;
    level?: string;
    role?: string;
    type?: string;
    user?: string;
}

export interface ServiceTaskSpecContainerSpecSecret {
    fileGid?: string;
    fileMode?: number;
    fileName: string;
    fileUid?: string;
    secretId: string;
    secretName?: string;
}

export interface ServiceTaskSpecLogDriver {
    name: string;
    options?: {[key: string]: string};
}

export interface ServiceTaskSpecPlacement {
    constraints?: string[];
    maxReplicas?: number;
    platforms?: outputs.ServiceTaskSpecPlacementPlatform[];
    prefs?: string[];
}

export interface ServiceTaskSpecPlacementPlatform {
    architecture: string;
    os: string;
}

export interface ServiceTaskSpecResources {
    limits?: outputs.ServiceTaskSpecResourcesLimits;
    reservation?: outputs.ServiceTaskSpecResourcesReservation;
}

export interface ServiceTaskSpecResourcesLimits {
    memoryBytes?: number;
    nanoCpus?: number;
}

export interface ServiceTaskSpecResourcesReservation {
    genericResources?: outputs.ServiceTaskSpecResourcesReservationGenericResources;
    memoryBytes?: number;
    nanoCpus?: number;
}

export interface ServiceTaskSpecResourcesReservationGenericResources {
    discreteResourcesSpecs?: string[];
    namedResourcesSpecs?: string[];
}

export interface ServiceTaskSpecRestartPolicy {
    condition?: string;
    delay?: string;
    maxAttempts?: number;
    window?: string;
}

export interface ServiceUpdateConfig {
    delay?: string;
    failureAction?: string;
    maxFailureRatio?: string;
    monitor?: string;
    order?: string;
    parallelism?: number;
}

export interface VolumeLabel {
    label: string;
    value: string;
}
export namespace config {
    export interface RegistryAuth {
        address: string;
        configFile?: string;
        configFileContent?: string;
        password?: string;
        username?: string;
    }
}
