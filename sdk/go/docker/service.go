// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package docker

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// <!-- Bug: Type and Name are switched -->
// This resource manages the lifecycle of a Docker service. By default, the creation, update and delete of services are detached.
//
//	With the Converge Config the behavior of the `docker cli` is imitated to guarantee tha for example, all tasks of a service are running or successfully updated or to inform `terraform` that a service could no be updated and was successfully rolled back.
//
// ## Example Usage
//
// ### Basic
//
// # The following configuration starts a Docker Service with
//
// - the given image,
// - 1 replica
// - exposes the port `8080` in `vip` mode to the host machine
// - moreover, uses the `container` runtime
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := docker.NewService(ctx, "foo", &docker.ServiceArgs{
//				Name: pulumi.String("foo-service"),
//				TaskSpec: &docker.ServiceTaskSpecArgs{
//					ContainerSpec: &docker.ServiceTaskSpecContainerSpecArgs{
//						Image: pulumi.String("repo.mycompany.com:8080/foo-service:v1"),
//					},
//				},
//				EndpointSpec: &docker.ServiceEndpointSpecArgs{
//					Ports: docker.ServiceEndpointSpecPortArray{
//						&docker.ServiceEndpointSpecPortArgs{
//							TargetPort: pulumi.Int(8080),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// The following command is the equivalent:
//
// ### Basic with Datasource
//
// Alternatively, if the image is already present on the Docker Host and not managed
// by `terraform`, you can also use the `RemoteImage` datasource:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			foo, err := docker.LookupRemoteImage(ctx, &docker.LookupRemoteImageArgs{
//				Name: "repo.mycompany.com:8080/foo-service:v1",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = docker.NewService(ctx, "foo", &docker.ServiceArgs{
//				Name: pulumi.String("foo-service"),
//				TaskSpec: &docker.ServiceTaskSpecArgs{
//					ContainerSpec: &docker.ServiceTaskSpecContainerSpecArgs{
//						Image: pulumi.String(foo.RepoDigest),
//					},
//				},
//				EndpointSpec: &docker.ServiceEndpointSpecArgs{
//					Ports: docker.ServiceEndpointSpecPortArray{
//						&docker.ServiceEndpointSpecPortArgs{
//							TargetPort: pulumi.Int(8080),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Advanced
//
// The following configuration shows the full capabilities of a Docker Service,
// with a `volume`, `config`, `secret` and `network`
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testVolume, err := docker.NewVolume(ctx, "test_volume", &docker.VolumeArgs{
//				Name: pulumi.String("tftest-volume"),
//			})
//			if err != nil {
//				return err
//			}
//			testVolume2, err := docker.NewVolume(ctx, "test_volume_2", &docker.VolumeArgs{
//				Name: pulumi.String("tftest-volume2"),
//			})
//			if err != nil {
//				return err
//			}
//			serviceConfig, err := docker.NewServiceConfig(ctx, "service_config", &docker.ServiceConfigArgs{
//				Name: pulumi.String("tftest-full-myconfig"),
//				Data: pulumi.String("ewogICJwcmVmaXgiOiAiMTIzIgp9"),
//			})
//			if err != nil {
//				return err
//			}
//			serviceSecret, err := docker.NewSecret(ctx, "service_secret", &docker.SecretArgs{
//				Name: pulumi.String("tftest-mysecret"),
//				Data: pulumi.String("ewogICJrZXkiOiAiUVdFUlRZIgp9"),
//			})
//			if err != nil {
//				return err
//			}
//			testNetwork, err := docker.NewNetwork(ctx, "test_network", &docker.NetworkArgs{
//				Name:   pulumi.String("tftest-network"),
//				Driver: pulumi.String("overlay"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = docker.NewService(ctx, "foo", &docker.ServiceArgs{
//				Name: pulumi.String("tftest-service-basic"),
//				TaskSpec: &docker.ServiceTaskSpecArgs{
//					ContainerSpec: &docker.ServiceTaskSpecContainerSpecArgs{
//						Configs: docker.ServiceTaskSpecContainerSpecConfigArray{
//							&docker.ServiceTaskSpecContainerSpecConfigArgs{
//								ConfigId:   serviceConfig.ID(),
//								ConfigName: serviceConfig.Name,
//								FileName:   pulumi.String("/configs.json"),
//							},
//							&docker.ServiceTaskSpecContainerSpecConfigArgs{},
//						},
//						Secrets: docker.ServiceTaskSpecContainerSpecSecretArray{
//							&docker.ServiceTaskSpecContainerSpecSecretArgs{
//								SecretId:   serviceSecret.ID(),
//								SecretName: serviceSecret.Name,
//								FileName:   pulumi.String("/secrets.json"),
//								FileUid:    pulumi.String("0"),
//								FileGid:    pulumi.String("0"),
//								FileMode:   pulumi.Int(777),
//							},
//							&docker.ServiceTaskSpecContainerSpecSecretArgs{},
//						},
//						Image: pulumi.String("repo.mycompany.com:8080/foo-service:v1"),
//						Labels: docker.ServiceTaskSpecContainerSpecLabelArray{
//							&docker.ServiceTaskSpecContainerSpecLabelArgs{
//								Label: pulumi.String("foo.bar"),
//								Value: pulumi.String("baz"),
//							},
//						},
//						Commands: pulumi.StringArray{
//							pulumi.String("ls"),
//						},
//						Args: pulumi.StringArray{
//							pulumi.String("-las"),
//						},
//						Hostname: pulumi.String("my-fancy-service"),
//						Env: pulumi.StringMap{
//							"MYFOO": pulumi.String("BAR"),
//						},
//						Dir:  pulumi.String("/root"),
//						User: pulumi.String("root"),
//						Groups: pulumi.StringArray{
//							pulumi.String("docker"),
//							pulumi.String("foogroup"),
//						},
//						Privileges: &docker.ServiceTaskSpecContainerSpecPrivilegesArgs{
//							SeLinuxContext: &docker.ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgs{
//								Disable: pulumi.Bool(true),
//								User:    pulumi.String("user-label"),
//								Role:    pulumi.String("role-label"),
//								Type:    pulumi.String("type-label"),
//								Level:   pulumi.String("level-label"),
//							},
//						},
//						ReadOnly: pulumi.Bool(true),
//						Mounts: docker.ServiceTaskSpecContainerSpecMountArray{
//							&docker.ServiceTaskSpecContainerSpecMountArgs{
//								Target:   pulumi.String("/mount/test"),
//								Source:   testVolume.Name,
//								Type:     pulumi.String("bind"),
//								ReadOnly: pulumi.Bool(true),
//								BindOptions: &docker.ServiceTaskSpecContainerSpecMountBindOptionsArgs{
//									Propagation: pulumi.String("rprivate"),
//								},
//							},
//							&docker.ServiceTaskSpecContainerSpecMountArgs{
//								Target:   pulumi.String("/mount/test2"),
//								Source:   testVolume2.Name,
//								Type:     pulumi.String("volume"),
//								ReadOnly: pulumi.Bool(true),
//								VolumeOptions: &docker.ServiceTaskSpecContainerSpecMountVolumeOptionsArgs{
//									NoCopy: pulumi.Bool(true),
//									Labels: docker.ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArray{
//										&docker.ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgs{
//											Label: pulumi.String("foo"),
//											Value: pulumi.String("bar"),
//										},
//									},
//									DriverName: pulumi.String("random-driver"),
//									DriverOptions: pulumi.StringMap{
//										"op1": pulumi.String("val1"),
//									},
//								},
//							},
//						},
//						StopSignal:      pulumi.String("SIGTERM"),
//						StopGracePeriod: pulumi.String("10s"),
//						Healthcheck: &docker.ServiceTaskSpecContainerSpecHealthcheckArgs{
//							Tests: pulumi.StringArray{
//								pulumi.String("CMD"),
//								pulumi.String("curl"),
//								pulumi.String("-f"),
//								pulumi.String("http://localhost:8080/health"),
//							},
//							Interval: pulumi.String("5s"),
//							Timeout:  pulumi.String("2s"),
//							Retries:  pulumi.Int(4),
//						},
//						Hosts: docker.ServiceTaskSpecContainerSpecHostArray{
//							&docker.ServiceTaskSpecContainerSpecHostArgs{
//								Host: pulumi.String("testhost"),
//								Ip:   pulumi.String("10.0.1.0"),
//							},
//						},
//						DnsConfig: &docker.ServiceTaskSpecContainerSpecDnsConfigArgs{
//							Nameservers: pulumi.StringArray{
//								pulumi.String("8.8.8.8"),
//							},
//							Searches: pulumi.StringArray{
//								pulumi.String("example.org"),
//							},
//							Options: pulumi.StringArray{
//								pulumi.String("timeout:3"),
//							},
//						},
//					},
//					Resources: &docker.ServiceTaskSpecResourcesArgs{
//						Limits: &docker.ServiceTaskSpecResourcesLimitsArgs{
//							NanoCpus:    pulumi.Int(1000000),
//							MemoryBytes: pulumi.Int(536870912),
//						},
//						Reservation: &docker.ServiceTaskSpecResourcesReservationArgs{
//							NanoCpus:    pulumi.Int(1000000),
//							MemoryBytes: pulumi.Int(536870912),
//							GenericResources: &docker.ServiceTaskSpecResourcesReservationGenericResourcesArgs{
//								NamedResourcesSpecs: pulumi.StringArray{
//									pulumi.String("GPU=UUID1"),
//								},
//								DiscreteResourcesSpecs: pulumi.StringArray{
//									pulumi.String("SSD=3"),
//								},
//							},
//						},
//					},
//					RestartPolicy: map[string]interface{}{
//						"condition":   "on-failure",
//						"delay":       "3s",
//						"maxAttempts": 4,
//						"window":      "10s",
//					}[0],
//					Placement: &docker.ServiceTaskSpecPlacementArgs{
//						Constraints: pulumi.StringArray{
//							pulumi.String("node.role==manager"),
//						},
//						Prefs: pulumi.StringArray{
//							pulumi.String("spread=node.role.manager"),
//						},
//						MaxReplicas: pulumi.Int(1),
//					},
//					ForceUpdate: pulumi.Int(0),
//					Runtime:     pulumi.String("container"),
//					Networks: pulumi.StringArray{
//						testNetwork.ID(),
//					},
//					LogDriver: &docker.ServiceTaskSpecLogDriverArgs{
//						Name: pulumi.String("json-file"),
//						Options: pulumi.StringMap{
//							"max-size": pulumi.String("10m"),
//							"max-file": pulumi.String("3"),
//						},
//					},
//				},
//				Mode: &docker.ServiceModeArgs{
//					Replicated: &docker.ServiceModeReplicatedArgs{
//						Replicas: pulumi.Int(2),
//					},
//				},
//				UpdateConfig: &docker.ServiceUpdateConfigArgs{
//					Parallelism:     pulumi.Int(2),
//					Delay:           pulumi.String("10s"),
//					FailureAction:   pulumi.String("pause"),
//					Monitor:         pulumi.String("5s"),
//					MaxFailureRatio: pulumi.String("0.1"),
//					Order:           pulumi.String("start-first"),
//				},
//				RollbackConfig: &docker.ServiceRollbackConfigArgs{
//					Parallelism:     pulumi.Int(2),
//					Delay:           pulumi.String("5ms"),
//					FailureAction:   pulumi.String("pause"),
//					Monitor:         pulumi.String("10h"),
//					MaxFailureRatio: pulumi.String("0.9"),
//					Order:           pulumi.String("stop-first"),
//				},
//				EndpointSpec: &docker.ServiceEndpointSpecArgs{
//					Ports: docker.ServiceEndpointSpecPortArray{
//						&docker.ServiceEndpointSpecPortArgs{
//							Name:          pulumi.String("random"),
//							Protocol:      pulumi.String("tcp"),
//							TargetPort:    pulumi.Int(8080),
//							PublishedPort: pulumi.Int(8080),
//							PublishMode:   pulumi.String("ingress"),
//						},
//						&docker.ServiceEndpointSpecPortArgs{},
//					},
//					Mode: pulumi.String("vip"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// !/bin/bash
//
// ```sh
// $ pulumi import docker:index/service:Service foo id
// ```
//
// ### Example
//
// # Assuming you created a `service` as follows
//
// ```sh
// #!/bin/bash
// docker service create --name foo -p 8080:80 nginx
// # prints th ID
// 4pcphbxkfn2rffhbhe6czytgi
// ```
//
// you provide the definition for the resource as follows
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := docker.NewService(ctx, "foo", &docker.ServiceArgs{
//				Name: pulumi.String("foo"),
//				TaskSpec: &docker.ServiceTaskSpecArgs{
//					ContainerSpec: &docker.ServiceTaskSpecContainerSpecArgs{
//						Image: pulumi.String("nginx"),
//					},
//				},
//				EndpointSpec: &docker.ServiceEndpointSpecArgs{
//					Ports: docker.ServiceEndpointSpecPortArray{
//						&docker.ServiceEndpointSpecPortArgs{
//							TargetPort:    pulumi.Int(80),
//							PublishedPort: pulumi.Int(8080),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// then the import command is as follows
//
// !/bin/bash
//
// ```sh
// $ pulumi import docker:index/service:Service foo 4pcphbxkfn2rffhbhe6czytgi
// ```
type Service struct {
	pulumi.CustomResourceState

	// Configuration for the authentication for pulling the images of the service
	Auth ServiceAuthPtrOutput `pulumi:"auth"`
	// A configuration to ensure that a service converges aka reaches the desired that of all task up and running
	ConvergeConfig ServiceConvergeConfigPtrOutput `pulumi:"convergeConfig"`
	// Properties that can be configured to access and load balance a service
	EndpointSpec ServiceEndpointSpecOutput `pulumi:"endpointSpec"`
	// User-defined key/value metadata
	Labels ServiceLabelArrayOutput `pulumi:"labels"`
	// Scheduling mode for the service
	Mode ServiceModeOutput `pulumi:"mode"`
	// Name of the service
	Name pulumi.StringOutput `pulumi:"name"`
	// Specification for the rollback strategy of the service
	RollbackConfig ServiceRollbackConfigPtrOutput `pulumi:"rollbackConfig"`
	// User modifiable task configuration
	TaskSpec ServiceTaskSpecOutput `pulumi:"taskSpec"`
	// Specification for the update strategy of the service
	UpdateConfig ServiceUpdateConfigPtrOutput `pulumi:"updateConfig"`
}

// NewService registers a new resource with the given unique name, arguments, and options.
func NewService(ctx *pulumi.Context,
	name string, args *ServiceArgs, opts ...pulumi.ResourceOption) (*Service, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.TaskSpec == nil {
		return nil, errors.New("invalid value for required argument 'TaskSpec'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Service
	err := ctx.RegisterResource("docker:index/service:Service", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetService gets an existing Service resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetService(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServiceState, opts ...pulumi.ResourceOption) (*Service, error) {
	var resource Service
	err := ctx.ReadResource("docker:index/service:Service", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Service resources.
type serviceState struct {
	// Configuration for the authentication for pulling the images of the service
	Auth *ServiceAuth `pulumi:"auth"`
	// A configuration to ensure that a service converges aka reaches the desired that of all task up and running
	ConvergeConfig *ServiceConvergeConfig `pulumi:"convergeConfig"`
	// Properties that can be configured to access and load balance a service
	EndpointSpec *ServiceEndpointSpec `pulumi:"endpointSpec"`
	// User-defined key/value metadata
	Labels []ServiceLabel `pulumi:"labels"`
	// Scheduling mode for the service
	Mode *ServiceMode `pulumi:"mode"`
	// Name of the service
	Name *string `pulumi:"name"`
	// Specification for the rollback strategy of the service
	RollbackConfig *ServiceRollbackConfig `pulumi:"rollbackConfig"`
	// User modifiable task configuration
	TaskSpec *ServiceTaskSpec `pulumi:"taskSpec"`
	// Specification for the update strategy of the service
	UpdateConfig *ServiceUpdateConfig `pulumi:"updateConfig"`
}

type ServiceState struct {
	// Configuration for the authentication for pulling the images of the service
	Auth ServiceAuthPtrInput
	// A configuration to ensure that a service converges aka reaches the desired that of all task up and running
	ConvergeConfig ServiceConvergeConfigPtrInput
	// Properties that can be configured to access and load balance a service
	EndpointSpec ServiceEndpointSpecPtrInput
	// User-defined key/value metadata
	Labels ServiceLabelArrayInput
	// Scheduling mode for the service
	Mode ServiceModePtrInput
	// Name of the service
	Name pulumi.StringPtrInput
	// Specification for the rollback strategy of the service
	RollbackConfig ServiceRollbackConfigPtrInput
	// User modifiable task configuration
	TaskSpec ServiceTaskSpecPtrInput
	// Specification for the update strategy of the service
	UpdateConfig ServiceUpdateConfigPtrInput
}

func (ServiceState) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceState)(nil)).Elem()
}

type serviceArgs struct {
	// Configuration for the authentication for pulling the images of the service
	Auth *ServiceAuth `pulumi:"auth"`
	// A configuration to ensure that a service converges aka reaches the desired that of all task up and running
	ConvergeConfig *ServiceConvergeConfig `pulumi:"convergeConfig"`
	// Properties that can be configured to access and load balance a service
	EndpointSpec *ServiceEndpointSpec `pulumi:"endpointSpec"`
	// User-defined key/value metadata
	Labels []ServiceLabel `pulumi:"labels"`
	// Scheduling mode for the service
	Mode *ServiceMode `pulumi:"mode"`
	// Name of the service
	Name *string `pulumi:"name"`
	// Specification for the rollback strategy of the service
	RollbackConfig *ServiceRollbackConfig `pulumi:"rollbackConfig"`
	// User modifiable task configuration
	TaskSpec ServiceTaskSpec `pulumi:"taskSpec"`
	// Specification for the update strategy of the service
	UpdateConfig *ServiceUpdateConfig `pulumi:"updateConfig"`
}

// The set of arguments for constructing a Service resource.
type ServiceArgs struct {
	// Configuration for the authentication for pulling the images of the service
	Auth ServiceAuthPtrInput
	// A configuration to ensure that a service converges aka reaches the desired that of all task up and running
	ConvergeConfig ServiceConvergeConfigPtrInput
	// Properties that can be configured to access and load balance a service
	EndpointSpec ServiceEndpointSpecPtrInput
	// User-defined key/value metadata
	Labels ServiceLabelArrayInput
	// Scheduling mode for the service
	Mode ServiceModePtrInput
	// Name of the service
	Name pulumi.StringPtrInput
	// Specification for the rollback strategy of the service
	RollbackConfig ServiceRollbackConfigPtrInput
	// User modifiable task configuration
	TaskSpec ServiceTaskSpecInput
	// Specification for the update strategy of the service
	UpdateConfig ServiceUpdateConfigPtrInput
}

func (ServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serviceArgs)(nil)).Elem()
}

type ServiceInput interface {
	pulumi.Input

	ToServiceOutput() ServiceOutput
	ToServiceOutputWithContext(ctx context.Context) ServiceOutput
}

func (*Service) ElementType() reflect.Type {
	return reflect.TypeOf((**Service)(nil)).Elem()
}

func (i *Service) ToServiceOutput() ServiceOutput {
	return i.ToServiceOutputWithContext(context.Background())
}

func (i *Service) ToServiceOutputWithContext(ctx context.Context) ServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceOutput)
}

// ServiceArrayInput is an input type that accepts ServiceArray and ServiceArrayOutput values.
// You can construct a concrete instance of `ServiceArrayInput` via:
//
//	ServiceArray{ ServiceArgs{...} }
type ServiceArrayInput interface {
	pulumi.Input

	ToServiceArrayOutput() ServiceArrayOutput
	ToServiceArrayOutputWithContext(context.Context) ServiceArrayOutput
}

type ServiceArray []ServiceInput

func (ServiceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Service)(nil)).Elem()
}

func (i ServiceArray) ToServiceArrayOutput() ServiceArrayOutput {
	return i.ToServiceArrayOutputWithContext(context.Background())
}

func (i ServiceArray) ToServiceArrayOutputWithContext(ctx context.Context) ServiceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceArrayOutput)
}

// ServiceMapInput is an input type that accepts ServiceMap and ServiceMapOutput values.
// You can construct a concrete instance of `ServiceMapInput` via:
//
//	ServiceMap{ "key": ServiceArgs{...} }
type ServiceMapInput interface {
	pulumi.Input

	ToServiceMapOutput() ServiceMapOutput
	ToServiceMapOutputWithContext(context.Context) ServiceMapOutput
}

type ServiceMap map[string]ServiceInput

func (ServiceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Service)(nil)).Elem()
}

func (i ServiceMap) ToServiceMapOutput() ServiceMapOutput {
	return i.ToServiceMapOutputWithContext(context.Background())
}

func (i ServiceMap) ToServiceMapOutputWithContext(ctx context.Context) ServiceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceMapOutput)
}

type ServiceOutput struct{ *pulumi.OutputState }

func (ServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Service)(nil)).Elem()
}

func (o ServiceOutput) ToServiceOutput() ServiceOutput {
	return o
}

func (o ServiceOutput) ToServiceOutputWithContext(ctx context.Context) ServiceOutput {
	return o
}

// Configuration for the authentication for pulling the images of the service
func (o ServiceOutput) Auth() ServiceAuthPtrOutput {
	return o.ApplyT(func(v *Service) ServiceAuthPtrOutput { return v.Auth }).(ServiceAuthPtrOutput)
}

// A configuration to ensure that a service converges aka reaches the desired that of all task up and running
func (o ServiceOutput) ConvergeConfig() ServiceConvergeConfigPtrOutput {
	return o.ApplyT(func(v *Service) ServiceConvergeConfigPtrOutput { return v.ConvergeConfig }).(ServiceConvergeConfigPtrOutput)
}

// Properties that can be configured to access and load balance a service
func (o ServiceOutput) EndpointSpec() ServiceEndpointSpecOutput {
	return o.ApplyT(func(v *Service) ServiceEndpointSpecOutput { return v.EndpointSpec }).(ServiceEndpointSpecOutput)
}

// User-defined key/value metadata
func (o ServiceOutput) Labels() ServiceLabelArrayOutput {
	return o.ApplyT(func(v *Service) ServiceLabelArrayOutput { return v.Labels }).(ServiceLabelArrayOutput)
}

// Scheduling mode for the service
func (o ServiceOutput) Mode() ServiceModeOutput {
	return o.ApplyT(func(v *Service) ServiceModeOutput { return v.Mode }).(ServiceModeOutput)
}

// Name of the service
func (o ServiceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Service) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Specification for the rollback strategy of the service
func (o ServiceOutput) RollbackConfig() ServiceRollbackConfigPtrOutput {
	return o.ApplyT(func(v *Service) ServiceRollbackConfigPtrOutput { return v.RollbackConfig }).(ServiceRollbackConfigPtrOutput)
}

// User modifiable task configuration
func (o ServiceOutput) TaskSpec() ServiceTaskSpecOutput {
	return o.ApplyT(func(v *Service) ServiceTaskSpecOutput { return v.TaskSpec }).(ServiceTaskSpecOutput)
}

// Specification for the update strategy of the service
func (o ServiceOutput) UpdateConfig() ServiceUpdateConfigPtrOutput {
	return o.ApplyT(func(v *Service) ServiceUpdateConfigPtrOutput { return v.UpdateConfig }).(ServiceUpdateConfigPtrOutput)
}

type ServiceArrayOutput struct{ *pulumi.OutputState }

func (ServiceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Service)(nil)).Elem()
}

func (o ServiceArrayOutput) ToServiceArrayOutput() ServiceArrayOutput {
	return o
}

func (o ServiceArrayOutput) ToServiceArrayOutputWithContext(ctx context.Context) ServiceArrayOutput {
	return o
}

func (o ServiceArrayOutput) Index(i pulumi.IntInput) ServiceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Service {
		return vs[0].([]*Service)[vs[1].(int)]
	}).(ServiceOutput)
}

type ServiceMapOutput struct{ *pulumi.OutputState }

func (ServiceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Service)(nil)).Elem()
}

func (o ServiceMapOutput) ToServiceMapOutput() ServiceMapOutput {
	return o
}

func (o ServiceMapOutput) ToServiceMapOutputWithContext(ctx context.Context) ServiceMapOutput {
	return o
}

func (o ServiceMapOutput) MapIndex(k pulumi.StringInput) ServiceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Service {
		return vs[0].(map[string]*Service)[vs[1].(string)]
	}).(ServiceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceInput)(nil)).Elem(), &Service{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceArrayInput)(nil)).Elem(), ServiceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceMapInput)(nil)).Elem(), ServiceMap{})
	pulumi.RegisterOutputType(ServiceOutput{})
	pulumi.RegisterOutputType(ServiceArrayOutput{})
	pulumi.RegisterOutputType(ServiceMapOutput{})
}
