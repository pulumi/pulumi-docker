// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package buildx

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A Docker image built using buildx -- Docker's interface to the improved
// BuildKit backend.
//
// **This resource is experimental and subject to change.**
//
// API types are unstable. Subsequent releases _may_ require manual edits
// to your state file(s) in order to adopt API changes.
//
// Only use this resource if you understand and accept the risks.
//
// ## Example Usage
// ### Multi-platform image
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//				Platforms: buildx.PlatformArray{
//					buildx.Platform_Plan9_amd64,
//					buildx.Platform_Plan9_386,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Registry export
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//				Exports: buildx.ExportEntryArray{
//					&buildx.ExportEntryArgs{
//						Registry: &buildx.ExportRegistryArgs{
//							OciMediaTypes: pulumi.Bool(true),
//						},
//					},
//				},
//				Registries: buildx.RegistryAuthArray{
//					&buildx.RegistryAuthArgs{
//						Address:  pulumi.String("docker.io"),
//						Password: pulumi.Any(dockerHubPassword),
//						Username: pulumi.String("pulumibot"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Caching
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				CacheFrom: buildx.CacheFromEntryArray{
//					&buildx.CacheFromEntryArgs{
//						Local: &buildx.CacheFromLocalArgs{
//							Src: pulumi.String("tmp/cache"),
//						},
//					},
//				},
//				CacheTo: buildx.CacheToEntryArray{
//					&buildx.CacheToEntryArgs{
//						Local: &buildx.CacheToLocalArgs{
//							Dest: pulumi.String("tmp/cache"),
//							Mode: buildx.CacheModeMax,
//						},
//					},
//				},
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Build arguments
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				BuildArgs: pulumi.StringMap{
//					"SET_ME_TO_TRUE": pulumi.String("true"),
//				},
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Build targets
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//				Targets: pulumi.StringArray{
//					pulumi.String("build-me"),
//					pulumi.String("also-build-me"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Named contexts
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//					Named: buildx.ContextMap{
//						"golang:latest": &buildx.ContextArgs{
//							Location: pulumi.String("docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984"),
//						},
//					},
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Remote context
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Inline Dockerfile
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Inline: pulumi.String("FROM busybox\nCOPY hello.c ./\n"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Remote context
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("https://github.com/docker-library/hello-world.git"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Local export
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := buildx.NewImage(ctx, "image", &buildx.ImageArgs{
//				Context: &buildx.BuildContextArgs{
//					Location: pulumi.String("app"),
//				},
//				Dockerfile: &buildx.DockerfileArgs{
//					Location: pulumi.String("app/Dockerfile"),
//				},
//				Exports: buildx.ExportEntryArray{
//					&buildx.ExportEntryArgs{
//						Docker: &buildx.ExportDockerArgs{
//							Tar: pulumi.Bool(true),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Image struct {
	pulumi.CustomResourceState

	// `ARG` names and values to set during the build.
	//
	// These variables are accessed like environment variables inside `RUN`
	// instructions.
	//
	// Build arguments are persisted in the image, so you should use `secrets`
	// if these arguments are sensitive.
	BuildArgs pulumi.StringMapOutput `pulumi:"buildArgs"`
	// When `true`, attempt to build the image during previews. The image will
	// not be pushed to registries, however caches will still populated.
	BuildOnPreview pulumi.BoolPtrOutput `pulumi:"buildOnPreview"`
	// Builder configuration.
	Builder BuilderConfigPtrOutput `pulumi:"builder"`
	// External cache configuration.
	CacheFrom CacheFromEntryArrayOutput `pulumi:"cacheFrom"`
	// Cache export configuration.
	CacheTo CacheToEntryArrayOutput `pulumi:"cacheTo"`
	// Build context settings.
	Context BuildContextPtrOutput `pulumi:"context"`
	// A preliminary hash of the image's build context.
	//
	// Pulumi uses this to determine if an image _may_ need to be re-built.
	ContextHash pulumi.StringPtrOutput `pulumi:"contextHash"`
	// A mapping of platform type to refs which were pushed to registries.
	Digests pulumi.StringArrayMapOutput `pulumi:"digests"`
	// Dockerfile settings.
	Dockerfile DockerfilePtrOutput `pulumi:"dockerfile"`
	// Controls where images are persisted after building.
	//
	// Images are only stored in the local cache unless `exports` are
	// explicitly configured.
	Exports ExportEntryArrayOutput `pulumi:"exports"`
	// Attach arbitrary key/value metadata to the image.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Set target platform(s) for the build. Defaults to the host's platform
	Platforms PlatformArrayOutput `pulumi:"platforms"`
	// Always pull referenced images.
	Pull pulumi.BoolPtrOutput `pulumi:"pull"`
	// Registry credentials. Required if reading or exporting to private
	// repositories.
	Registries RegistryAuthArrayOutput `pulumi:"registries"`
	// A mapping of secret names to their corresponding values.
	//
	// Unlike the Docker CLI, these can be passed by value and do not need to
	// exist on-disk or in environment variables.
	//
	// Build arguments and environment variables are persistent in the final
	// image, so you should use this for sensitive values.
	Secrets pulumi.StringMapOutput `pulumi:"secrets"`
	// Name and optionally a tag (format: `name:tag`).
	//
	// If exporting to a registry, the name should include the fully qualified
	// registry address (e.g. `docker.io/pulumi/pulumi:latest`).
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// Set the target build stage(s) to build.
	//
	// If not specified all targets will be built by default.
	Targets pulumi.StringArrayOutput `pulumi:"targets"`
}

// NewImage registers a new resource with the given unique name, arguments, and options.
func NewImage(ctx *pulumi.Context,
	name string, args *ImageArgs, opts ...pulumi.ResourceOption) (*Image, error) {
	if args == nil {
		args = &ImageArgs{}
	}

	if args.Secrets != nil {
		args.Secrets = pulumi.ToSecret(args.Secrets).(pulumi.StringMapInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"secrets",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Image
	err := ctx.RegisterResource("docker:buildx/image:Image", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetImage gets an existing Image resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetImage(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ImageState, opts ...pulumi.ResourceOption) (*Image, error) {
	var resource Image
	err := ctx.ReadResource("docker:buildx/image:Image", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Image resources.
type imageState struct {
}

type ImageState struct {
}

func (ImageState) ElementType() reflect.Type {
	return reflect.TypeOf((*imageState)(nil)).Elem()
}

type imageArgs struct {
	// `ARG` names and values to set during the build.
	//
	// These variables are accessed like environment variables inside `RUN`
	// instructions.
	//
	// Build arguments are persisted in the image, so you should use `secrets`
	// if these arguments are sensitive.
	BuildArgs map[string]string `pulumi:"buildArgs"`
	// When `true`, attempt to build the image during previews. The image will
	// not be pushed to registries, however caches will still populated.
	BuildOnPreview *bool `pulumi:"buildOnPreview"`
	// Builder configuration.
	Builder *BuilderConfig `pulumi:"builder"`
	// External cache configuration.
	CacheFrom []CacheFromEntry `pulumi:"cacheFrom"`
	// Cache export configuration.
	CacheTo []CacheToEntry `pulumi:"cacheTo"`
	// Build context settings.
	Context *BuildContext `pulumi:"context"`
	// Dockerfile settings.
	Dockerfile *Dockerfile `pulumi:"dockerfile"`
	// Controls where images are persisted after building.
	//
	// Images are only stored in the local cache unless `exports` are
	// explicitly configured.
	Exports []ExportEntry `pulumi:"exports"`
	// Attach arbitrary key/value metadata to the image.
	Labels map[string]string `pulumi:"labels"`
	// Set target platform(s) for the build. Defaults to the host's platform
	Platforms []Platform `pulumi:"platforms"`
	// Always pull referenced images.
	Pull *bool `pulumi:"pull"`
	// Registry credentials. Required if reading or exporting to private
	// repositories.
	Registries []RegistryAuth `pulumi:"registries"`
	// A mapping of secret names to their corresponding values.
	//
	// Unlike the Docker CLI, these can be passed by value and do not need to
	// exist on-disk or in environment variables.
	//
	// Build arguments and environment variables are persistent in the final
	// image, so you should use this for sensitive values.
	Secrets map[string]string `pulumi:"secrets"`
	// Name and optionally a tag (format: `name:tag`).
	//
	// If exporting to a registry, the name should include the fully qualified
	// registry address (e.g. `docker.io/pulumi/pulumi:latest`).
	Tags []string `pulumi:"tags"`
	// Set the target build stage(s) to build.
	//
	// If not specified all targets will be built by default.
	Targets []string `pulumi:"targets"`
}

// The set of arguments for constructing a Image resource.
type ImageArgs struct {
	// `ARG` names and values to set during the build.
	//
	// These variables are accessed like environment variables inside `RUN`
	// instructions.
	//
	// Build arguments are persisted in the image, so you should use `secrets`
	// if these arguments are sensitive.
	BuildArgs pulumi.StringMapInput
	// When `true`, attempt to build the image during previews. The image will
	// not be pushed to registries, however caches will still populated.
	BuildOnPreview pulumi.BoolPtrInput
	// Builder configuration.
	Builder BuilderConfigPtrInput
	// External cache configuration.
	CacheFrom CacheFromEntryArrayInput
	// Cache export configuration.
	CacheTo CacheToEntryArrayInput
	// Build context settings.
	Context BuildContextPtrInput
	// Dockerfile settings.
	Dockerfile DockerfilePtrInput
	// Controls where images are persisted after building.
	//
	// Images are only stored in the local cache unless `exports` are
	// explicitly configured.
	Exports ExportEntryArrayInput
	// Attach arbitrary key/value metadata to the image.
	Labels pulumi.StringMapInput
	// Set target platform(s) for the build. Defaults to the host's platform
	Platforms PlatformArrayInput
	// Always pull referenced images.
	Pull pulumi.BoolPtrInput
	// Registry credentials. Required if reading or exporting to private
	// repositories.
	Registries RegistryAuthArrayInput
	// A mapping of secret names to their corresponding values.
	//
	// Unlike the Docker CLI, these can be passed by value and do not need to
	// exist on-disk or in environment variables.
	//
	// Build arguments and environment variables are persistent in the final
	// image, so you should use this for sensitive values.
	Secrets pulumi.StringMapInput
	// Name and optionally a tag (format: `name:tag`).
	//
	// If exporting to a registry, the name should include the fully qualified
	// registry address (e.g. `docker.io/pulumi/pulumi:latest`).
	Tags pulumi.StringArrayInput
	// Set the target build stage(s) to build.
	//
	// If not specified all targets will be built by default.
	Targets pulumi.StringArrayInput
}

func (ImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*imageArgs)(nil)).Elem()
}

type ImageInput interface {
	pulumi.Input

	ToImageOutput() ImageOutput
	ToImageOutputWithContext(ctx context.Context) ImageOutput
}

func (*Image) ElementType() reflect.Type {
	return reflect.TypeOf((**Image)(nil)).Elem()
}

func (i *Image) ToImageOutput() ImageOutput {
	return i.ToImageOutputWithContext(context.Background())
}

func (i *Image) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageOutput)
}

// ImageArrayInput is an input type that accepts ImageArray and ImageArrayOutput values.
// You can construct a concrete instance of `ImageArrayInput` via:
//
//	ImageArray{ ImageArgs{...} }
type ImageArrayInput interface {
	pulumi.Input

	ToImageArrayOutput() ImageArrayOutput
	ToImageArrayOutputWithContext(context.Context) ImageArrayOutput
}

type ImageArray []ImageInput

func (ImageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Image)(nil)).Elem()
}

func (i ImageArray) ToImageArrayOutput() ImageArrayOutput {
	return i.ToImageArrayOutputWithContext(context.Background())
}

func (i ImageArray) ToImageArrayOutputWithContext(ctx context.Context) ImageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageArrayOutput)
}

// ImageMapInput is an input type that accepts ImageMap and ImageMapOutput values.
// You can construct a concrete instance of `ImageMapInput` via:
//
//	ImageMap{ "key": ImageArgs{...} }
type ImageMapInput interface {
	pulumi.Input

	ToImageMapOutput() ImageMapOutput
	ToImageMapOutputWithContext(context.Context) ImageMapOutput
}

type ImageMap map[string]ImageInput

func (ImageMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Image)(nil)).Elem()
}

func (i ImageMap) ToImageMapOutput() ImageMapOutput {
	return i.ToImageMapOutputWithContext(context.Background())
}

func (i ImageMap) ToImageMapOutputWithContext(ctx context.Context) ImageMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageMapOutput)
}

type ImageOutput struct{ *pulumi.OutputState }

func (ImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Image)(nil)).Elem()
}

func (o ImageOutput) ToImageOutput() ImageOutput {
	return o
}

func (o ImageOutput) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return o
}

// `ARG` names and values to set during the build.
//
// These variables are accessed like environment variables inside `RUN`
// instructions.
//
// Build arguments are persisted in the image, so you should use `secrets`
// if these arguments are sensitive.
func (o ImageOutput) BuildArgs() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Image) pulumi.StringMapOutput { return v.BuildArgs }).(pulumi.StringMapOutput)
}

// When `true`, attempt to build the image during previews. The image will
// not be pushed to registries, however caches will still populated.
func (o ImageOutput) BuildOnPreview() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Image) pulumi.BoolPtrOutput { return v.BuildOnPreview }).(pulumi.BoolPtrOutput)
}

// Builder configuration.
func (o ImageOutput) Builder() BuilderConfigPtrOutput {
	return o.ApplyT(func(v *Image) BuilderConfigPtrOutput { return v.Builder }).(BuilderConfigPtrOutput)
}

// External cache configuration.
func (o ImageOutput) CacheFrom() CacheFromEntryArrayOutput {
	return o.ApplyT(func(v *Image) CacheFromEntryArrayOutput { return v.CacheFrom }).(CacheFromEntryArrayOutput)
}

// Cache export configuration.
func (o ImageOutput) CacheTo() CacheToEntryArrayOutput {
	return o.ApplyT(func(v *Image) CacheToEntryArrayOutput { return v.CacheTo }).(CacheToEntryArrayOutput)
}

// Build context settings.
func (o ImageOutput) Context() BuildContextPtrOutput {
	return o.ApplyT(func(v *Image) BuildContextPtrOutput { return v.Context }).(BuildContextPtrOutput)
}

// A preliminary hash of the image's build context.
//
// Pulumi uses this to determine if an image _may_ need to be re-built.
func (o ImageOutput) ContextHash() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Image) pulumi.StringPtrOutput { return v.ContextHash }).(pulumi.StringPtrOutput)
}

// A mapping of platform type to refs which were pushed to registries.
func (o ImageOutput) Digests() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v *Image) pulumi.StringArrayMapOutput { return v.Digests }).(pulumi.StringArrayMapOutput)
}

// Dockerfile settings.
func (o ImageOutput) Dockerfile() DockerfilePtrOutput {
	return o.ApplyT(func(v *Image) DockerfilePtrOutput { return v.Dockerfile }).(DockerfilePtrOutput)
}

// Controls where images are persisted after building.
//
// Images are only stored in the local cache unless `exports` are
// explicitly configured.
func (o ImageOutput) Exports() ExportEntryArrayOutput {
	return o.ApplyT(func(v *Image) ExportEntryArrayOutput { return v.Exports }).(ExportEntryArrayOutput)
}

// Attach arbitrary key/value metadata to the image.
func (o ImageOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Image) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Set target platform(s) for the build. Defaults to the host's platform
func (o ImageOutput) Platforms() PlatformArrayOutput {
	return o.ApplyT(func(v *Image) PlatformArrayOutput { return v.Platforms }).(PlatformArrayOutput)
}

// Always pull referenced images.
func (o ImageOutput) Pull() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Image) pulumi.BoolPtrOutput { return v.Pull }).(pulumi.BoolPtrOutput)
}

// Registry credentials. Required if reading or exporting to private
// repositories.
func (o ImageOutput) Registries() RegistryAuthArrayOutput {
	return o.ApplyT(func(v *Image) RegistryAuthArrayOutput { return v.Registries }).(RegistryAuthArrayOutput)
}

// A mapping of secret names to their corresponding values.
//
// Unlike the Docker CLI, these can be passed by value and do not need to
// exist on-disk or in environment variables.
//
// Build arguments and environment variables are persistent in the final
// image, so you should use this for sensitive values.
func (o ImageOutput) Secrets() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Image) pulumi.StringMapOutput { return v.Secrets }).(pulumi.StringMapOutput)
}

// Name and optionally a tag (format: `name:tag`).
//
// If exporting to a registry, the name should include the fully qualified
// registry address (e.g. `docker.io/pulumi/pulumi:latest`).
func (o ImageOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Image) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// Set the target build stage(s) to build.
//
// If not specified all targets will be built by default.
func (o ImageOutput) Targets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Image) pulumi.StringArrayOutput { return v.Targets }).(pulumi.StringArrayOutput)
}

type ImageArrayOutput struct{ *pulumi.OutputState }

func (ImageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Image)(nil)).Elem()
}

func (o ImageArrayOutput) ToImageArrayOutput() ImageArrayOutput {
	return o
}

func (o ImageArrayOutput) ToImageArrayOutputWithContext(ctx context.Context) ImageArrayOutput {
	return o
}

func (o ImageArrayOutput) Index(i pulumi.IntInput) ImageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Image {
		return vs[0].([]*Image)[vs[1].(int)]
	}).(ImageOutput)
}

type ImageMapOutput struct{ *pulumi.OutputState }

func (ImageMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Image)(nil)).Elem()
}

func (o ImageMapOutput) ToImageMapOutput() ImageMapOutput {
	return o
}

func (o ImageMapOutput) ToImageMapOutputWithContext(ctx context.Context) ImageMapOutput {
	return o
}

func (o ImageMapOutput) MapIndex(k pulumi.StringInput) ImageOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Image {
		return vs[0].(map[string]*Image)[vs[1].(string)]
	}).(ImageOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ImageInput)(nil)).Elem(), &Image{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageArrayInput)(nil)).Elem(), ImageArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageMapInput)(nil)).Elem(), ImageMap{})
	pulumi.RegisterOutputType(ImageOutput{})
	pulumi.RegisterOutputType(ImageArrayOutput{})
	pulumi.RegisterOutputType(ImageMapOutput{})
}
