# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'BuildContext',
    'BuilderConfig',
    'CacheFrom',
    'CacheFromAzureBlob',
    'CacheFromGitHubActions',
    'CacheFromLocal',
    'CacheFromRegistry',
    'CacheFromS3',
    'CacheTo',
    'CacheToAzureBlob',
    'CacheToGitHubActions',
    'CacheToInline',
    'CacheToLocal',
    'CacheToRegistry',
    'CacheToS3',
    'Context',
    'Dockerfile',
    'Export',
    'ExportCacheOnly',
    'ExportDocker',
    'ExportImage',
    'ExportLocal',
    'ExportOCI',
    'ExportRegistry',
    'ExportTar',
    'RegistryAuth',
    'SSH',
]

@pulumi.output_type
class BuildContext(dict):
    def __init__(__self__, *,
                 location: str,
                 named: Optional[Mapping[str, 'outputs.Context']] = None):
        """
        :param str location: Resources to use for build context.
               
               The location can be:
               * A relative or absolute path to a local directory (`.`, `./app`,
                 `/app`, etc.).
               * A remote URL of a Git repository, tarball, or plain text file
                 (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
                 etc.).
        :param Mapping[str, 'ContextArgs'] named: Additional build contexts to use. 
               
               These contexts are accessed with `FROM name` or `--from=name`
               statements when using Dockerfile 1.4+ syntax.
               
               Values can be local paths, HTTP URLs, or  `docker-image://` images.
        """
        pulumi.set(__self__, "location", location)
        if named is not None:
            pulumi.set(__self__, "named", named)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Resources to use for build context.

        The location can be:
        * A relative or absolute path to a local directory (`.`, `./app`,
          `/app`, etc.).
        * A remote URL of a Git repository, tarball, or plain text file
          (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
          etc.).
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def named(self) -> Optional[Mapping[str, 'outputs.Context']]:
        """
        Additional build contexts to use. 

        These contexts are accessed with `FROM name` or `--from=name`
        statements when using Dockerfile 1.4+ syntax.

        Values can be local paths, HTTP URLs, or  `docker-image://` images.
        """
        return pulumi.get(self, "named")


@pulumi.output_type
class BuilderConfig(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of an existing buildx builder to use.
               
               Only `docker-container`, `kubernetes`, or `remote` drivers are
               supported. The legacy `docker` driver is not supported.
               
               Equivalent to Docker's `--builder` flag.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of an existing buildx builder to use.

        Only `docker-container`, `kubernetes`, or `remote` drivers are
        supported. The legacy `docker` driver is not supported.

        Equivalent to Docker's `--builder` flag.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CacheFrom(dict):
    def __init__(__self__, *,
                 azblob: Optional['outputs.CacheFromAzureBlob'] = None,
                 disabled: Optional[bool] = None,
                 gha: Optional['outputs.CacheFromGitHubActions'] = None,
                 local: Optional['outputs.CacheFromLocal'] = None,
                 raw: Optional[str] = None,
                 registry: Optional['outputs.CacheFromRegistry'] = None,
                 s3: Optional['outputs.CacheFromS3'] = None):
        """
        :param 'CacheFromAzureBlobArgs' azblob: Upload build caches to Azure's blob storage service.
        :param bool disabled: When `true` this entry will be excluded. Defaults to `false`.
        :param 'CacheFromGitHubActionsArgs' gha: Recommended for use with GitHub Actions workflows.
               
               An action like `crazy-max/ghaction-github-runtime` is recommended to
               expose appropriate credentials to your GitHub workflow.
        :param 'CacheFromLocalArgs' local: A simple backend which caches images on your local filesystem.
        :param str raw: A raw string as you would provide it to the Docker CLI (e.g.,
               `type=inline`).
        :param 'CacheFromRegistryArgs' registry: Upload build caches to remote registries.
        :param 'CacheFromS3Args' s3: Upload build caches to AWS S3 or an S3-compatible services such as
               MinIO.
        """
        if azblob is not None:
            pulumi.set(__self__, "azblob", azblob)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gha is not None:
            pulumi.set(__self__, "gha", gha)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if raw is not None:
            pulumi.set(__self__, "raw", raw)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def azblob(self) -> Optional['outputs.CacheFromAzureBlob']:
        """
        Upload build caches to Azure's blob storage service.
        """
        return pulumi.get(self, "azblob")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        When `true` this entry will be excluded. Defaults to `false`.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def gha(self) -> Optional['outputs.CacheFromGitHubActions']:
        """
        Recommended for use with GitHub Actions workflows.

        An action like `crazy-max/ghaction-github-runtime` is recommended to
        expose appropriate credentials to your GitHub workflow.
        """
        return pulumi.get(self, "gha")

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.CacheFromLocal']:
        """
        A simple backend which caches images on your local filesystem.
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter
    def raw(self) -> Optional[str]:
        """
        A raw string as you would provide it to the Docker CLI (e.g.,
        `type=inline`).
        """
        return pulumi.get(self, "raw")

    @property
    @pulumi.getter
    def registry(self) -> Optional['outputs.CacheFromRegistry']:
        """
        Upload build caches to remote registries.
        """
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.CacheFromS3']:
        """
        Upload build caches to AWS S3 or an S3-compatible services such as
        MinIO.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class CacheFromAzureBlob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountUrl":
            suggest = "account_url"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheFromAzureBlob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheFromAzureBlob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheFromAzureBlob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 account_url: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param str name: The name of the cache image.
        :param str account_url: Base URL of the storage account.
        :param str secret_access_key: Blob storage account key.
        """
        pulumi.set(__self__, "name", name)
        if account_url is not None:
            pulumi.set(__self__, "account_url", account_url)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cache image.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="accountUrl")
    def account_url(self) -> Optional[str]:
        """
        Base URL of the storage account.
        """
        return pulumi.get(self, "account_url")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        Blob storage account key.
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class CacheFromGitHubActions(dict):
    def __init__(__self__, *,
                 scope: Optional[str] = None,
                 token: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str scope: The scope to use for cache keys. Defaults to `buildkit`.
               
               This should be set if building and caching multiple images in one
               workflow, otherwise caches will overwrite each other.
        :param str token: The GitHub Actions token to use. This is not a personal access tokens
               and is typically generated automatically as part of each job.
               
               Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
               `crazy-max/ghaction-github-runtime` is recommended to expose this
               environment variable to your jobs.
        :param str url: The cache server URL to use for artifacts.
               
               Defaults to `$ACTIONS_RUNTIME_URL`, although a separate action like
               `crazy-max/ghaction-github-runtime` is recommended to expose this
               environment variable to your jobs.
        """
        if scope is None:
            scope = (_utilities.get_env('buildkit') or '')
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token is None:
            token = (_utilities.get_env('ACTIONS_RUNTIME_TOKEN') or '')
        if token is not None:
            pulumi.set(__self__, "token", token)
        if url is None:
            url = (_utilities.get_env('ACTIONS_RUNTIME_URL') or '')
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope to use for cache keys. Defaults to `buildkit`.

        This should be set if building and caching multiple images in one
        workflow, otherwise caches will overwrite each other.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The GitHub Actions token to use. This is not a personal access tokens
        and is typically generated automatically as part of each job.

        Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
        `crazy-max/ghaction-github-runtime` is recommended to expose this
        environment variable to your jobs.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The cache server URL to use for artifacts.

        Defaults to `$ACTIONS_RUNTIME_URL`, although a separate action like
        `crazy-max/ghaction-github-runtime` is recommended to expose this
        environment variable to your jobs.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class CacheFromLocal(dict):
    def __init__(__self__, *,
                 src: str,
                 digest: Optional[str] = None):
        """
        :param str src: Path of the local directory where cache gets imported from.
        :param str digest: Digest of manifest to import.
        """
        pulumi.set(__self__, "src", src)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)

    @property
    @pulumi.getter
    def src(self) -> str:
        """
        Path of the local directory where cache gets imported from.
        """
        return pulumi.get(self, "src")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        Digest of manifest to import.
        """
        return pulumi.get(self, "digest")


@pulumi.output_type
class CacheFromRegistry(dict):
    def __init__(__self__, *,
                 ref: str):
        """
        :param str ref: Fully qualified name of the cache image to import.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        Fully qualified name of the cache image to import.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class CacheFromS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "blobsPrefix":
            suggest = "blobs_prefix"
        elif key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "manifestsPrefix":
            suggest = "manifests_prefix"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "usePathStyle":
            suggest = "use_path_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheFromS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheFromS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheFromS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 region: Optional[str] = None,
                 access_key_id: Optional[str] = None,
                 blobs_prefix: Optional[str] = None,
                 endpoint_url: Optional[str] = None,
                 manifests_prefix: Optional[str] = None,
                 name: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 session_token: Optional[str] = None,
                 use_path_style: Optional[bool] = None):
        """
        :param str bucket: Name of the S3 bucket.
        :param str region: The geographic location of the bucket. Defaults to `$AWS_REGION`.
        :param str access_key_id: Defaults to `$AWS_ACCESS_KEY_ID`.
        :param str blobs_prefix: Prefix to prepend to blob filenames.
        :param str endpoint_url: Endpoint of the S3 bucket.
        :param str manifests_prefix: Prefix to prepend on manifest filenames.
        :param str name: Name of the cache image.
        :param str secret_access_key: Defaults to `$AWS_SECRET_ACCESS_KEY`.
        :param str session_token: Defaults to `$AWS_SESSION_TOKEN`.
        :param bool use_path_style: Uses `bucket` in the URL instead of hostname when `true`.
        """
        pulumi.set(__self__, "bucket", bucket)
        if region is None:
            region = (_utilities.get_env('AWS_REGION') or '')
        pulumi.set(__self__, "region", region)
        if access_key_id is None:
            access_key_id = (_utilities.get_env('AWS_ACCESS_KEY_ID') or '')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if blobs_prefix is not None:
            pulumi.set(__self__, "blobs_prefix", blobs_prefix)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if manifests_prefix is not None:
            pulumi.set(__self__, "manifests_prefix", manifests_prefix)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_access_key is None:
            secret_access_key = (_utilities.get_env('AWS_SECRET_ACCESS_KEY') or '')
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if session_token is None:
            session_token = (_utilities.get_env('AWS_SESSION_TOKEN') or '')
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if use_path_style is not None:
            pulumi.set(__self__, "use_path_style", use_path_style)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The geographic location of the bucket. Defaults to `$AWS_REGION`.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        Defaults to `$AWS_ACCESS_KEY_ID`.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="blobsPrefix")
    def blobs_prefix(self) -> Optional[str]:
        """
        Prefix to prepend to blob filenames.
        """
        return pulumi.get(self, "blobs_prefix")

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[str]:
        """
        Endpoint of the S3 bucket.
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="manifestsPrefix")
    def manifests_prefix(self) -> Optional[str]:
        """
        Prefix to prepend on manifest filenames.
        """
        return pulumi.get(self, "manifests_prefix")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cache image.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        Defaults to `$AWS_SECRET_ACCESS_KEY`.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[str]:
        """
        Defaults to `$AWS_SESSION_TOKEN`.
        """
        return pulumi.get(self, "session_token")

    @property
    @pulumi.getter(name="usePathStyle")
    def use_path_style(self) -> Optional[bool]:
        """
        Uses `bucket` in the URL instead of hostname when `true`.
        """
        return pulumi.get(self, "use_path_style")


@pulumi.output_type
class CacheTo(dict):
    def __init__(__self__, *,
                 azblob: Optional['outputs.CacheToAzureBlob'] = None,
                 disabled: Optional[bool] = None,
                 gha: Optional['outputs.CacheToGitHubActions'] = None,
                 inline: Optional['outputs.CacheToInline'] = None,
                 local: Optional['outputs.CacheToLocal'] = None,
                 raw: Optional[str] = None,
                 registry: Optional['outputs.CacheToRegistry'] = None,
                 s3: Optional['outputs.CacheToS3'] = None):
        """
        :param 'CacheToAzureBlobArgs' azblob: Push cache to Azure's blob storage service.
        :param bool disabled: When `true` this entry will be excluded. Defaults to `false`.
        :param 'CacheToGitHubActionsArgs' gha: Recommended for use with GitHub Actions workflows.
               
               An action like `crazy-max/ghaction-github-runtime` is recommended to
               expose appropriate credentials to your GitHub workflow.
        :param 'CacheToInlineArgs' inline: The inline cache storage backend is the simplest implementation to get
               started with, but it does not handle multi-stage builds. Consider the
               `registry` cache backend instead.
        :param 'CacheToLocalArgs' local: A simple backend which caches imagines on your local filesystem.
        :param str raw: A raw string as you would provide it to the Docker CLI (e.g.,
               `type=inline`)
        :param 'CacheToRegistryArgs' registry: Push caches to remote registries. Incompatible with the `docker` build
               driver.
        :param 'CacheToS3Args' s3: Push cache to AWS S3 or S3-compatible services such as MinIO.
        """
        if azblob is not None:
            pulumi.set(__self__, "azblob", azblob)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gha is not None:
            pulumi.set(__self__, "gha", gha)
        if inline is not None:
            pulumi.set(__self__, "inline", inline)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if raw is not None:
            pulumi.set(__self__, "raw", raw)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def azblob(self) -> Optional['outputs.CacheToAzureBlob']:
        """
        Push cache to Azure's blob storage service.
        """
        return pulumi.get(self, "azblob")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        When `true` this entry will be excluded. Defaults to `false`.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def gha(self) -> Optional['outputs.CacheToGitHubActions']:
        """
        Recommended for use with GitHub Actions workflows.

        An action like `crazy-max/ghaction-github-runtime` is recommended to
        expose appropriate credentials to your GitHub workflow.
        """
        return pulumi.get(self, "gha")

    @property
    @pulumi.getter
    def inline(self) -> Optional['outputs.CacheToInline']:
        """
        The inline cache storage backend is the simplest implementation to get
        started with, but it does not handle multi-stage builds. Consider the
        `registry` cache backend instead.
        """
        return pulumi.get(self, "inline")

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.CacheToLocal']:
        """
        A simple backend which caches imagines on your local filesystem.
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter
    def raw(self) -> Optional[str]:
        """
        A raw string as you would provide it to the Docker CLI (e.g.,
        `type=inline`)
        """
        return pulumi.get(self, "raw")

    @property
    @pulumi.getter
    def registry(self) -> Optional['outputs.CacheToRegistry']:
        """
        Push caches to remote registries. Incompatible with the `docker` build
        driver.
        """
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.CacheToS3']:
        """
        Push cache to AWS S3 or S3-compatible services such as MinIO.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class CacheToAzureBlob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountUrl":
            suggest = "account_url"
        elif key == "ignoreError":
            suggest = "ignore_error"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheToAzureBlob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheToAzureBlob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheToAzureBlob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 account_url: Optional[str] = None,
                 ignore_error: Optional[bool] = None,
                 mode: Optional['CacheMode'] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param str name: The name of the cache image.
        :param str account_url: Base URL of the storage account.
        :param bool ignore_error: Ignore errors caused by failed cache exports.
        :param 'CacheMode' mode: The cache mode to use. Defaults to `min`.
        :param str secret_access_key: Blob storage account key.
        """
        pulumi.set(__self__, "name", name)
        if account_url is not None:
            pulumi.set(__self__, "account_url", account_url)
        if ignore_error is None:
            ignore_error = False
        if ignore_error is not None:
            pulumi.set(__self__, "ignore_error", ignore_error)
        if mode is None:
            mode = 'min'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cache image.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="accountUrl")
    def account_url(self) -> Optional[str]:
        """
        Base URL of the storage account.
        """
        return pulumi.get(self, "account_url")

    @property
    @pulumi.getter(name="ignoreError")
    def ignore_error(self) -> Optional[bool]:
        """
        Ignore errors caused by failed cache exports.
        """
        return pulumi.get(self, "ignore_error")

    @property
    @pulumi.getter
    def mode(self) -> Optional['CacheMode']:
        """
        The cache mode to use. Defaults to `min`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        Blob storage account key.
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class CacheToGitHubActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreError":
            suggest = "ignore_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheToGitHubActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheToGitHubActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheToGitHubActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_error: Optional[bool] = None,
                 mode: Optional['CacheMode'] = None,
                 scope: Optional[str] = None,
                 token: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool ignore_error: Ignore errors caused by failed cache exports.
        :param 'CacheMode' mode: The cache mode to use. Defaults to `min`.
        :param str scope: The scope to use for cache keys. Defaults to `buildkit`.
               
               This should be set if building and caching multiple images in one
               workflow, otherwise caches will overwrite each other.
        :param str token: The GitHub Actions token to use. This is not a personal access tokens
               and is typically generated automatically as part of each job.
               
               Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
               `crazy-max/ghaction-github-runtime` is recommended to expose this
               environment variable to your jobs.
        :param str url: The cache server URL to use for artifacts.
               
               Defaults to `$ACTIONS_RUNTIME_URL`, although a separate action like
               `crazy-max/ghaction-github-runtime` is recommended to expose this
               environment variable to your jobs.
        """
        if ignore_error is None:
            ignore_error = False
        if ignore_error is not None:
            pulumi.set(__self__, "ignore_error", ignore_error)
        if mode is None:
            mode = 'min'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scope is None:
            scope = (_utilities.get_env('buildkit') or '')
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token is None:
            token = (_utilities.get_env('ACTIONS_RUNTIME_TOKEN') or '')
        if token is not None:
            pulumi.set(__self__, "token", token)
        if url is None:
            url = (_utilities.get_env('ACTIONS_RUNTIME_URL') or '')
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="ignoreError")
    def ignore_error(self) -> Optional[bool]:
        """
        Ignore errors caused by failed cache exports.
        """
        return pulumi.get(self, "ignore_error")

    @property
    @pulumi.getter
    def mode(self) -> Optional['CacheMode']:
        """
        The cache mode to use. Defaults to `min`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope to use for cache keys. Defaults to `buildkit`.

        This should be set if building and caching multiple images in one
        workflow, otherwise caches will overwrite each other.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The GitHub Actions token to use. This is not a personal access tokens
        and is typically generated automatically as part of each job.

        Defaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like
        `crazy-max/ghaction-github-runtime` is recommended to expose this
        environment variable to your jobs.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The cache server URL to use for artifacts.

        Defaults to `$ACTIONS_RUNTIME_URL`, although a separate action like
        `crazy-max/ghaction-github-runtime` is recommended to expose this
        environment variable to your jobs.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class CacheToInline(dict):
    """
    Include an inline cache with the exported image.
    """
    def __init__(__self__):
        """
        Include an inline cache with the exported image.
        """
        pass


@pulumi.output_type
class CacheToLocal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "forceCompression":
            suggest = "force_compression"
        elif key == "ignoreError":
            suggest = "ignore_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheToLocal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheToLocal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheToLocal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dest: str,
                 compression: Optional['CompressionType'] = None,
                 compression_level: Optional[int] = None,
                 force_compression: Optional[bool] = None,
                 ignore_error: Optional[bool] = None,
                 mode: Optional['CacheMode'] = None):
        """
        :param str dest: Path of the local directory to export the cache.
        :param 'CompressionType' compression: The compression type to use.
        :param int compression_level: Compression level from 0 to 22.
        :param bool force_compression: Forcefully apply compression.
        :param bool ignore_error: Ignore errors caused by failed cache exports.
        :param 'CacheMode' mode: The cache mode to use. Defaults to `min`.
        """
        pulumi.set(__self__, "dest", dest)
        if compression is None:
            compression = 'gzip'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if compression_level is None:
            compression_level = 0
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if force_compression is None:
            force_compression = False
        if force_compression is not None:
            pulumi.set(__self__, "force_compression", force_compression)
        if ignore_error is None:
            ignore_error = False
        if ignore_error is not None:
            pulumi.set(__self__, "ignore_error", ignore_error)
        if mode is None:
            mode = 'min'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def dest(self) -> str:
        """
        Path of the local directory to export the cache.
        """
        return pulumi.get(self, "dest")

    @property
    @pulumi.getter
    def compression(self) -> Optional['CompressionType']:
        """
        The compression type to use.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Compression level from 0 to 22.
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter(name="forceCompression")
    def force_compression(self) -> Optional[bool]:
        """
        Forcefully apply compression.
        """
        return pulumi.get(self, "force_compression")

    @property
    @pulumi.getter(name="ignoreError")
    def ignore_error(self) -> Optional[bool]:
        """
        Ignore errors caused by failed cache exports.
        """
        return pulumi.get(self, "ignore_error")

    @property
    @pulumi.getter
    def mode(self) -> Optional['CacheMode']:
        """
        The cache mode to use. Defaults to `min`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class CacheToRegistry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "forceCompression":
            suggest = "force_compression"
        elif key == "ignoreError":
            suggest = "ignore_error"
        elif key == "imageManifest":
            suggest = "image_manifest"
        elif key == "ociMediaTypes":
            suggest = "oci_media_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheToRegistry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheToRegistry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheToRegistry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ref: str,
                 compression: Optional['CompressionType'] = None,
                 compression_level: Optional[int] = None,
                 force_compression: Optional[bool] = None,
                 ignore_error: Optional[bool] = None,
                 image_manifest: Optional[bool] = None,
                 mode: Optional['CacheMode'] = None,
                 oci_media_types: Optional[bool] = None):
        """
        :param str ref: Fully qualified name of the cache image to import.
        :param 'CompressionType' compression: The compression type to use.
        :param int compression_level: Compression level from 0 to 22.
        :param bool force_compression: Forcefully apply compression.
        :param bool ignore_error: Ignore errors caused by failed cache exports.
        :param bool image_manifest: Export cache manifest as an OCI-compatible image manifest instead of a
               manifest list. Requires `ociMediaTypes` to also be `true`.
               
               Some registries like AWS ECR will not work with caching if this is
               `false`.
               
               Defaults to `false` to match Docker's default behavior.
        :param 'CacheMode' mode: The cache mode to use. Defaults to `min`.
        :param bool oci_media_types: Whether to use OCI media types in exported manifests. Defaults to
               `true`.
        """
        pulumi.set(__self__, "ref", ref)
        if compression is None:
            compression = 'gzip'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if compression_level is None:
            compression_level = 0
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if force_compression is None:
            force_compression = False
        if force_compression is not None:
            pulumi.set(__self__, "force_compression", force_compression)
        if ignore_error is None:
            ignore_error = False
        if ignore_error is not None:
            pulumi.set(__self__, "ignore_error", ignore_error)
        if image_manifest is None:
            image_manifest = False
        if image_manifest is not None:
            pulumi.set(__self__, "image_manifest", image_manifest)
        if mode is None:
            mode = 'min'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if oci_media_types is None:
            oci_media_types = True
        if oci_media_types is not None:
            pulumi.set(__self__, "oci_media_types", oci_media_types)

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        Fully qualified name of the cache image to import.
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter
    def compression(self) -> Optional['CompressionType']:
        """
        The compression type to use.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Compression level from 0 to 22.
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter(name="forceCompression")
    def force_compression(self) -> Optional[bool]:
        """
        Forcefully apply compression.
        """
        return pulumi.get(self, "force_compression")

    @property
    @pulumi.getter(name="ignoreError")
    def ignore_error(self) -> Optional[bool]:
        """
        Ignore errors caused by failed cache exports.
        """
        return pulumi.get(self, "ignore_error")

    @property
    @pulumi.getter(name="imageManifest")
    def image_manifest(self) -> Optional[bool]:
        """
        Export cache manifest as an OCI-compatible image manifest instead of a
        manifest list. Requires `ociMediaTypes` to also be `true`.

        Some registries like AWS ECR will not work with caching if this is
        `false`.

        Defaults to `false` to match Docker's default behavior.
        """
        return pulumi.get(self, "image_manifest")

    @property
    @pulumi.getter
    def mode(self) -> Optional['CacheMode']:
        """
        The cache mode to use. Defaults to `min`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="ociMediaTypes")
    def oci_media_types(self) -> Optional[bool]:
        """
        Whether to use OCI media types in exported manifests. Defaults to
        `true`.
        """
        return pulumi.get(self, "oci_media_types")


@pulumi.output_type
class CacheToS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "blobsPrefix":
            suggest = "blobs_prefix"
        elif key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "ignoreError":
            suggest = "ignore_error"
        elif key == "manifestsPrefix":
            suggest = "manifests_prefix"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "usePathStyle":
            suggest = "use_path_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheToS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheToS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheToS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 region: Optional[str] = None,
                 access_key_id: Optional[str] = None,
                 blobs_prefix: Optional[str] = None,
                 endpoint_url: Optional[str] = None,
                 ignore_error: Optional[bool] = None,
                 manifests_prefix: Optional[str] = None,
                 mode: Optional['CacheMode'] = None,
                 name: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 session_token: Optional[str] = None,
                 use_path_style: Optional[bool] = None):
        """
        :param str bucket: Name of the S3 bucket.
        :param str region: The geographic location of the bucket. Defaults to `$AWS_REGION`.
        :param str access_key_id: Defaults to `$AWS_ACCESS_KEY_ID`.
        :param str blobs_prefix: Prefix to prepend to blob filenames.
        :param str endpoint_url: Endpoint of the S3 bucket.
        :param bool ignore_error: Ignore errors caused by failed cache exports.
        :param str manifests_prefix: Prefix to prepend on manifest filenames.
        :param 'CacheMode' mode: The cache mode to use. Defaults to `min`.
        :param str name: Name of the cache image.
        :param str secret_access_key: Defaults to `$AWS_SECRET_ACCESS_KEY`.
        :param str session_token: Defaults to `$AWS_SESSION_TOKEN`.
        :param bool use_path_style: Uses `bucket` in the URL instead of hostname when `true`.
        """
        pulumi.set(__self__, "bucket", bucket)
        if region is None:
            region = (_utilities.get_env('AWS_REGION') or '')
        pulumi.set(__self__, "region", region)
        if access_key_id is None:
            access_key_id = (_utilities.get_env('AWS_ACCESS_KEY_ID') or '')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if blobs_prefix is not None:
            pulumi.set(__self__, "blobs_prefix", blobs_prefix)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if ignore_error is None:
            ignore_error = False
        if ignore_error is not None:
            pulumi.set(__self__, "ignore_error", ignore_error)
        if manifests_prefix is not None:
            pulumi.set(__self__, "manifests_prefix", manifests_prefix)
        if mode is None:
            mode = 'min'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_access_key is None:
            secret_access_key = (_utilities.get_env('AWS_SECRET_ACCESS_KEY') or '')
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if session_token is None:
            session_token = (_utilities.get_env('AWS_SESSION_TOKEN') or '')
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if use_path_style is not None:
            pulumi.set(__self__, "use_path_style", use_path_style)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The geographic location of the bucket. Defaults to `$AWS_REGION`.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        Defaults to `$AWS_ACCESS_KEY_ID`.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="blobsPrefix")
    def blobs_prefix(self) -> Optional[str]:
        """
        Prefix to prepend to blob filenames.
        """
        return pulumi.get(self, "blobs_prefix")

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[str]:
        """
        Endpoint of the S3 bucket.
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="ignoreError")
    def ignore_error(self) -> Optional[bool]:
        """
        Ignore errors caused by failed cache exports.
        """
        return pulumi.get(self, "ignore_error")

    @property
    @pulumi.getter(name="manifestsPrefix")
    def manifests_prefix(self) -> Optional[str]:
        """
        Prefix to prepend on manifest filenames.
        """
        return pulumi.get(self, "manifests_prefix")

    @property
    @pulumi.getter
    def mode(self) -> Optional['CacheMode']:
        """
        The cache mode to use. Defaults to `min`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cache image.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        Defaults to `$AWS_SECRET_ACCESS_KEY`.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[str]:
        """
        Defaults to `$AWS_SESSION_TOKEN`.
        """
        return pulumi.get(self, "session_token")

    @property
    @pulumi.getter(name="usePathStyle")
    def use_path_style(self) -> Optional[bool]:
        """
        Uses `bucket` in the URL instead of hostname when `true`.
        """
        return pulumi.get(self, "use_path_style")


@pulumi.output_type
class Context(dict):
    def __init__(__self__, *,
                 location: str):
        """
        :param str location: Resources to use for build context.
               
               The location can be:
               * A relative or absolute path to a local directory (`.`, `./app`,
                 `/app`, etc.).
               * A remote URL of a Git repository, tarball, or plain text file
                 (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
                 etc.).
        """
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Resources to use for build context.

        The location can be:
        * A relative or absolute path to a local directory (`.`, `./app`,
          `/app`, etc.).
        * A remote URL of a Git repository, tarball, or plain text file
          (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,
          etc.).
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class Dockerfile(dict):
    def __init__(__self__, *,
                 inline: Optional[str] = None,
                 location: Optional[str] = None):
        """
        :param str inline: Raw Dockerfile contents.
               
               Conflicts with `location`.
               
               Equivalent to invoking Docker with `-f -`.
        :param str location: Location of the Dockerfile to use.
               
               Can be a relative or absolute path to a local file, or a remote URL.
               
               Defaults to `${context.location}/Dockerfile` if context is on-disk.
               
               Conflicts with `inline`.
        """
        if inline is not None:
            pulumi.set(__self__, "inline", inline)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def inline(self) -> Optional[str]:
        """
        Raw Dockerfile contents.

        Conflicts with `location`.

        Equivalent to invoking Docker with `-f -`.
        """
        return pulumi.get(self, "inline")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location of the Dockerfile to use.

        Can be a relative or absolute path to a local file, or a remote URL.

        Defaults to `${context.location}/Dockerfile` if context is on-disk.

        Conflicts with `inline`.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class Export(dict):
    def __init__(__self__, *,
                 cacheonly: Optional['outputs.ExportCacheOnly'] = None,
                 disabled: Optional[bool] = None,
                 docker: Optional['outputs.ExportDocker'] = None,
                 image: Optional['outputs.ExportImage'] = None,
                 local: Optional['outputs.ExportLocal'] = None,
                 oci: Optional['outputs.ExportOCI'] = None,
                 raw: Optional[str] = None,
                 registry: Optional['outputs.ExportRegistry'] = None,
                 tar: Optional['outputs.ExportTar'] = None):
        """
        :param 'ExportCacheOnlyArgs' cacheonly: A no-op export. Helpful for silencing the 'no exports' warning if you
               just want to populate caches.
        :param bool disabled: When `true` this entry will be excluded. Defaults to `false`.
        :param 'ExportDockerArgs' docker: Export as a Docker image layout.
        :param 'ExportImageArgs' image: Outputs the build result into a container image format.
        :param 'ExportLocalArgs' local: Export to a local directory as files and directories.
        :param 'ExportOCIArgs' oci: Identical to the Docker exporter but uses OCI media types by default.
        :param str raw: A raw string as you would provide it to the Docker CLI (e.g.,
               `type=docker`)
        :param 'ExportRegistryArgs' registry: Identical to the Image exporter, but pushes by default.
        :param 'ExportTarArgs' tar: Export to a local directory as a tarball.
        """
        if cacheonly is not None:
            pulumi.set(__self__, "cacheonly", cacheonly)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if docker is not None:
            pulumi.set(__self__, "docker", docker)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if oci is not None:
            pulumi.set(__self__, "oci", oci)
        if raw is not None:
            pulumi.set(__self__, "raw", raw)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if tar is not None:
            pulumi.set(__self__, "tar", tar)

    @property
    @pulumi.getter
    def cacheonly(self) -> Optional['outputs.ExportCacheOnly']:
        """
        A no-op export. Helpful for silencing the 'no exports' warning if you
        just want to populate caches.
        """
        return pulumi.get(self, "cacheonly")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        When `true` this entry will be excluded. Defaults to `false`.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def docker(self) -> Optional['outputs.ExportDocker']:
        """
        Export as a Docker image layout.
        """
        return pulumi.get(self, "docker")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.ExportImage']:
        """
        Outputs the build result into a container image format.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.ExportLocal']:
        """
        Export to a local directory as files and directories.
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter
    def oci(self) -> Optional['outputs.ExportOCI']:
        """
        Identical to the Docker exporter but uses OCI media types by default.
        """
        return pulumi.get(self, "oci")

    @property
    @pulumi.getter
    def raw(self) -> Optional[str]:
        """
        A raw string as you would provide it to the Docker CLI (e.g.,
        `type=docker`)
        """
        return pulumi.get(self, "raw")

    @property
    @pulumi.getter
    def registry(self) -> Optional['outputs.ExportRegistry']:
        """
        Identical to the Image exporter, but pushes by default.
        """
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def tar(self) -> Optional['outputs.ExportTar']:
        """
        Export to a local directory as a tarball.
        """
        return pulumi.get(self, "tar")


@pulumi.output_type
class ExportCacheOnly(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ExportDocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "forceCompression":
            suggest = "force_compression"
        elif key == "ociMediaTypes":
            suggest = "oci_media_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportDocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportDocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportDocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 compression: Optional['CompressionType'] = None,
                 compression_level: Optional[int] = None,
                 dest: Optional[str] = None,
                 force_compression: Optional[bool] = None,
                 names: Optional[Sequence[str]] = None,
                 oci_media_types: Optional[bool] = None,
                 tar: Optional[bool] = None):
        """
        :param Mapping[str, str] annotations: Attach an arbitrary key/value annotation to the image.
        :param 'CompressionType' compression: The compression type to use.
        :param int compression_level: Compression level from 0 to 22.
        :param str dest: The local export path.
        :param bool force_compression: Forcefully apply compression.
        :param Sequence[str] names: Specify images names to export. This is overridden if tags are already specified.
        :param bool oci_media_types: Use OCI media types in exporter manifests.
        :param bool tar: Bundle the output into a tarball layout.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is None:
            compression = 'gzip'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if compression_level is None:
            compression_level = 0
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if dest is not None:
            pulumi.set(__self__, "dest", dest)
        if force_compression is None:
            force_compression = False
        if force_compression is not None:
            pulumi.set(__self__, "force_compression", force_compression)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if oci_media_types is None:
            oci_media_types = False
        if oci_media_types is not None:
            pulumi.set(__self__, "oci_media_types", oci_media_types)
        if tar is None:
            tar = True
        if tar is not None:
            pulumi.set(__self__, "tar", tar)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Attach an arbitrary key/value annotation to the image.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional['CompressionType']:
        """
        The compression type to use.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Compression level from 0 to 22.
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter
    def dest(self) -> Optional[str]:
        """
        The local export path.
        """
        return pulumi.get(self, "dest")

    @property
    @pulumi.getter(name="forceCompression")
    def force_compression(self) -> Optional[bool]:
        """
        Forcefully apply compression.
        """
        return pulumi.get(self, "force_compression")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Specify images names to export. This is overridden if tags are already specified.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="ociMediaTypes")
    def oci_media_types(self) -> Optional[bool]:
        """
        Use OCI media types in exporter manifests.
        """
        return pulumi.get(self, "oci_media_types")

    @property
    @pulumi.getter
    def tar(self) -> Optional[bool]:
        """
        Bundle the output into a tarball layout.
        """
        return pulumi.get(self, "tar")


@pulumi.output_type
class ExportImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "danglingNamePrefix":
            suggest = "dangling_name_prefix"
        elif key == "forceCompression":
            suggest = "force_compression"
        elif key == "nameCanonical":
            suggest = "name_canonical"
        elif key == "ociMediaTypes":
            suggest = "oci_media_types"
        elif key == "pushByDigest":
            suggest = "push_by_digest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 compression: Optional['CompressionType'] = None,
                 compression_level: Optional[int] = None,
                 dangling_name_prefix: Optional[str] = None,
                 force_compression: Optional[bool] = None,
                 insecure: Optional[bool] = None,
                 name_canonical: Optional[bool] = None,
                 names: Optional[Sequence[str]] = None,
                 oci_media_types: Optional[bool] = None,
                 push: Optional[bool] = None,
                 push_by_digest: Optional[bool] = None,
                 store: Optional[bool] = None,
                 unpack: Optional[bool] = None):
        """
        :param Mapping[str, str] annotations: Attach an arbitrary key/value annotation to the image.
        :param 'CompressionType' compression: The compression type to use.
        :param int compression_level: Compression level from 0 to 22.
        :param str dangling_name_prefix: Name image with `prefix@<digest>`, used for anonymous images.
        :param bool force_compression: Forcefully apply compression.
        :param bool insecure: Allow pushing to an insecure registry.
        :param bool name_canonical: Add additional canonical name (`name@<digest>`).
        :param Sequence[str] names: Specify images names to export. This is overridden if tags are already specified.
        :param bool oci_media_types: Use OCI media types in exporter manifests.
        :param bool push: Push after creating the image.
        :param bool push_by_digest: Push image without name.
        :param bool store: Store resulting images to the worker's image store and ensure all of
               its blobs are in the content store.
               
               Defaults to `true`.
               
               Ignored if the worker doesn't have image store (when using OCI workers,
               for example).
        :param bool unpack: Unpack image after creation (for use with containerd). Defaults to
               `false`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is None:
            compression = 'gzip'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if compression_level is None:
            compression_level = 0
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if dangling_name_prefix is not None:
            pulumi.set(__self__, "dangling_name_prefix", dangling_name_prefix)
        if force_compression is None:
            force_compression = False
        if force_compression is not None:
            pulumi.set(__self__, "force_compression", force_compression)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if name_canonical is not None:
            pulumi.set(__self__, "name_canonical", name_canonical)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if oci_media_types is None:
            oci_media_types = False
        if oci_media_types is not None:
            pulumi.set(__self__, "oci_media_types", oci_media_types)
        if push is not None:
            pulumi.set(__self__, "push", push)
        if push_by_digest is not None:
            pulumi.set(__self__, "push_by_digest", push_by_digest)
        if store is None:
            store = True
        if store is not None:
            pulumi.set(__self__, "store", store)
        if unpack is not None:
            pulumi.set(__self__, "unpack", unpack)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Attach an arbitrary key/value annotation to the image.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional['CompressionType']:
        """
        The compression type to use.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Compression level from 0 to 22.
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter(name="danglingNamePrefix")
    def dangling_name_prefix(self) -> Optional[str]:
        """
        Name image with `prefix@<digest>`, used for anonymous images.
        """
        return pulumi.get(self, "dangling_name_prefix")

    @property
    @pulumi.getter(name="forceCompression")
    def force_compression(self) -> Optional[bool]:
        """
        Forcefully apply compression.
        """
        return pulumi.get(self, "force_compression")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Allow pushing to an insecure registry.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="nameCanonical")
    def name_canonical(self) -> Optional[bool]:
        """
        Add additional canonical name (`name@<digest>`).
        """
        return pulumi.get(self, "name_canonical")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Specify images names to export. This is overridden if tags are already specified.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="ociMediaTypes")
    def oci_media_types(self) -> Optional[bool]:
        """
        Use OCI media types in exporter manifests.
        """
        return pulumi.get(self, "oci_media_types")

    @property
    @pulumi.getter
    def push(self) -> Optional[bool]:
        """
        Push after creating the image.
        """
        return pulumi.get(self, "push")

    @property
    @pulumi.getter(name="pushByDigest")
    def push_by_digest(self) -> Optional[bool]:
        """
        Push image without name.
        """
        return pulumi.get(self, "push_by_digest")

    @property
    @pulumi.getter
    def store(self) -> Optional[bool]:
        """
        Store resulting images to the worker's image store and ensure all of
        its blobs are in the content store.

        Defaults to `true`.

        Ignored if the worker doesn't have image store (when using OCI workers,
        for example).
        """
        return pulumi.get(self, "store")

    @property
    @pulumi.getter
    def unpack(self) -> Optional[bool]:
        """
        Unpack image after creation (for use with containerd). Defaults to
        `false`.
        """
        return pulumi.get(self, "unpack")


@pulumi.output_type
class ExportLocal(dict):
    def __init__(__self__, *,
                 dest: str):
        """
        :param str dest: Output path.
        """
        pulumi.set(__self__, "dest", dest)

    @property
    @pulumi.getter
    def dest(self) -> str:
        """
        Output path.
        """
        return pulumi.get(self, "dest")


@pulumi.output_type
class ExportOCI(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "forceCompression":
            suggest = "force_compression"
        elif key == "ociMediaTypes":
            suggest = "oci_media_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportOCI. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportOCI.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportOCI.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 compression: Optional['CompressionType'] = None,
                 compression_level: Optional[int] = None,
                 dest: Optional[str] = None,
                 force_compression: Optional[bool] = None,
                 names: Optional[Sequence[str]] = None,
                 oci_media_types: Optional[bool] = None,
                 tar: Optional[bool] = None):
        """
        :param Mapping[str, str] annotations: Attach an arbitrary key/value annotation to the image.
        :param 'CompressionType' compression: The compression type to use.
        :param int compression_level: Compression level from 0 to 22.
        :param str dest: The local export path.
        :param bool force_compression: Forcefully apply compression.
        :param Sequence[str] names: Specify images names to export. This is overridden if tags are already specified.
        :param bool oci_media_types: Use OCI media types in exporter manifests.
        :param bool tar: Bundle the output into a tarball layout.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is None:
            compression = 'gzip'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if compression_level is None:
            compression_level = 0
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if dest is not None:
            pulumi.set(__self__, "dest", dest)
        if force_compression is None:
            force_compression = False
        if force_compression is not None:
            pulumi.set(__self__, "force_compression", force_compression)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if oci_media_types is None:
            oci_media_types = True
        if oci_media_types is not None:
            pulumi.set(__self__, "oci_media_types", oci_media_types)
        if tar is None:
            tar = True
        if tar is not None:
            pulumi.set(__self__, "tar", tar)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Attach an arbitrary key/value annotation to the image.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional['CompressionType']:
        """
        The compression type to use.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Compression level from 0 to 22.
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter
    def dest(self) -> Optional[str]:
        """
        The local export path.
        """
        return pulumi.get(self, "dest")

    @property
    @pulumi.getter(name="forceCompression")
    def force_compression(self) -> Optional[bool]:
        """
        Forcefully apply compression.
        """
        return pulumi.get(self, "force_compression")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Specify images names to export. This is overridden if tags are already specified.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="ociMediaTypes")
    def oci_media_types(self) -> Optional[bool]:
        """
        Use OCI media types in exporter manifests.
        """
        return pulumi.get(self, "oci_media_types")

    @property
    @pulumi.getter
    def tar(self) -> Optional[bool]:
        """
        Bundle the output into a tarball layout.
        """
        return pulumi.get(self, "tar")


@pulumi.output_type
class ExportRegistry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "danglingNamePrefix":
            suggest = "dangling_name_prefix"
        elif key == "forceCompression":
            suggest = "force_compression"
        elif key == "nameCanonical":
            suggest = "name_canonical"
        elif key == "ociMediaTypes":
            suggest = "oci_media_types"
        elif key == "pushByDigest":
            suggest = "push_by_digest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportRegistry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportRegistry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportRegistry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 compression: Optional['CompressionType'] = None,
                 compression_level: Optional[int] = None,
                 dangling_name_prefix: Optional[str] = None,
                 force_compression: Optional[bool] = None,
                 insecure: Optional[bool] = None,
                 name_canonical: Optional[bool] = None,
                 names: Optional[Sequence[str]] = None,
                 oci_media_types: Optional[bool] = None,
                 push: Optional[bool] = None,
                 push_by_digest: Optional[bool] = None,
                 store: Optional[bool] = None,
                 unpack: Optional[bool] = None):
        """
        :param Mapping[str, str] annotations: Attach an arbitrary key/value annotation to the image.
        :param 'CompressionType' compression: The compression type to use.
        :param int compression_level: Compression level from 0 to 22.
        :param str dangling_name_prefix: Name image with `prefix@<digest>`, used for anonymous images.
        :param bool force_compression: Forcefully apply compression.
        :param bool insecure: Allow pushing to an insecure registry.
        :param bool name_canonical: Add additional canonical name (`name@<digest>`).
        :param Sequence[str] names: Specify images names to export. This is overridden if tags are already specified.
        :param bool oci_media_types: Use OCI media types in exporter manifests.
        :param bool push: Push after creating the image.
        :param bool push_by_digest: Push image without name.
        :param bool store: Store resulting images to the worker's image store and ensure all of
               its blobs are in the content store.
               
               Defaults to `true`.
               
               Ignored if the worker doesn't have image store (when using OCI workers,
               for example).
        :param bool unpack: Unpack image after creation (for use with containerd). Defaults to
               `false`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is None:
            compression = 'gzip'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if compression_level is None:
            compression_level = 0
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if dangling_name_prefix is not None:
            pulumi.set(__self__, "dangling_name_prefix", dangling_name_prefix)
        if force_compression is None:
            force_compression = False
        if force_compression is not None:
            pulumi.set(__self__, "force_compression", force_compression)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if name_canonical is not None:
            pulumi.set(__self__, "name_canonical", name_canonical)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if oci_media_types is None:
            oci_media_types = False
        if oci_media_types is not None:
            pulumi.set(__self__, "oci_media_types", oci_media_types)
        if push is None:
            push = True
        if push is not None:
            pulumi.set(__self__, "push", push)
        if push_by_digest is not None:
            pulumi.set(__self__, "push_by_digest", push_by_digest)
        if store is None:
            store = True
        if store is not None:
            pulumi.set(__self__, "store", store)
        if unpack is not None:
            pulumi.set(__self__, "unpack", unpack)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Attach an arbitrary key/value annotation to the image.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional['CompressionType']:
        """
        The compression type to use.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Compression level from 0 to 22.
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter(name="danglingNamePrefix")
    def dangling_name_prefix(self) -> Optional[str]:
        """
        Name image with `prefix@<digest>`, used for anonymous images.
        """
        return pulumi.get(self, "dangling_name_prefix")

    @property
    @pulumi.getter(name="forceCompression")
    def force_compression(self) -> Optional[bool]:
        """
        Forcefully apply compression.
        """
        return pulumi.get(self, "force_compression")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Allow pushing to an insecure registry.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="nameCanonical")
    def name_canonical(self) -> Optional[bool]:
        """
        Add additional canonical name (`name@<digest>`).
        """
        return pulumi.get(self, "name_canonical")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Specify images names to export. This is overridden if tags are already specified.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="ociMediaTypes")
    def oci_media_types(self) -> Optional[bool]:
        """
        Use OCI media types in exporter manifests.
        """
        return pulumi.get(self, "oci_media_types")

    @property
    @pulumi.getter
    def push(self) -> Optional[bool]:
        """
        Push after creating the image.
        """
        return pulumi.get(self, "push")

    @property
    @pulumi.getter(name="pushByDigest")
    def push_by_digest(self) -> Optional[bool]:
        """
        Push image without name.
        """
        return pulumi.get(self, "push_by_digest")

    @property
    @pulumi.getter
    def store(self) -> Optional[bool]:
        """
        Store resulting images to the worker's image store and ensure all of
        its blobs are in the content store.

        Defaults to `true`.

        Ignored if the worker doesn't have image store (when using OCI workers,
        for example).
        """
        return pulumi.get(self, "store")

    @property
    @pulumi.getter
    def unpack(self) -> Optional[bool]:
        """
        Unpack image after creation (for use with containerd). Defaults to
        `false`.
        """
        return pulumi.get(self, "unpack")


@pulumi.output_type
class ExportTar(dict):
    def __init__(__self__, *,
                 dest: str):
        """
        :param str dest: Output path.
        """
        pulumi.set(__self__, "dest", dest)

    @property
    @pulumi.getter
    def dest(self) -> str:
        """
        Output path.
        """
        return pulumi.get(self, "dest")


@pulumi.output_type
class RegistryAuth(dict):
    def __init__(__self__, *,
                 address: str,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str address: The registry's address (e.g. "docker.io").
        :param str password: Password or token for the registry.
        :param str username: Username for the registry.
        """
        pulumi.set(__self__, "address", address)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The registry's address (e.g. "docker.io").
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password or token for the registry.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for the registry.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SSH(dict):
    def __init__(__self__, *,
                 id: str,
                 paths: Optional[Sequence[str]] = None):
        """
        :param str id: Useful for distinguishing different servers that are part of the same
               build.
               
               A value of `default` is appropriate if only dealing with a single host.
        :param Sequence[str] paths: SSH agent socket or private keys to expose to the build under the given
               identifier.
               
               Defaults to `[$SSH_AUTH_SOCK]`.
               
               Note that your keys are **not** automatically added when using an
               agent. Run `ssh-add -l` locally to confirm which public keys are
               visible to the agent; these will be exposed to your build.
        """
        pulumi.set(__self__, "id", id)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Useful for distinguishing different servers that are part of the same
        build.

        A value of `default` is appropriate if only dealing with a single host.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[str]]:
        """
        SSH agent socket or private keys to expose to the build under the given
        identifier.

        Defaults to `[$SSH_AUTH_SOCK]`.

        Note that your keys are **not** automatically added when using an
        agent. Run `ssh-add -l` locally to confirm which public keys are
        visible to the agent; these will be exposed to your build.
        """
        return pulumi.get(self, "paths")


