# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from ._enums import *

__all__ = [
    'ContainerCapabilitiesArgs',
    'ContainerCapabilitiesArgsDict',
    'ContainerDeviceArgs',
    'ContainerDeviceArgsDict',
    'ContainerHealthcheckArgs',
    'ContainerHealthcheckArgsDict',
    'ContainerHostArgs',
    'ContainerHostArgsDict',
    'ContainerLabelArgs',
    'ContainerLabelArgsDict',
    'ContainerMountArgs',
    'ContainerMountArgsDict',
    'ContainerMountBindOptionsArgs',
    'ContainerMountBindOptionsArgsDict',
    'ContainerMountTmpfsOptionsArgs',
    'ContainerMountTmpfsOptionsArgsDict',
    'ContainerMountVolumeOptionsArgs',
    'ContainerMountVolumeOptionsArgsDict',
    'ContainerMountVolumeOptionsLabelArgs',
    'ContainerMountVolumeOptionsLabelArgsDict',
    'ContainerNetworkDataArgs',
    'ContainerNetworkDataArgsDict',
    'ContainerNetworksAdvancedArgs',
    'ContainerNetworksAdvancedArgsDict',
    'ContainerPortArgs',
    'ContainerPortArgsDict',
    'ContainerUlimitArgs',
    'ContainerUlimitArgsDict',
    'ContainerUploadArgs',
    'ContainerUploadArgsDict',
    'ContainerVolumeArgs',
    'ContainerVolumeArgsDict',
    'NetworkIpamConfigArgs',
    'NetworkIpamConfigArgsDict',
    'NetworkLabelArgs',
    'NetworkLabelArgsDict',
    'PluginGrantPermissionArgs',
    'PluginGrantPermissionArgsDict',
    'ProviderRegistryAuthArgs',
    'ProviderRegistryAuthArgsDict',
    'RemoteImageBuildArgs',
    'RemoteImageBuildArgsDict',
    'RemoteImageBuildAuthConfigArgs',
    'RemoteImageBuildAuthConfigArgsDict',
    'RemoteImageBuildUlimitArgs',
    'RemoteImageBuildUlimitArgsDict',
    'SecretLabelArgs',
    'SecretLabelArgsDict',
    'ServiceAuthArgs',
    'ServiceAuthArgsDict',
    'ServiceConvergeConfigArgs',
    'ServiceConvergeConfigArgsDict',
    'ServiceEndpointSpecArgs',
    'ServiceEndpointSpecArgsDict',
    'ServiceEndpointSpecPortArgs',
    'ServiceEndpointSpecPortArgsDict',
    'ServiceLabelArgs',
    'ServiceLabelArgsDict',
    'ServiceModeArgs',
    'ServiceModeArgsDict',
    'ServiceModeReplicatedArgs',
    'ServiceModeReplicatedArgsDict',
    'ServiceRollbackConfigArgs',
    'ServiceRollbackConfigArgsDict',
    'ServiceTaskSpecArgs',
    'ServiceTaskSpecArgsDict',
    'ServiceTaskSpecContainerSpecArgs',
    'ServiceTaskSpecContainerSpecArgsDict',
    'ServiceTaskSpecContainerSpecConfigArgs',
    'ServiceTaskSpecContainerSpecConfigArgsDict',
    'ServiceTaskSpecContainerSpecDnsConfigArgs',
    'ServiceTaskSpecContainerSpecDnsConfigArgsDict',
    'ServiceTaskSpecContainerSpecHealthcheckArgs',
    'ServiceTaskSpecContainerSpecHealthcheckArgsDict',
    'ServiceTaskSpecContainerSpecHostArgs',
    'ServiceTaskSpecContainerSpecHostArgsDict',
    'ServiceTaskSpecContainerSpecLabelArgs',
    'ServiceTaskSpecContainerSpecLabelArgsDict',
    'ServiceTaskSpecContainerSpecMountArgs',
    'ServiceTaskSpecContainerSpecMountArgsDict',
    'ServiceTaskSpecContainerSpecMountBindOptionsArgs',
    'ServiceTaskSpecContainerSpecMountBindOptionsArgsDict',
    'ServiceTaskSpecContainerSpecMountTmpfsOptionsArgs',
    'ServiceTaskSpecContainerSpecMountTmpfsOptionsArgsDict',
    'ServiceTaskSpecContainerSpecMountVolumeOptionsArgs',
    'ServiceTaskSpecContainerSpecMountVolumeOptionsArgsDict',
    'ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgs',
    'ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgsDict',
    'ServiceTaskSpecContainerSpecPrivilegesArgs',
    'ServiceTaskSpecContainerSpecPrivilegesArgsDict',
    'ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgs',
    'ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgsDict',
    'ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgs',
    'ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgsDict',
    'ServiceTaskSpecContainerSpecSecretArgs',
    'ServiceTaskSpecContainerSpecSecretArgsDict',
    'ServiceTaskSpecLogDriverArgs',
    'ServiceTaskSpecLogDriverArgsDict',
    'ServiceTaskSpecNetworksAdvancedArgs',
    'ServiceTaskSpecNetworksAdvancedArgsDict',
    'ServiceTaskSpecPlacementArgs',
    'ServiceTaskSpecPlacementArgsDict',
    'ServiceTaskSpecPlacementPlatformArgs',
    'ServiceTaskSpecPlacementPlatformArgsDict',
    'ServiceTaskSpecResourcesArgs',
    'ServiceTaskSpecResourcesArgsDict',
    'ServiceTaskSpecResourcesLimitsArgs',
    'ServiceTaskSpecResourcesLimitsArgsDict',
    'ServiceTaskSpecResourcesReservationArgs',
    'ServiceTaskSpecResourcesReservationArgsDict',
    'ServiceTaskSpecResourcesReservationGenericResourcesArgs',
    'ServiceTaskSpecResourcesReservationGenericResourcesArgsDict',
    'ServiceTaskSpecRestartPolicyArgs',
    'ServiceTaskSpecRestartPolicyArgsDict',
    'ServiceUpdateConfigArgs',
    'ServiceUpdateConfigArgsDict',
    'VolumeLabelArgs',
    'VolumeLabelArgsDict',
    'CacheFromArgs',
    'CacheFromArgsDict',
    'DockerBuildArgs',
    'DockerBuildArgsDict',
    'RegistryArgs',
    'RegistryArgsDict',
]

MYPY = False

if not MYPY:
    class ContainerCapabilitiesArgsDict(TypedDict):
        adds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of linux capabilities to add.
        """
        drops: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of linux capabilities to drop.
        """
elif False:
    ContainerCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerCapabilitiesArgs:
    def __init__(__self__, *,
                 adds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drops: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] adds: List of linux capabilities to add.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] drops: List of linux capabilities to drop.
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of linux capabilities to add.
        """
        return pulumi.get(self, "adds")

    @adds.setter
    def adds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "adds", value)

    @property
    @pulumi.getter
    def drops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of linux capabilities to drop.
        """
        return pulumi.get(self, "drops")

    @drops.setter
    def drops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drops", value)


if not MYPY:
    class ContainerDeviceArgsDict(TypedDict):
        host_path: pulumi.Input[str]
        """
        The path on the host where the device is located.
        """
        container_path: NotRequired[pulumi.Input[str]]
        """
        The path in the container where the device will be bound.
        """
        permissions: NotRequired[pulumi.Input[str]]
        """
        The cgroup permissions given to the container to access the device. Defaults to `rwm`.
        """
elif False:
    ContainerDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerDeviceArgs:
    def __init__(__self__, *,
                 host_path: pulumi.Input[str],
                 container_path: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_path: The path on the host where the device is located.
        :param pulumi.Input[str] container_path: The path in the container where the device will be bound.
        :param pulumi.Input[str] permissions: The cgroup permissions given to the container to access the device. Defaults to `rwm`.
        """
        pulumi.set(__self__, "host_path", host_path)
        if container_path is not None:
            pulumi.set(__self__, "container_path", container_path)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> pulumi.Input[str]:
        """
        The path on the host where the device is located.
        """
        return pulumi.get(self, "host_path")

    @host_path.setter
    def host_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_path", value)

    @property
    @pulumi.getter(name="containerPath")
    def container_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path in the container where the device will be bound.
        """
        return pulumi.get(self, "container_path")

    @container_path.setter
    def container_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_path", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[str]]:
        """
        The cgroup permissions given to the container to access the device. Defaults to `rwm`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class ContainerHealthcheckArgsDict(TypedDict):
        tests: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Command to run to check health. For example, to run `curl -f localhost/health` set the command to be `["CMD", "curl", "-f", "localhost/health"]`.
        """
        interval: NotRequired[pulumi.Input[str]]
        """
        Time between running the check (ms|s|m|h). Defaults to `0s`.
        """
        retries: NotRequired[pulumi.Input[int]]
        """
        Consecutive failures needed to report unhealthy. Defaults to `0`.
        """
        start_period: NotRequired[pulumi.Input[str]]
        """
        Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.
        """
        timeout: NotRequired[pulumi.Input[str]]
        """
        Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.
        """
elif False:
    ContainerHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerHealthcheckArgs:
    def __init__(__self__, *,
                 tests: pulumi.Input[Sequence[pulumi.Input[str]]],
                 interval: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 start_period: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tests: Command to run to check health. For example, to run `curl -f localhost/health` set the command to be `["CMD", "curl", "-f", "localhost/health"]`.
        :param pulumi.Input[str] interval: Time between running the check (ms|s|m|h). Defaults to `0s`.
        :param pulumi.Input[int] retries: Consecutive failures needed to report unhealthy. Defaults to `0`.
        :param pulumi.Input[str] start_period: Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.
        :param pulumi.Input[str] timeout: Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.
        """
        pulumi.set(__self__, "tests", tests)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if start_period is not None:
            pulumi.set(__self__, "start_period", start_period)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def tests(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Command to run to check health. For example, to run `curl -f localhost/health` set the command to be `["CMD", "curl", "-f", "localhost/health"]`.
        """
        return pulumi.get(self, "tests")

    @tests.setter
    def tests(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "tests", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time between running the check (ms|s|m|h). Defaults to `0s`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        Consecutive failures needed to report unhealthy. Defaults to `0`.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="startPeriod")
    def start_period(self) -> Optional[pulumi.Input[str]]:
        """
        Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.
        """
        return pulumi.get(self, "start_period")

    @start_period.setter
    def start_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_period", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ContainerHostArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        Hostname to add
        """
        ip: pulumi.Input[str]
        """
        IP address this hostname should resolve to.
        """
elif False:
    ContainerHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerHostArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] host: Hostname to add
        :param pulumi.Input[str] ip: IP address this hostname should resolve to.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname to add
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IP address this hostname should resolve to.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ContainerLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    ContainerLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ContainerMountArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        Container path
        """
        type: pulumi.Input[str]
        """
        The mount type
        """
        bind_options: NotRequired[pulumi.Input['ContainerMountBindOptionsArgsDict']]
        """
        Optional configuration for the bind type.
        """
        read_only: NotRequired[pulumi.Input[bool]]
        """
        Whether the mount should be read-only.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Mount source (e.g. a volume name, a host path).
        """
        tmpfs_options: NotRequired[pulumi.Input['ContainerMountTmpfsOptionsArgsDict']]
        """
        Optional configuration for the tmpfs type.
        """
        volume_options: NotRequired[pulumi.Input['ContainerMountVolumeOptionsArgsDict']]
        """
        Optional configuration for the volume type.
        """
elif False:
    ContainerMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerMountArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 type: pulumi.Input[str],
                 bind_options: Optional[pulumi.Input['ContainerMountBindOptionsArgs']] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 tmpfs_options: Optional[pulumi.Input['ContainerMountTmpfsOptionsArgs']] = None,
                 volume_options: Optional[pulumi.Input['ContainerMountVolumeOptionsArgs']] = None):
        """
        :param pulumi.Input[str] target: Container path
        :param pulumi.Input[str] type: The mount type
        :param pulumi.Input['ContainerMountBindOptionsArgs'] bind_options: Optional configuration for the bind type.
        :param pulumi.Input[bool] read_only: Whether the mount should be read-only.
        :param pulumi.Input[str] source: Mount source (e.g. a volume name, a host path).
        :param pulumi.Input['ContainerMountTmpfsOptionsArgs'] tmpfs_options: Optional configuration for the tmpfs type.
        :param pulumi.Input['ContainerMountVolumeOptionsArgs'] volume_options: Optional configuration for the volume type.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if bind_options is not None:
            pulumi.set(__self__, "bind_options", bind_options)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tmpfs_options is not None:
            pulumi.set(__self__, "tmpfs_options", tmpfs_options)
        if volume_options is not None:
            pulumi.set(__self__, "volume_options", volume_options)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Container path
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The mount type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bindOptions")
    def bind_options(self) -> Optional[pulumi.Input['ContainerMountBindOptionsArgs']]:
        """
        Optional configuration for the bind type.
        """
        return pulumi.get(self, "bind_options")

    @bind_options.setter
    def bind_options(self, value: Optional[pulumi.Input['ContainerMountBindOptionsArgs']]):
        pulumi.set(self, "bind_options", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the mount should be read-only.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Mount source (e.g. a volume name, a host path).
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="tmpfsOptions")
    def tmpfs_options(self) -> Optional[pulumi.Input['ContainerMountTmpfsOptionsArgs']]:
        """
        Optional configuration for the tmpfs type.
        """
        return pulumi.get(self, "tmpfs_options")

    @tmpfs_options.setter
    def tmpfs_options(self, value: Optional[pulumi.Input['ContainerMountTmpfsOptionsArgs']]):
        pulumi.set(self, "tmpfs_options", value)

    @property
    @pulumi.getter(name="volumeOptions")
    def volume_options(self) -> Optional[pulumi.Input['ContainerMountVolumeOptionsArgs']]:
        """
        Optional configuration for the volume type.
        """
        return pulumi.get(self, "volume_options")

    @volume_options.setter
    def volume_options(self, value: Optional[pulumi.Input['ContainerMountVolumeOptionsArgs']]):
        pulumi.set(self, "volume_options", value)


if not MYPY:
    class ContainerMountBindOptionsArgsDict(TypedDict):
        propagation: NotRequired[pulumi.Input[str]]
        """
        A propagation mode with the value.
        """
elif False:
    ContainerMountBindOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerMountBindOptionsArgs:
    def __init__(__self__, *,
                 propagation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] propagation: A propagation mode with the value.
        """
        if propagation is not None:
            pulumi.set(__self__, "propagation", propagation)

    @property
    @pulumi.getter
    def propagation(self) -> Optional[pulumi.Input[str]]:
        """
        A propagation mode with the value.
        """
        return pulumi.get(self, "propagation")

    @propagation.setter
    def propagation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "propagation", value)


if not MYPY:
    class ContainerMountTmpfsOptionsArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[int]]
        """
        The permission mode for the tmpfs mount in an integer.
        """
        size_bytes: NotRequired[pulumi.Input[int]]
        """
        The size for the tmpfs mount in bytes.
        """
elif False:
    ContainerMountTmpfsOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerMountTmpfsOptionsArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[int]] = None,
                 size_bytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] mode: The permission mode for the tmpfs mount in an integer.
        :param pulumi.Input[int] size_bytes: The size for the tmpfs mount in bytes.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        """
        The permission mode for the tmpfs mount in an integer.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The size for the tmpfs mount in bytes.
        """
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_bytes", value)


if not MYPY:
    class ContainerMountVolumeOptionsArgsDict(TypedDict):
        driver_name: NotRequired[pulumi.Input[str]]
        """
        Name of the driver to use to create the volume.
        """
        driver_options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        key/value map of driver specific options.
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerMountVolumeOptionsLabelArgsDict']]]]
        """
        User-defined key/value metadata.
        """
        no_copy: NotRequired[pulumi.Input[bool]]
        """
        Populate volume with data from the target.
        """
elif False:
    ContainerMountVolumeOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerMountVolumeOptionsArgs:
    def __init__(__self__, *,
                 driver_name: Optional[pulumi.Input[str]] = None,
                 driver_options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerMountVolumeOptionsLabelArgs']]]] = None,
                 no_copy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] driver_name: Name of the driver to use to create the volume.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] driver_options: key/value map of driver specific options.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerMountVolumeOptionsLabelArgs']]] labels: User-defined key/value metadata.
        :param pulumi.Input[bool] no_copy: Populate volume with data from the target.
        """
        if driver_name is not None:
            pulumi.set(__self__, "driver_name", driver_name)
        if driver_options is not None:
            pulumi.set(__self__, "driver_options", driver_options)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if no_copy is not None:
            pulumi.set(__self__, "no_copy", no_copy)

    @property
    @pulumi.getter(name="driverName")
    def driver_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the driver to use to create the volume.
        """
        return pulumi.get(self, "driver_name")

    @driver_name.setter
    def driver_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_name", value)

    @property
    @pulumi.getter(name="driverOptions")
    def driver_options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        key/value map of driver specific options.
        """
        return pulumi.get(self, "driver_options")

    @driver_options.setter
    def driver_options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "driver_options", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerMountVolumeOptionsLabelArgs']]]]:
        """
        User-defined key/value metadata.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerMountVolumeOptionsLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="noCopy")
    def no_copy(self) -> Optional[pulumi.Input[bool]]:
        """
        Populate volume with data from the target.
        """
        return pulumi.get(self, "no_copy")

    @no_copy.setter
    def no_copy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_copy", value)


if not MYPY:
    class ContainerMountVolumeOptionsLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    ContainerMountVolumeOptionsLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerMountVolumeOptionsLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ContainerNetworkDataArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[str]]
        """
        The network gateway of the container.
        """
        global_ipv6_address: NotRequired[pulumi.Input[str]]
        """
        The IPV6 address of the container.
        """
        global_ipv6_prefix_length: NotRequired[pulumi.Input[int]]
        """
        The IPV6 prefix length address of the container.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP address of the container.
        """
        ip_prefix_length: NotRequired[pulumi.Input[int]]
        """
        The IP prefix length of the container.
        """
        ipv6_gateway: NotRequired[pulumi.Input[str]]
        """
        The IPV6 gateway of the container.
        """
        mac_address: NotRequired[pulumi.Input[str]]
        """
        The MAC address of the container.
        """
        network_name: NotRequired[pulumi.Input[str]]
        """
        The name of the network
        """
elif False:
    ContainerNetworkDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerNetworkDataArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 global_ipv6_address: Optional[pulumi.Input[str]] = None,
                 global_ipv6_prefix_length: Optional[pulumi.Input[int]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 ip_prefix_length: Optional[pulumi.Input[int]] = None,
                 ipv6_gateway: Optional[pulumi.Input[str]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 network_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway: The network gateway of the container.
        :param pulumi.Input[str] global_ipv6_address: The IPV6 address of the container.
        :param pulumi.Input[int] global_ipv6_prefix_length: The IPV6 prefix length address of the container.
        :param pulumi.Input[str] ip_address: The IP address of the container.
        :param pulumi.Input[int] ip_prefix_length: The IP prefix length of the container.
        :param pulumi.Input[str] ipv6_gateway: The IPV6 gateway of the container.
        :param pulumi.Input[str] mac_address: The MAC address of the container.
        :param pulumi.Input[str] network_name: The name of the network
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if global_ipv6_address is not None:
            pulumi.set(__self__, "global_ipv6_address", global_ipv6_address)
        if global_ipv6_prefix_length is not None:
            pulumi.set(__self__, "global_ipv6_prefix_length", global_ipv6_prefix_length)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_prefix_length is not None:
            pulumi.set(__self__, "ip_prefix_length", ip_prefix_length)
        if ipv6_gateway is not None:
            pulumi.set(__self__, "ipv6_gateway", ipv6_gateway)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The network gateway of the container.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="globalIpv6Address")
    def global_ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPV6 address of the container.
        """
        return pulumi.get(self, "global_ipv6_address")

    @global_ipv6_address.setter
    def global_ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "global_ipv6_address", value)

    @property
    @pulumi.getter(name="globalIpv6PrefixLength")
    def global_ipv6_prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The IPV6 prefix length address of the container.
        """
        return pulumi.get(self, "global_ipv6_prefix_length")

    @global_ipv6_prefix_length.setter
    def global_ipv6_prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "global_ipv6_prefix_length", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of the container.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipPrefixLength")
    def ip_prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The IP prefix length of the container.
        """
        return pulumi.get(self, "ip_prefix_length")

    @ip_prefix_length.setter
    def ip_prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ip_prefix_length", value)

    @property
    @pulumi.getter(name="ipv6Gateway")
    def ipv6_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The IPV6 gateway of the container.
        """
        return pulumi.get(self, "ipv6_gateway")

    @ipv6_gateway.setter
    def ipv6_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_gateway", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        The MAC address of the container.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the network
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_name", value)


if not MYPY:
    class ContainerNetworksAdvancedArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name or id of the network to use. You can use `name` or `id` attribute from a `Network` resource.
        """
        aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The network aliases of the container in the specific network.
        """
        ipv4_address: NotRequired[pulumi.Input[str]]
        """
        The IPV4 address of the container in the specific network.
        """
        ipv6_address: NotRequired[pulumi.Input[str]]
        """
        The IPV6 address of the container in the specific network.
        """
elif False:
    ContainerNetworksAdvancedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerNetworksAdvancedArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name or id of the network to use. You can use `name` or `id` attribute from a `Network` resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aliases: The network aliases of the container in the specific network.
        :param pulumi.Input[str] ipv4_address: The IPV4 address of the container in the specific network.
        :param pulumi.Input[str] ipv6_address: The IPV6 address of the container in the specific network.
        """
        pulumi.set(__self__, "name", name)
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name or id of the network to use. You can use `name` or `id` attribute from a `Network` resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The network aliases of the container in the specific network.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPV4 address of the container in the specific network.
        """
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPV6 address of the container in the specific network.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)


if not MYPY:
    class ContainerPortArgsDict(TypedDict):
        internal: pulumi.Input[int]
        """
        Port within the container.
        """
        external: NotRequired[pulumi.Input[int]]
        """
        Port exposed out of the container. If not given a free random port `>= 32768` will be used.
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        IP address/mask that can access this port. Defaults to `0.0.0.0`.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol that can be used over this port. Defaults to `tcp`.
        """
elif False:
    ContainerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerPortArgs:
    def __init__(__self__, *,
                 internal: pulumi.Input[int],
                 external: Optional[pulumi.Input[int]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] internal: Port within the container.
        :param pulumi.Input[int] external: Port exposed out of the container. If not given a free random port `>= 32768` will be used.
        :param pulumi.Input[str] ip: IP address/mask that can access this port. Defaults to `0.0.0.0`.
        :param pulumi.Input[str] protocol: Protocol that can be used over this port. Defaults to `tcp`.
        """
        pulumi.set(__self__, "internal", internal)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def internal(self) -> pulumi.Input[int]:
        """
        Port within the container.
        """
        return pulumi.get(self, "internal")

    @internal.setter
    def internal(self, value: pulumi.Input[int]):
        pulumi.set(self, "internal", value)

    @property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input[int]]:
        """
        Port exposed out of the container. If not given a free random port `>= 32768` will be used.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "external", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address/mask that can access this port. Defaults to `0.0.0.0`.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol that can be used over this port. Defaults to `tcp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ContainerUlimitArgsDict(TypedDict):
        hard: pulumi.Input[int]
        """
        The hard limit
        """
        name: pulumi.Input[str]
        """
        The name of the ulimit
        """
        soft: pulumi.Input[int]
        """
        The soft limit
        """
elif False:
    ContainerUlimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerUlimitArgs:
    def __init__(__self__, *,
                 hard: pulumi.Input[int],
                 name: pulumi.Input[str],
                 soft: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hard: The hard limit
        :param pulumi.Input[str] name: The name of the ulimit
        :param pulumi.Input[int] soft: The soft limit
        """
        pulumi.set(__self__, "hard", hard)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "soft", soft)

    @property
    @pulumi.getter
    def hard(self) -> pulumi.Input[int]:
        """
        The hard limit
        """
        return pulumi.get(self, "hard")

    @hard.setter
    def hard(self, value: pulumi.Input[int]):
        pulumi.set(self, "hard", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the ulimit
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def soft(self) -> pulumi.Input[int]:
        """
        The soft limit
        """
        return pulumi.get(self, "soft")

    @soft.setter
    def soft(self, value: pulumi.Input[int]):
        pulumi.set(self, "soft", value)


if not MYPY:
    class ContainerUploadArgsDict(TypedDict):
        file: pulumi.Input[str]
        """
        Path to the file in the container where is upload goes to
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text. Conflicts with `content_base64` & `source`
        """
        content_base64: NotRequired[pulumi.Input[str]]
        """
        Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for larger binary content such as the result of the `base64encode` interpolation function. See here for the reason. Conflicts with `content` & `source`
        """
        executable: NotRequired[pulumi.Input[bool]]
        """
        If `true`, the file will be uploaded with user executable permission. Defaults to `false`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        A filename that references a file which will be uploaded as the object content. This allows for large file uploads that do not get stored in state. Conflicts with `content` & `content_base64`
        """
        source_hash: NotRequired[pulumi.Input[str]]
        """
        If using `source`, this will force an update if the file content has updated but the filename has not.
        """
elif False:
    ContainerUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerUploadArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None,
                 content_base64: Optional[pulumi.Input[str]] = None,
                 executable: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 source_hash: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file: Path to the file in the container where is upload goes to
        :param pulumi.Input[str] content: Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text. Conflicts with `content_base64` & `source`
        :param pulumi.Input[str] content_base64: Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for larger binary content such as the result of the `base64encode` interpolation function. See here for the reason. Conflicts with `content` & `source`
        :param pulumi.Input[bool] executable: If `true`, the file will be uploaded with user executable permission. Defaults to `false`.
        :param pulumi.Input[str] source: A filename that references a file which will be uploaded as the object content. This allows for large file uploads that do not get stored in state. Conflicts with `content` & `content_base64`
        :param pulumi.Input[str] source_hash: If using `source`, this will force an update if the file content has updated but the filename has not.
        """
        pulumi.set(__self__, "file", file)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_base64 is not None:
            pulumi.set(__self__, "content_base64", content_base64)
        if executable is not None:
            pulumi.set(__self__, "executable", executable)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_hash is not None:
            pulumi.set(__self__, "source_hash", source_hash)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        """
        Path to the file in the container where is upload goes to
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text. Conflicts with `content_base64` & `source`
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentBase64")
    def content_base64(self) -> Optional[pulumi.Input[str]]:
        """
        Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for larger binary content such as the result of the `base64encode` interpolation function. See here for the reason. Conflicts with `content` & `source`
        """
        return pulumi.get(self, "content_base64")

    @content_base64.setter
    def content_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_base64", value)

    @property
    @pulumi.getter
    def executable(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the file will be uploaded with user executable permission. Defaults to `false`.
        """
        return pulumi.get(self, "executable")

    @executable.setter
    def executable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "executable", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        A filename that references a file which will be uploaded as the object content. This allows for large file uploads that do not get stored in state. Conflicts with `content` & `content_base64`
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourceHash")
    def source_hash(self) -> Optional[pulumi.Input[str]]:
        """
        If using `source`, this will force an update if the file content has updated but the filename has not.
        """
        return pulumi.get(self, "source_hash")

    @source_hash.setter
    def source_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_hash", value)


if not MYPY:
    class ContainerVolumeArgsDict(TypedDict):
        container_path: NotRequired[pulumi.Input[str]]
        """
        The path in the container where the volume will be mounted.
        """
        from_container: NotRequired[pulumi.Input[str]]
        """
        The container where the volume is coming from.
        """
        host_path: NotRequired[pulumi.Input[str]]
        """
        The path on the host where the volume is coming from.
        """
        read_only: NotRequired[pulumi.Input[bool]]
        """
        If `true`, this volume will be readonly. Defaults to `false`.
        """
        volume_name: NotRequired[pulumi.Input[str]]
        """
        The name of the docker volume which should be mounted.
        """
elif False:
    ContainerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerVolumeArgs:
    def __init__(__self__, *,
                 container_path: Optional[pulumi.Input[str]] = None,
                 from_container: Optional[pulumi.Input[str]] = None,
                 host_path: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 volume_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container_path: The path in the container where the volume will be mounted.
        :param pulumi.Input[str] from_container: The container where the volume is coming from.
        :param pulumi.Input[str] host_path: The path on the host where the volume is coming from.
        :param pulumi.Input[bool] read_only: If `true`, this volume will be readonly. Defaults to `false`.
        :param pulumi.Input[str] volume_name: The name of the docker volume which should be mounted.
        """
        if container_path is not None:
            pulumi.set(__self__, "container_path", container_path)
        if from_container is not None:
            pulumi.set(__self__, "from_container", from_container)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="containerPath")
    def container_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path in the container where the volume will be mounted.
        """
        return pulumi.get(self, "container_path")

    @container_path.setter
    def container_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_path", value)

    @property
    @pulumi.getter(name="fromContainer")
    def from_container(self) -> Optional[pulumi.Input[str]]:
        """
        The container where the volume is coming from.
        """
        return pulumi.get(self, "from_container")

    @from_container.setter
    def from_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_container", value)

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path on the host where the volume is coming from.
        """
        return pulumi.get(self, "host_path")

    @host_path.setter
    def host_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_path", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, this volume will be readonly. Defaults to `false`.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the docker volume which should be mounted.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_name", value)


if not MYPY:
    class NetworkIpamConfigArgsDict(TypedDict):
        aux_address: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Auxiliary IPv4 or IPv6 addresses used by Network driver
        """
        gateway: NotRequired[pulumi.Input[str]]
        """
        The IP address of the gateway
        """
        ip_range: NotRequired[pulumi.Input[str]]
        """
        The ip range in CIDR form
        """
        subnet: NotRequired[pulumi.Input[str]]
        """
        The subnet in CIDR form
        """
elif False:
    NetworkIpamConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIpamConfigArgs:
    def __init__(__self__, *,
                 aux_address: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip_range: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] aux_address: Auxiliary IPv4 or IPv6 addresses used by Network driver
        :param pulumi.Input[str] gateway: The IP address of the gateway
        :param pulumi.Input[str] ip_range: The ip range in CIDR form
        :param pulumi.Input[str] subnet: The subnet in CIDR form
        """
        if aux_address is not None:
            pulumi.set(__self__, "aux_address", aux_address)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip_range is not None:
            pulumi.set(__self__, "ip_range", ip_range)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="auxAddress")
    def aux_address(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Auxiliary IPv4 or IPv6 addresses used by Network driver
        """
        return pulumi.get(self, "aux_address")

    @aux_address.setter
    def aux_address(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "aux_address", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of the gateway
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ip range in CIDR form
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_range", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet in CIDR form
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class NetworkLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    NetworkLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PluginGrantPermissionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the permission
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The value of the permission
        """
elif False:
    PluginGrantPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginGrantPermissionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name of the permission
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The value of the permission
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the permission
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The value of the permission
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProviderRegistryAuthArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        Address of the registry
        """
        auth_disabled: NotRequired[pulumi.Input[bool]]
        config_file: NotRequired[pulumi.Input[str]]
        """
        Path to docker json file for registry auth. Defaults to `~/.docker/config.json`. If `DOCKER_CONFIG` is set, the value of `DOCKER_CONFIG` is used as the path. `config_file` has predencen over all other options.
        """
        config_file_content: NotRequired[pulumi.Input[str]]
        """
        Plain content of the docker json file for registry auth. `config_file_content` has precedence over username/password.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password for the registry. Defaults to `DOCKER_REGISTRY_PASS` env variable if set.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username for the registry. Defaults to `DOCKER_REGISTRY_USER` env variable if set.
        """
elif False:
    ProviderRegistryAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderRegistryAuthArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 auth_disabled: Optional[pulumi.Input[bool]] = None,
                 config_file: Optional[pulumi.Input[str]] = None,
                 config_file_content: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Address of the registry
        :param pulumi.Input[str] config_file: Path to docker json file for registry auth. Defaults to `~/.docker/config.json`. If `DOCKER_CONFIG` is set, the value of `DOCKER_CONFIG` is used as the path. `config_file` has predencen over all other options.
        :param pulumi.Input[str] config_file_content: Plain content of the docker json file for registry auth. `config_file_content` has precedence over username/password.
        :param pulumi.Input[str] password: Password for the registry. Defaults to `DOCKER_REGISTRY_PASS` env variable if set.
        :param pulumi.Input[str] username: Username for the registry. Defaults to `DOCKER_REGISTRY_USER` env variable if set.
        """
        pulumi.set(__self__, "address", address)
        if auth_disabled is not None:
            pulumi.set(__self__, "auth_disabled", auth_disabled)
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if config_file_content is not None:
            pulumi.set(__self__, "config_file_content", config_file_content)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Address of the registry
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="authDisabled")
    def auth_disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auth_disabled")

    @auth_disabled.setter
    def auth_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_disabled", value)

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to docker json file for registry auth. Defaults to `~/.docker/config.json`. If `DOCKER_CONFIG` is set, the value of `DOCKER_CONFIG` is used as the path. `config_file` has predencen over all other options.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file", value)

    @property
    @pulumi.getter(name="configFileContent")
    def config_file_content(self) -> Optional[pulumi.Input[str]]:
        """
        Plain content of the docker json file for registry auth. `config_file_content` has precedence over username/password.
        """
        return pulumi.get(self, "config_file_content")

    @config_file_content.setter
    def config_file_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_content", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for the registry. Defaults to `DOCKER_REGISTRY_PASS` env variable if set.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for the registry. Defaults to `DOCKER_REGISTRY_USER` env variable if set.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class RemoteImageBuildArgsDict(TypedDict):
        context: pulumi.Input[str]
        """
        Value to specify the build context. Currently, only a `PATH` context is supported. You can use the helper function '${path.cwd}/context-dir'. Please see https://docs.docker.com/build/building/context/ for more information about build contexts.
        """
        auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildAuthConfigArgsDict']]]]
        """
        The configuration for the authentication
        """
        build_arg: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Set build-time variables
        """
        build_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Pairs for build-time variables in the form TODO
        """
        build_id: NotRequired[pulumi.Input[str]]
        """
        BuildID is an optional identifier that can be passed together with the build request. The same identifier can be used to gracefully cancel the build with the cancel request.
        """
        cache_froms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Images to consider as cache sources
        """
        cgroup_parent: NotRequired[pulumi.Input[str]]
        """
        Optional parent cgroup for the container
        """
        cpu_period: NotRequired[pulumi.Input[int]]
        """
        The length of a CPU period in microseconds
        """
        cpu_quota: NotRequired[pulumi.Input[int]]
        """
        Microseconds of CPU time that the container can get in a CPU period
        """
        cpu_set_cpus: NotRequired[pulumi.Input[str]]
        """
        CPUs in which to allow execution (e.g., `0-3`, `0`, `1`)
        """
        cpu_set_mems: NotRequired[pulumi.Input[str]]
        """
        MEMs in which to allow execution (`0-3`, `0`, `1`)
        """
        cpu_shares: NotRequired[pulumi.Input[int]]
        """
        CPU shares (relative weight)
        """
        dockerfile: NotRequired[pulumi.Input[str]]
        """
        Name of the Dockerfile. Defaults to `Dockerfile`.
        """
        extra_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of hostnames/IP mappings to add to the containers /etc/hosts file. Specified in the form ["hostname:IP"]
        """
        force_remove: NotRequired[pulumi.Input[bool]]
        """
        Always remove intermediate containers
        """
        isolation: NotRequired[pulumi.Input[str]]
        """
        Isolation represents the isolation technology of a container. The supported values are
        """
        label: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Set metadata for an image
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        User-defined key/value metadata
        """
        memory: NotRequired[pulumi.Input[int]]
        """
        Set memory limit for build
        """
        memory_swap: NotRequired[pulumi.Input[int]]
        """
        Total memory (memory + swap), -1 to enable unlimited swap
        """
        network_mode: NotRequired[pulumi.Input[str]]
        """
        Set the networking mode for the RUN instructions during build
        """
        no_cache: NotRequired[pulumi.Input[bool]]
        """
        Do not use the cache when building the image
        """
        platform: NotRequired[pulumi.Input[str]]
        """
        Set platform if server is multi-platform capable
        """
        pull_parent: NotRequired[pulumi.Input[bool]]
        """
        Attempt to pull the image even if an older image exists locally
        """
        remote_context: NotRequired[pulumi.Input[str]]
        """
        A Git repository URI or HTTP/HTTPS context URI
        """
        remove: NotRequired[pulumi.Input[bool]]
        """
        Remove intermediate containers after a successful build. Defaults to `true`.
        """
        security_opts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The security options
        """
        session_id: NotRequired[pulumi.Input[str]]
        """
        Set an ID for the build session
        """
        shm_size: NotRequired[pulumi.Input[int]]
        """
        Size of /dev/shm in bytes. The size must be greater than 0
        """
        squash: NotRequired[pulumi.Input[bool]]
        """
        If true the new layers are squashed into a new image with a single new layer
        """
        suppress_output: NotRequired[pulumi.Input[bool]]
        """
        Suppress the build output and print image ID on success
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Name and optionally a tag in the 'name:tag' format
        """
        target: NotRequired[pulumi.Input[str]]
        """
        Set the target build stage to build
        """
        ulimits: NotRequired[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildUlimitArgsDict']]]]
        """
        Configuration for ulimits
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the underlying builder to use
        """
elif False:
    RemoteImageBuildArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteImageBuildArgs:
    def __init__(__self__, *,
                 context: pulumi.Input[str],
                 auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildAuthConfigArgs']]]] = None,
                 build_arg: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 build_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 build_id: Optional[pulumi.Input[str]] = None,
                 cache_froms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cgroup_parent: Optional[pulumi.Input[str]] = None,
                 cpu_period: Optional[pulumi.Input[int]] = None,
                 cpu_quota: Optional[pulumi.Input[int]] = None,
                 cpu_set_cpus: Optional[pulumi.Input[str]] = None,
                 cpu_set_mems: Optional[pulumi.Input[str]] = None,
                 cpu_shares: Optional[pulumi.Input[int]] = None,
                 dockerfile: Optional[pulumi.Input[str]] = None,
                 extra_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 force_remove: Optional[pulumi.Input[bool]] = None,
                 isolation: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 memory: Optional[pulumi.Input[int]] = None,
                 memory_swap: Optional[pulumi.Input[int]] = None,
                 network_mode: Optional[pulumi.Input[str]] = None,
                 no_cache: Optional[pulumi.Input[bool]] = None,
                 platform: Optional[pulumi.Input[str]] = None,
                 pull_parent: Optional[pulumi.Input[bool]] = None,
                 remote_context: Optional[pulumi.Input[str]] = None,
                 remove: Optional[pulumi.Input[bool]] = None,
                 security_opts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 session_id: Optional[pulumi.Input[str]] = None,
                 shm_size: Optional[pulumi.Input[int]] = None,
                 squash: Optional[pulumi.Input[bool]] = None,
                 suppress_output: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 ulimits: Optional[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildUlimitArgs']]]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] context: Value to specify the build context. Currently, only a `PATH` context is supported. You can use the helper function '${path.cwd}/context-dir'. Please see https://docs.docker.com/build/building/context/ for more information about build contexts.
        :param pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildAuthConfigArgs']]] auth_configs: The configuration for the authentication
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] build_arg: Set build-time variables
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] build_args: Pairs for build-time variables in the form TODO
        :param pulumi.Input[str] build_id: BuildID is an optional identifier that can be passed together with the build request. The same identifier can be used to gracefully cancel the build with the cancel request.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cache_froms: Images to consider as cache sources
        :param pulumi.Input[str] cgroup_parent: Optional parent cgroup for the container
        :param pulumi.Input[int] cpu_period: The length of a CPU period in microseconds
        :param pulumi.Input[int] cpu_quota: Microseconds of CPU time that the container can get in a CPU period
        :param pulumi.Input[str] cpu_set_cpus: CPUs in which to allow execution (e.g., `0-3`, `0`, `1`)
        :param pulumi.Input[str] cpu_set_mems: MEMs in which to allow execution (`0-3`, `0`, `1`)
        :param pulumi.Input[int] cpu_shares: CPU shares (relative weight)
        :param pulumi.Input[str] dockerfile: Name of the Dockerfile. Defaults to `Dockerfile`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_hosts: A list of hostnames/IP mappings to add to the containers /etc/hosts file. Specified in the form ["hostname:IP"]
        :param pulumi.Input[bool] force_remove: Always remove intermediate containers
        :param pulumi.Input[str] isolation: Isolation represents the isolation technology of a container. The supported values are
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] label: Set metadata for an image
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: User-defined key/value metadata
        :param pulumi.Input[int] memory: Set memory limit for build
        :param pulumi.Input[int] memory_swap: Total memory (memory + swap), -1 to enable unlimited swap
        :param pulumi.Input[str] network_mode: Set the networking mode for the RUN instructions during build
        :param pulumi.Input[bool] no_cache: Do not use the cache when building the image
        :param pulumi.Input[str] platform: Set platform if server is multi-platform capable
        :param pulumi.Input[bool] pull_parent: Attempt to pull the image even if an older image exists locally
        :param pulumi.Input[str] remote_context: A Git repository URI or HTTP/HTTPS context URI
        :param pulumi.Input[bool] remove: Remove intermediate containers after a successful build. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_opts: The security options
        :param pulumi.Input[str] session_id: Set an ID for the build session
        :param pulumi.Input[int] shm_size: Size of /dev/shm in bytes. The size must be greater than 0
        :param pulumi.Input[bool] squash: If true the new layers are squashed into a new image with a single new layer
        :param pulumi.Input[bool] suppress_output: Suppress the build output and print image ID on success
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Name and optionally a tag in the 'name:tag' format
        :param pulumi.Input[str] target: Set the target build stage to build
        :param pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildUlimitArgs']]] ulimits: Configuration for ulimits
        :param pulumi.Input[str] version: Version of the underlying builder to use
        """
        pulumi.set(__self__, "context", context)
        if auth_configs is not None:
            pulumi.set(__self__, "auth_configs", auth_configs)
        if build_arg is not None:
            pulumi.set(__self__, "build_arg", build_arg)
        if build_args is not None:
            pulumi.set(__self__, "build_args", build_args)
        if build_id is not None:
            pulumi.set(__self__, "build_id", build_id)
        if cache_froms is not None:
            pulumi.set(__self__, "cache_froms", cache_froms)
        if cgroup_parent is not None:
            pulumi.set(__self__, "cgroup_parent", cgroup_parent)
        if cpu_period is not None:
            pulumi.set(__self__, "cpu_period", cpu_period)
        if cpu_quota is not None:
            pulumi.set(__self__, "cpu_quota", cpu_quota)
        if cpu_set_cpus is not None:
            pulumi.set(__self__, "cpu_set_cpus", cpu_set_cpus)
        if cpu_set_mems is not None:
            pulumi.set(__self__, "cpu_set_mems", cpu_set_mems)
        if cpu_shares is not None:
            pulumi.set(__self__, "cpu_shares", cpu_shares)
        if dockerfile is not None:
            pulumi.set(__self__, "dockerfile", dockerfile)
        if extra_hosts is not None:
            pulumi.set(__self__, "extra_hosts", extra_hosts)
        if force_remove is not None:
            pulumi.set(__self__, "force_remove", force_remove)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if memory_swap is not None:
            pulumi.set(__self__, "memory_swap", memory_swap)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if no_cache is not None:
            pulumi.set(__self__, "no_cache", no_cache)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if pull_parent is not None:
            pulumi.set(__self__, "pull_parent", pull_parent)
        if remote_context is not None:
            pulumi.set(__self__, "remote_context", remote_context)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if security_opts is not None:
            pulumi.set(__self__, "security_opts", security_opts)
        if session_id is not None:
            pulumi.set(__self__, "session_id", session_id)
        if shm_size is not None:
            pulumi.set(__self__, "shm_size", shm_size)
        if squash is not None:
            pulumi.set(__self__, "squash", squash)
        if suppress_output is not None:
            pulumi.set(__self__, "suppress_output", suppress_output)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if ulimits is not None:
            pulumi.set(__self__, "ulimits", ulimits)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def context(self) -> pulumi.Input[str]:
        """
        Value to specify the build context. Currently, only a `PATH` context is supported. You can use the helper function '${path.cwd}/context-dir'. Please see https://docs.docker.com/build/building/context/ for more information about build contexts.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: pulumi.Input[str]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="authConfigs")
    def auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildAuthConfigArgs']]]]:
        """
        The configuration for the authentication
        """
        return pulumi.get(self, "auth_configs")

    @auth_configs.setter
    def auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildAuthConfigArgs']]]]):
        pulumi.set(self, "auth_configs", value)

    @property
    @pulumi.getter(name="buildArg")
    def build_arg(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Set build-time variables
        """
        return pulumi.get(self, "build_arg")

    @build_arg.setter
    def build_arg(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "build_arg", value)

    @property
    @pulumi.getter(name="buildArgs")
    def build_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Pairs for build-time variables in the form TODO
        """
        return pulumi.get(self, "build_args")

    @build_args.setter
    def build_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "build_args", value)

    @property
    @pulumi.getter(name="buildId")
    def build_id(self) -> Optional[pulumi.Input[str]]:
        """
        BuildID is an optional identifier that can be passed together with the build request. The same identifier can be used to gracefully cancel the build with the cancel request.
        """
        return pulumi.get(self, "build_id")

    @build_id.setter
    def build_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_id", value)

    @property
    @pulumi.getter(name="cacheFroms")
    def cache_froms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Images to consider as cache sources
        """
        return pulumi.get(self, "cache_froms")

    @cache_froms.setter
    def cache_froms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cache_froms", value)

    @property
    @pulumi.getter(name="cgroupParent")
    def cgroup_parent(self) -> Optional[pulumi.Input[str]]:
        """
        Optional parent cgroup for the container
        """
        return pulumi.get(self, "cgroup_parent")

    @cgroup_parent.setter
    def cgroup_parent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cgroup_parent", value)

    @property
    @pulumi.getter(name="cpuPeriod")
    def cpu_period(self) -> Optional[pulumi.Input[int]]:
        """
        The length of a CPU period in microseconds
        """
        return pulumi.get(self, "cpu_period")

    @cpu_period.setter
    def cpu_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_period", value)

    @property
    @pulumi.getter(name="cpuQuota")
    def cpu_quota(self) -> Optional[pulumi.Input[int]]:
        """
        Microseconds of CPU time that the container can get in a CPU period
        """
        return pulumi.get(self, "cpu_quota")

    @cpu_quota.setter
    def cpu_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_quota", value)

    @property
    @pulumi.getter(name="cpuSetCpus")
    def cpu_set_cpus(self) -> Optional[pulumi.Input[str]]:
        """
        CPUs in which to allow execution (e.g., `0-3`, `0`, `1`)
        """
        return pulumi.get(self, "cpu_set_cpus")

    @cpu_set_cpus.setter
    def cpu_set_cpus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_set_cpus", value)

    @property
    @pulumi.getter(name="cpuSetMems")
    def cpu_set_mems(self) -> Optional[pulumi.Input[str]]:
        """
        MEMs in which to allow execution (`0-3`, `0`, `1`)
        """
        return pulumi.get(self, "cpu_set_mems")

    @cpu_set_mems.setter
    def cpu_set_mems(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_set_mems", value)

    @property
    @pulumi.getter(name="cpuShares")
    def cpu_shares(self) -> Optional[pulumi.Input[int]]:
        """
        CPU shares (relative weight)
        """
        return pulumi.get(self, "cpu_shares")

    @cpu_shares.setter
    def cpu_shares(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_shares", value)

    @property
    @pulumi.getter
    def dockerfile(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Dockerfile. Defaults to `Dockerfile`.
        """
        return pulumi.get(self, "dockerfile")

    @dockerfile.setter
    def dockerfile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dockerfile", value)

    @property
    @pulumi.getter(name="extraHosts")
    def extra_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of hostnames/IP mappings to add to the containers /etc/hosts file. Specified in the form ["hostname:IP"]
        """
        return pulumi.get(self, "extra_hosts")

    @extra_hosts.setter
    def extra_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_hosts", value)

    @property
    @pulumi.getter(name="forceRemove")
    def force_remove(self) -> Optional[pulumi.Input[bool]]:
        """
        Always remove intermediate containers
        """
        return pulumi.get(self, "force_remove")

    @force_remove.setter
    def force_remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_remove", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[str]]:
        """
        Isolation represents the isolation technology of a container. The supported values are
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Set metadata for an image
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        User-defined key/value metadata
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[int]]:
        """
        Set memory limit for build
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="memorySwap")
    def memory_swap(self) -> Optional[pulumi.Input[int]]:
        """
        Total memory (memory + swap), -1 to enable unlimited swap
        """
        return pulumi.get(self, "memory_swap")

    @memory_swap.setter
    def memory_swap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_swap", value)

    @property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Set the networking mode for the RUN instructions during build
        """
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_mode", value)

    @property
    @pulumi.getter(name="noCache")
    def no_cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not use the cache when building the image
        """
        return pulumi.get(self, "no_cache")

    @no_cache.setter
    def no_cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_cache", value)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        Set platform if server is multi-platform capable
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter(name="pullParent")
    def pull_parent(self) -> Optional[pulumi.Input[bool]]:
        """
        Attempt to pull the image even if an older image exists locally
        """
        return pulumi.get(self, "pull_parent")

    @pull_parent.setter
    def pull_parent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pull_parent", value)

    @property
    @pulumi.getter(name="remoteContext")
    def remote_context(self) -> Optional[pulumi.Input[str]]:
        """
        A Git repository URI or HTTP/HTTPS context URI
        """
        return pulumi.get(self, "remote_context")

    @remote_context.setter
    def remote_context(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_context", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[bool]]:
        """
        Remove intermediate containers after a successful build. Defaults to `true`.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter(name="securityOpts")
    def security_opts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security options
        """
        return pulumi.get(self, "security_opts")

    @security_opts.setter
    def security_opts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_opts", value)

    @property
    @pulumi.getter(name="sessionId")
    def session_id(self) -> Optional[pulumi.Input[str]]:
        """
        Set an ID for the build session
        """
        return pulumi.get(self, "session_id")

    @session_id.setter
    def session_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_id", value)

    @property
    @pulumi.getter(name="shmSize")
    def shm_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of /dev/shm in bytes. The size must be greater than 0
        """
        return pulumi.get(self, "shm_size")

    @shm_size.setter
    def shm_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shm_size", value)

    @property
    @pulumi.getter
    def squash(self) -> Optional[pulumi.Input[bool]]:
        """
        If true the new layers are squashed into a new image with a single new layer
        """
        return pulumi.get(self, "squash")

    @squash.setter
    def squash(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "squash", value)

    @property
    @pulumi.getter(name="suppressOutput")
    def suppress_output(self) -> Optional[pulumi.Input[bool]]:
        """
        Suppress the build output and print image ID on success
        """
        return pulumi.get(self, "suppress_output")

    @suppress_output.setter
    def suppress_output(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress_output", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Name and optionally a tag in the 'name:tag' format
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Set the target build stage to build
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def ulimits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildUlimitArgs']]]]:
        """
        Configuration for ulimits
        """
        return pulumi.get(self, "ulimits")

    @ulimits.setter
    def ulimits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RemoteImageBuildUlimitArgs']]]]):
        pulumi.set(self, "ulimits", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the underlying builder to use
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RemoteImageBuildAuthConfigArgsDict(TypedDict):
        host_name: pulumi.Input[str]
        """
        hostname of the registry
        """
        auth: NotRequired[pulumi.Input[str]]
        """
        the auth token
        """
        email: NotRequired[pulumi.Input[str]]
        """
        the user emal
        """
        identity_token: NotRequired[pulumi.Input[str]]
        """
        the identity token
        """
        password: NotRequired[pulumi.Input[str]]
        """
        the registry password
        """
        registry_token: NotRequired[pulumi.Input[str]]
        """
        the registry token
        """
        server_address: NotRequired[pulumi.Input[str]]
        """
        the server address
        """
        user_name: NotRequired[pulumi.Input[str]]
        """
        the registry user name
        """
elif False:
    RemoteImageBuildAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteImageBuildAuthConfigArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[str],
                 auth: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 identity_token: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 registry_token: Optional[pulumi.Input[str]] = None,
                 server_address: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_name: hostname of the registry
        :param pulumi.Input[str] auth: the auth token
        :param pulumi.Input[str] email: the user emal
        :param pulumi.Input[str] identity_token: the identity token
        :param pulumi.Input[str] password: the registry password
        :param pulumi.Input[str] registry_token: the registry token
        :param pulumi.Input[str] server_address: the server address
        :param pulumi.Input[str] user_name: the registry user name
        """
        pulumi.set(__self__, "host_name", host_name)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if identity_token is not None:
            pulumi.set(__self__, "identity_token", identity_token)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if registry_token is not None:
            pulumi.set(__self__, "registry_token", registry_token)
        if server_address is not None:
            pulumi.set(__self__, "server_address", server_address)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        """
        hostname of the registry
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[str]]:
        """
        the auth token
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        the user emal
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityToken")
    def identity_token(self) -> Optional[pulumi.Input[str]]:
        """
        the identity token
        """
        return pulumi.get(self, "identity_token")

    @identity_token.setter
    def identity_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_token", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        the registry password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="registryToken")
    def registry_token(self) -> Optional[pulumi.Input[str]]:
        """
        the registry token
        """
        return pulumi.get(self, "registry_token")

    @registry_token.setter
    def registry_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_token", value)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> Optional[pulumi.Input[str]]:
        """
        the server address
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        the registry user name
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class RemoteImageBuildUlimitArgsDict(TypedDict):
        hard: pulumi.Input[int]
        """
        soft limit
        """
        name: pulumi.Input[str]
        """
        type of ulimit, e.g. `nofile`
        """
        soft: pulumi.Input[int]
        """
        hard limit
        """
elif False:
    RemoteImageBuildUlimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteImageBuildUlimitArgs:
    def __init__(__self__, *,
                 hard: pulumi.Input[int],
                 name: pulumi.Input[str],
                 soft: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hard: soft limit
        :param pulumi.Input[str] name: type of ulimit, e.g. `nofile`
        :param pulumi.Input[int] soft: hard limit
        """
        pulumi.set(__self__, "hard", hard)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "soft", soft)

    @property
    @pulumi.getter
    def hard(self) -> pulumi.Input[int]:
        """
        soft limit
        """
        return pulumi.get(self, "hard")

    @hard.setter
    def hard(self, value: pulumi.Input[int]):
        pulumi.set(self, "hard", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        type of ulimit, e.g. `nofile`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def soft(self) -> pulumi.Input[int]:
        """
        hard limit
        """
        return pulumi.get(self, "soft")

    @soft.setter
    def soft(self, value: pulumi.Input[int]):
        pulumi.set(self, "soft", value)


if not MYPY:
    class SecretLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    SecretLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceAuthArgsDict(TypedDict):
        server_address: pulumi.Input[str]
        """
        The address of the server for the authentication
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username
        """
elif False:
    ServiceAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAuthArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] server_address: The address of the server for the authentication
        :param pulumi.Input[str] password: The password
        :param pulumi.Input[str] username: The username
        """
        pulumi.set(__self__, "server_address", server_address)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        """
        The address of the server for the authentication
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ServiceConvergeConfigArgsDict(TypedDict):
        delay: NotRequired[pulumi.Input[str]]
        """
        The interval to check if the desired state is reached `(ms|s)`. Defaults to `7s`.
        """
        timeout: NotRequired[pulumi.Input[str]]
        """
        The timeout of the service to reach the desired state `(s|m)`. Defaults to `3m`
        """
elif False:
    ServiceConvergeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConvergeConfigArgs:
    def __init__(__self__, *,
                 delay: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delay: The interval to check if the desired state is reached `(ms|s)`. Defaults to `7s`.
        :param pulumi.Input[str] timeout: The timeout of the service to reach the desired state `(s|m)`. Defaults to `3m`
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[str]]:
        """
        The interval to check if the desired state is reached `(ms|s)`. Defaults to `7s`.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The timeout of the service to reach the desired state `(s|m)`. Defaults to `3m`
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ServiceEndpointSpecArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        The mode of resolution to use for internal load balancing between tasks
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEndpointSpecPortArgsDict']]]]
        """
        List of exposed ports that this service is accessible on from the outside. Ports can only be provided if 'vip' resolution mode is used
        """
elif False:
    ServiceEndpointSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointSpecArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEndpointSpecPortArgs']]]] = None):
        """
        :param pulumi.Input[str] mode: The mode of resolution to use for internal load balancing between tasks
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEndpointSpecPortArgs']]] ports: List of exposed ports that this service is accessible on from the outside. Ports can only be provided if 'vip' resolution mode is used
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode of resolution to use for internal load balancing between tasks
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEndpointSpecPortArgs']]]]:
        """
        List of exposed ports that this service is accessible on from the outside. Ports can only be provided if 'vip' resolution mode is used
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEndpointSpecPortArgs']]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class ServiceEndpointSpecPortArgsDict(TypedDict):
        target_port: pulumi.Input[int]
        """
        The port inside the container
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A random name for the port
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Rrepresents the protocol of a port: `tcp`, `udp` or `sctp`. Defaults to `tcp`.
        """
        publish_mode: NotRequired[pulumi.Input[str]]
        """
        Represents the mode in which the port is to be published: 'ingress' or 'host'. Defaults to `ingress`.
        """
        published_port: NotRequired[pulumi.Input[int]]
        """
        The port on the swarm hosts
        """
elif False:
    ServiceEndpointSpecPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointSpecPortArgs:
    def __init__(__self__, *,
                 target_port: pulumi.Input[int],
                 name: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 publish_mode: Optional[pulumi.Input[str]] = None,
                 published_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] target_port: The port inside the container
        :param pulumi.Input[str] name: A random name for the port
        :param pulumi.Input[str] protocol: Rrepresents the protocol of a port: `tcp`, `udp` or `sctp`. Defaults to `tcp`.
        :param pulumi.Input[str] publish_mode: Represents the mode in which the port is to be published: 'ingress' or 'host'. Defaults to `ingress`.
        :param pulumi.Input[int] published_port: The port on the swarm hosts
        """
        pulumi.set(__self__, "target_port", target_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if publish_mode is not None:
            pulumi.set(__self__, "publish_mode", publish_mode)
        if published_port is not None:
            pulumi.set(__self__, "published_port", published_port)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[int]:
        """
        The port inside the container
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "target_port", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A random name for the port
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Rrepresents the protocol of a port: `tcp`, `udp` or `sctp`. Defaults to `tcp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="publishMode")
    def publish_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Represents the mode in which the port is to be published: 'ingress' or 'host'. Defaults to `ingress`.
        """
        return pulumi.get(self, "publish_mode")

    @publish_mode.setter
    def publish_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publish_mode", value)

    @property
    @pulumi.getter(name="publishedPort")
    def published_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port on the swarm hosts
        """
        return pulumi.get(self, "published_port")

    @published_port.setter
    def published_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "published_port", value)


if not MYPY:
    class ServiceLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    ServiceLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceModeArgsDict(TypedDict):
        global_: NotRequired[pulumi.Input[bool]]
        """
        When `true`, tasks will run on every worker node. Conflicts with `replicated`
        """
        replicated: NotRequired[pulumi.Input['ServiceModeReplicatedArgsDict']]
        """
        The replicated service mode
        """
elif False:
    ServiceModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceModeArgs:
    def __init__(__self__, *,
                 global_: Optional[pulumi.Input[bool]] = None,
                 replicated: Optional[pulumi.Input['ServiceModeReplicatedArgs']] = None):
        """
        :param pulumi.Input[bool] global_: When `true`, tasks will run on every worker node. Conflicts with `replicated`
        :param pulumi.Input['ServiceModeReplicatedArgs'] replicated: The replicated service mode
        """
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if replicated is not None:
            pulumi.set(__self__, "replicated", replicated)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, tasks will run on every worker node. Conflicts with `replicated`
        """
        return pulumi.get(self, "global_")

    @global_.setter
    def global_(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "global_", value)

    @property
    @pulumi.getter
    def replicated(self) -> Optional[pulumi.Input['ServiceModeReplicatedArgs']]:
        """
        The replicated service mode
        """
        return pulumi.get(self, "replicated")

    @replicated.setter
    def replicated(self, value: Optional[pulumi.Input['ServiceModeReplicatedArgs']]):
        pulumi.set(self, "replicated", value)


if not MYPY:
    class ServiceModeReplicatedArgsDict(TypedDict):
        replicas: NotRequired[pulumi.Input[int]]
        """
        The amount of replicas of the service. Defaults to `1`
        """
elif False:
    ServiceModeReplicatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceModeReplicatedArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] replicas: The amount of replicas of the service. Defaults to `1`
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of replicas of the service. Defaults to `1`
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class ServiceRollbackConfigArgsDict(TypedDict):
        delay: NotRequired[pulumi.Input[str]]
        """
        Delay between task rollbacks (ns|us|ms|s|m|h). Defaults to `0s`.
        """
        failure_action: NotRequired[pulumi.Input[str]]
        """
        Action on rollback failure: pause | continue. Defaults to `pause`.
        """
        max_failure_ratio: NotRequired[pulumi.Input[str]]
        """
        Failure rate to tolerate during a rollback. Defaults to `0.0`.
        """
        monitor: NotRequired[pulumi.Input[str]]
        """
        Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.
        """
        order: NotRequired[pulumi.Input[str]]
        """
        Rollback order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.
        """
        parallelism: NotRequired[pulumi.Input[int]]
        """
        Maximum number of tasks to be rollbacked in one iteration. Defaults to `1`
        """
elif False:
    ServiceRollbackConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceRollbackConfigArgs:
    def __init__(__self__, *,
                 delay: Optional[pulumi.Input[str]] = None,
                 failure_action: Optional[pulumi.Input[str]] = None,
                 max_failure_ratio: Optional[pulumi.Input[str]] = None,
                 monitor: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None,
                 parallelism: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delay: Delay between task rollbacks (ns|us|ms|s|m|h). Defaults to `0s`.
        :param pulumi.Input[str] failure_action: Action on rollback failure: pause | continue. Defaults to `pause`.
        :param pulumi.Input[str] max_failure_ratio: Failure rate to tolerate during a rollback. Defaults to `0.0`.
        :param pulumi.Input[str] monitor: Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.
        :param pulumi.Input[str] order: Rollback order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.
        :param pulumi.Input[int] parallelism: Maximum number of tasks to be rollbacked in one iteration. Defaults to `1`
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if failure_action is not None:
            pulumi.set(__self__, "failure_action", failure_action)
        if max_failure_ratio is not None:
            pulumi.set(__self__, "max_failure_ratio", max_failure_ratio)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)

    @property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[str]]:
        """
        Delay between task rollbacks (ns|us|ms|s|m|h). Defaults to `0s`.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter(name="failureAction")
    def failure_action(self) -> Optional[pulumi.Input[str]]:
        """
        Action on rollback failure: pause | continue. Defaults to `pause`.
        """
        return pulumi.get(self, "failure_action")

    @failure_action.setter
    def failure_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_action", value)

    @property
    @pulumi.getter(name="maxFailureRatio")
    def max_failure_ratio(self) -> Optional[pulumi.Input[str]]:
        """
        Failure rate to tolerate during a rollback. Defaults to `0.0`.
        """
        return pulumi.get(self, "max_failure_ratio")

    @max_failure_ratio.setter
    def max_failure_ratio(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_failure_ratio", value)

    @property
    @pulumi.getter
    def monitor(self) -> Optional[pulumi.Input[str]]:
        """
        Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.
        """
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitor", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Rollback order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of tasks to be rollbacked in one iteration. Defaults to `1`
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelism", value)


if not MYPY:
    class ServiceTaskSpecArgsDict(TypedDict):
        container_spec: pulumi.Input['ServiceTaskSpecContainerSpecArgsDict']
        """
        The spec for each container
        """
        force_update: NotRequired[pulumi.Input[int]]
        """
        A counter that triggers an update even if no relevant parameters have been changed. See the [spec](https://github.com/docker/swarmkit/blob/master/api/specs.proto#L126).
        """
        log_driver: NotRequired[pulumi.Input['ServiceTaskSpecLogDriverArgsDict']]
        """
        Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified
        """
        networks_advanceds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecNetworksAdvancedArgsDict']]]]
        """
        The networks the container is attached to
        """
        placement: NotRequired[pulumi.Input['ServiceTaskSpecPlacementArgsDict']]
        """
        The placement preferences
        """
        resources: NotRequired[pulumi.Input['ServiceTaskSpecResourcesArgsDict']]
        """
        Resource requirements which apply to each individual container created as part of the service
        """
        restart_policy: NotRequired[pulumi.Input['ServiceTaskSpecRestartPolicyArgsDict']]
        """
        Specification for the restart policy which applies to containers created as part of this service.
        """
        runtime: NotRequired[pulumi.Input[str]]
        """
        Runtime is the type of runtime specified for the task executor. See the [types](https://github.com/moby/moby/blob/master/api/types/swarm/runtime.go).
        """
elif False:
    ServiceTaskSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecArgs:
    def __init__(__self__, *,
                 container_spec: pulumi.Input['ServiceTaskSpecContainerSpecArgs'],
                 force_update: Optional[pulumi.Input[int]] = None,
                 log_driver: Optional[pulumi.Input['ServiceTaskSpecLogDriverArgs']] = None,
                 networks_advanceds: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecNetworksAdvancedArgs']]]] = None,
                 placement: Optional[pulumi.Input['ServiceTaskSpecPlacementArgs']] = None,
                 resources: Optional[pulumi.Input['ServiceTaskSpecResourcesArgs']] = None,
                 restart_policy: Optional[pulumi.Input['ServiceTaskSpecRestartPolicyArgs']] = None,
                 runtime: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ServiceTaskSpecContainerSpecArgs'] container_spec: The spec for each container
        :param pulumi.Input[int] force_update: A counter that triggers an update even if no relevant parameters have been changed. See the [spec](https://github.com/docker/swarmkit/blob/master/api/specs.proto#L126).
        :param pulumi.Input['ServiceTaskSpecLogDriverArgs'] log_driver: Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecNetworksAdvancedArgs']]] networks_advanceds: The networks the container is attached to
        :param pulumi.Input['ServiceTaskSpecPlacementArgs'] placement: The placement preferences
        :param pulumi.Input['ServiceTaskSpecResourcesArgs'] resources: Resource requirements which apply to each individual container created as part of the service
        :param pulumi.Input['ServiceTaskSpecRestartPolicyArgs'] restart_policy: Specification for the restart policy which applies to containers created as part of this service.
        :param pulumi.Input[str] runtime: Runtime is the type of runtime specified for the task executor. See the [types](https://github.com/moby/moby/blob/master/api/types/swarm/runtime.go).
        """
        pulumi.set(__self__, "container_spec", container_spec)
        if force_update is not None:
            pulumi.set(__self__, "force_update", force_update)
        if log_driver is not None:
            pulumi.set(__self__, "log_driver", log_driver)
        if networks_advanceds is not None:
            pulumi.set(__self__, "networks_advanceds", networks_advanceds)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)

    @property
    @pulumi.getter(name="containerSpec")
    def container_spec(self) -> pulumi.Input['ServiceTaskSpecContainerSpecArgs']:
        """
        The spec for each container
        """
        return pulumi.get(self, "container_spec")

    @container_spec.setter
    def container_spec(self, value: pulumi.Input['ServiceTaskSpecContainerSpecArgs']):
        pulumi.set(self, "container_spec", value)

    @property
    @pulumi.getter(name="forceUpdate")
    def force_update(self) -> Optional[pulumi.Input[int]]:
        """
        A counter that triggers an update even if no relevant parameters have been changed. See the [spec](https://github.com/docker/swarmkit/blob/master/api/specs.proto#L126).
        """
        return pulumi.get(self, "force_update")

    @force_update.setter
    def force_update(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "force_update", value)

    @property
    @pulumi.getter(name="logDriver")
    def log_driver(self) -> Optional[pulumi.Input['ServiceTaskSpecLogDriverArgs']]:
        """
        Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified
        """
        return pulumi.get(self, "log_driver")

    @log_driver.setter
    def log_driver(self, value: Optional[pulumi.Input['ServiceTaskSpecLogDriverArgs']]):
        pulumi.set(self, "log_driver", value)

    @property
    @pulumi.getter(name="networksAdvanceds")
    def networks_advanceds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecNetworksAdvancedArgs']]]]:
        """
        The networks the container is attached to
        """
        return pulumi.get(self, "networks_advanceds")

    @networks_advanceds.setter
    def networks_advanceds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecNetworksAdvancedArgs']]]]):
        pulumi.set(self, "networks_advanceds", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['ServiceTaskSpecPlacementArgs']]:
        """
        The placement preferences
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['ServiceTaskSpecPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['ServiceTaskSpecResourcesArgs']]:
        """
        Resource requirements which apply to each individual container created as part of the service
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['ServiceTaskSpecResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[pulumi.Input['ServiceTaskSpecRestartPolicyArgs']]:
        """
        Specification for the restart policy which applies to containers created as part of this service.
        """
        return pulumi.get(self, "restart_policy")

    @restart_policy.setter
    def restart_policy(self, value: Optional[pulumi.Input['ServiceTaskSpecRestartPolicyArgs']]):
        pulumi.set(self, "restart_policy", value)

    @property
    @pulumi.getter
    def runtime(self) -> Optional[pulumi.Input[str]]:
        """
        Runtime is the type of runtime specified for the task executor. See the [types](https://github.com/moby/moby/blob/master/api/types/swarm/runtime.go).
        """
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecArgsDict(TypedDict):
        image: pulumi.Input[str]
        """
        The image name to use for the containers of the service, like `nginx:1.17.6`. Also use the data-source or resource of `RemoteImage` with the `repo_digest` or `RegistryImage` with the `name` attribute for this, as shown in the examples.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Arguments to the command
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The command/entrypoint to be run in the image. According to the [docker cli](https://github.com/docker/cli/blob/v20.10.7/cli/command/service/opts.go#L705) the override of the entrypoint is also passed to the `command` property and there is no `entrypoint` attribute in the `ContainerSpec` of the service.
        """
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecConfigArgsDict']]]]
        """
        References to zero or more configs that will be exposed to the service
        """
        dir: NotRequired[pulumi.Input[str]]
        """
        The working directory for commands to run in
        """
        dns_config: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecDnsConfigArgsDict']]
        """
        Specification for DNS related configurations in resolver configuration file (`resolv.conf`)
        """
        env: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A list of environment variables in the form VAR="value"
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of additional groups that the container process will run as
        """
        healthcheck: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecHealthcheckArgsDict']]
        """
        A test to perform to check that the container is healthy
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        The hostname to use for the container, as a valid RFC 1123 hostname
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecHostArgsDict']]]]
        """
        A list of hostname/IP mappings to add to the container's hosts file
        """
        isolation: NotRequired[pulumi.Input[str]]
        """
        Isolation technology of the containers running the service. (Windows only). Defaults to `default`.
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecLabelArgsDict']]]]
        """
        User-defined key/value metadata
        """
        mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountArgsDict']]]]
        """
        Specification for mounts to be added to containers created as part of the service
        """
        privileges: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesArgsDict']]
        """
        Security options for the container
        """
        read_only: NotRequired[pulumi.Input[bool]]
        """
        Mount the container's root filesystem as read only
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecSecretArgsDict']]]]
        """
        References to zero or more secrets that will be exposed to the service
        """
        stop_grace_period: NotRequired[pulumi.Input[str]]
        """
        Amount of time to wait for the container to terminate before forcefully removing it (ms|s|m|h). If not specified or '0s' the destroy will not check if all tasks/containers of the service terminate.
        """
        stop_signal: NotRequired[pulumi.Input[str]]
        """
        Signal to stop the container
        """
        sysctl: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Sysctls config (Linux only)
        """
        user: NotRequired[pulumi.Input[str]]
        """
        The user inside the container
        """
elif False:
    ServiceTaskSpecContainerSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecConfigArgs']]]] = None,
                 dir: Optional[pulumi.Input[str]] = None,
                 dns_config: Optional[pulumi.Input['ServiceTaskSpecContainerSpecDnsConfigArgs']] = None,
                 env: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 healthcheck: Optional[pulumi.Input['ServiceTaskSpecContainerSpecHealthcheckArgs']] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecHostArgs']]]] = None,
                 isolation: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecLabelArgs']]]] = None,
                 mounts: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountArgs']]]] = None,
                 privileges: Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesArgs']] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecSecretArgs']]]] = None,
                 stop_grace_period: Optional[pulumi.Input[str]] = None,
                 stop_signal: Optional[pulumi.Input[str]] = None,
                 sysctl: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image: The image name to use for the containers of the service, like `nginx:1.17.6`. Also use the data-source or resource of `RemoteImage` with the `repo_digest` or `RegistryImage` with the `name` attribute for this, as shown in the examples.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments to the command
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: The command/entrypoint to be run in the image. According to the [docker cli](https://github.com/docker/cli/blob/v20.10.7/cli/command/service/opts.go#L705) the override of the entrypoint is also passed to the `command` property and there is no `entrypoint` attribute in the `ContainerSpec` of the service.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecConfigArgs']]] configs: References to zero or more configs that will be exposed to the service
        :param pulumi.Input[str] dir: The working directory for commands to run in
        :param pulumi.Input['ServiceTaskSpecContainerSpecDnsConfigArgs'] dns_config: Specification for DNS related configurations in resolver configuration file (`resolv.conf`)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] env: A list of environment variables in the form VAR="value"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: A list of additional groups that the container process will run as
        :param pulumi.Input['ServiceTaskSpecContainerSpecHealthcheckArgs'] healthcheck: A test to perform to check that the container is healthy
        :param pulumi.Input[str] hostname: The hostname to use for the container, as a valid RFC 1123 hostname
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecHostArgs']]] hosts: A list of hostname/IP mappings to add to the container's hosts file
        :param pulumi.Input[str] isolation: Isolation technology of the containers running the service. (Windows only). Defaults to `default`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecLabelArgs']]] labels: User-defined key/value metadata
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountArgs']]] mounts: Specification for mounts to be added to containers created as part of the service
        :param pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesArgs'] privileges: Security options for the container
        :param pulumi.Input[bool] read_only: Mount the container's root filesystem as read only
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecSecretArgs']]] secrets: References to zero or more secrets that will be exposed to the service
        :param pulumi.Input[str] stop_grace_period: Amount of time to wait for the container to terminate before forcefully removing it (ms|s|m|h). If not specified or '0s' the destroy will not check if all tasks/containers of the service terminate.
        :param pulumi.Input[str] stop_signal: Signal to stop the container
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] sysctl: Sysctls config (Linux only)
        :param pulumi.Input[str] user: The user inside the container
        """
        pulumi.set(__self__, "image", image)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if dns_config is not None:
            pulumi.set(__self__, "dns_config", dns_config)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if mounts is not None:
            pulumi.set(__self__, "mounts", mounts)
        if privileges is not None:
            pulumi.set(__self__, "privileges", privileges)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if stop_grace_period is not None:
            pulumi.set(__self__, "stop_grace_period", stop_grace_period)
        if stop_signal is not None:
            pulumi.set(__self__, "stop_signal", stop_signal)
        if sysctl is not None:
            pulumi.set(__self__, "sysctl", sysctl)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        The image name to use for the containers of the service, like `nginx:1.17.6`. Also use the data-source or resource of `RemoteImage` with the `repo_digest` or `RegistryImage` with the `name` attribute for this, as shown in the examples.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments to the command
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The command/entrypoint to be run in the image. According to the [docker cli](https://github.com/docker/cli/blob/v20.10.7/cli/command/service/opts.go#L705) the override of the entrypoint is also passed to the `command` property and there is no `entrypoint` attribute in the `ContainerSpec` of the service.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecConfigArgs']]]]:
        """
        References to zero or more configs that will be exposed to the service
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecConfigArgs']]]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter
    def dir(self) -> Optional[pulumi.Input[str]]:
        """
        The working directory for commands to run in
        """
        return pulumi.get(self, "dir")

    @dir.setter
    def dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dir", value)

    @property
    @pulumi.getter(name="dnsConfig")
    def dns_config(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecDnsConfigArgs']]:
        """
        Specification for DNS related configurations in resolver configuration file (`resolv.conf`)
        """
        return pulumi.get(self, "dns_config")

    @dns_config.setter
    def dns_config(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecDnsConfigArgs']]):
        pulumi.set(self, "dns_config", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A list of environment variables in the form VAR="value"
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of additional groups that the container process will run as
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecHealthcheckArgs']]:
        """
        A test to perform to check that the container is healthy
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecHealthcheckArgs']]):
        pulumi.set(self, "healthcheck", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname to use for the container, as a valid RFC 1123 hostname
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecHostArgs']]]]:
        """
        A list of hostname/IP mappings to add to the container's hosts file
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecHostArgs']]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[str]]:
        """
        Isolation technology of the containers running the service. (Windows only). Defaults to `default`.
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecLabelArgs']]]]:
        """
        User-defined key/value metadata
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountArgs']]]]:
        """
        Specification for mounts to be added to containers created as part of the service
        """
        return pulumi.get(self, "mounts")

    @mounts.setter
    def mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountArgs']]]]):
        pulumi.set(self, "mounts", value)

    @property
    @pulumi.getter
    def privileges(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesArgs']]:
        """
        Security options for the container
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesArgs']]):
        pulumi.set(self, "privileges", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Mount the container's root filesystem as read only
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecSecretArgs']]]]:
        """
        References to zero or more secrets that will be exposed to the service
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="stopGracePeriod")
    def stop_grace_period(self) -> Optional[pulumi.Input[str]]:
        """
        Amount of time to wait for the container to terminate before forcefully removing it (ms|s|m|h). If not specified or '0s' the destroy will not check if all tasks/containers of the service terminate.
        """
        return pulumi.get(self, "stop_grace_period")

    @stop_grace_period.setter
    def stop_grace_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stop_grace_period", value)

    @property
    @pulumi.getter(name="stopSignal")
    def stop_signal(self) -> Optional[pulumi.Input[str]]:
        """
        Signal to stop the container
        """
        return pulumi.get(self, "stop_signal")

    @stop_signal.setter
    def stop_signal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stop_signal", value)

    @property
    @pulumi.getter
    def sysctl(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Sysctls config (Linux only)
        """
        return pulumi.get(self, "sysctl")

    @sysctl.setter
    def sysctl(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "sysctl", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        The user inside the container
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecConfigArgsDict(TypedDict):
        config_id: pulumi.Input[str]
        """
        ID of the specific config that we're referencing
        """
        file_name: pulumi.Input[str]
        """
        Represents the final filename in the filesystem
        """
        config_name: NotRequired[pulumi.Input[str]]
        """
        Name of the config that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID
        """
        file_gid: NotRequired[pulumi.Input[str]]
        """
        Represents the file GID. Defaults to `0`.
        """
        file_mode: NotRequired[pulumi.Input[int]]
        """
        Represents represents the FileMode of the file. Defaults to `0o444`.
        """
        file_uid: NotRequired[pulumi.Input[str]]
        """
        Represents the file UID. Defaults to `0`.
        """
elif False:
    ServiceTaskSpecContainerSpecConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecConfigArgs:
    def __init__(__self__, *,
                 config_id: pulumi.Input[str],
                 file_name: pulumi.Input[str],
                 config_name: Optional[pulumi.Input[str]] = None,
                 file_gid: Optional[pulumi.Input[str]] = None,
                 file_mode: Optional[pulumi.Input[int]] = None,
                 file_uid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_id: ID of the specific config that we're referencing
        :param pulumi.Input[str] file_name: Represents the final filename in the filesystem
        :param pulumi.Input[str] config_name: Name of the config that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID
        :param pulumi.Input[str] file_gid: Represents the file GID. Defaults to `0`.
        :param pulumi.Input[int] file_mode: Represents represents the FileMode of the file. Defaults to `0o444`.
        :param pulumi.Input[str] file_uid: Represents the file UID. Defaults to `0`.
        """
        pulumi.set(__self__, "config_id", config_id)
        pulumi.set(__self__, "file_name", file_name)
        if config_name is not None:
            pulumi.set(__self__, "config_name", config_name)
        if file_gid is not None:
            pulumi.set(__self__, "file_gid", file_gid)
        if file_mode is not None:
            pulumi.set(__self__, "file_mode", file_mode)
        if file_uid is not None:
            pulumi.set(__self__, "file_uid", file_uid)

    @property
    @pulumi.getter(name="configId")
    def config_id(self) -> pulumi.Input[str]:
        """
        ID of the specific config that we're referencing
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_id", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[str]:
        """
        Represents the final filename in the filesystem
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="configName")
    def config_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the config that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID
        """
        return pulumi.get(self, "config_name")

    @config_name.setter
    def config_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_name", value)

    @property
    @pulumi.getter(name="fileGid")
    def file_gid(self) -> Optional[pulumi.Input[str]]:
        """
        Represents the file GID. Defaults to `0`.
        """
        return pulumi.get(self, "file_gid")

    @file_gid.setter
    def file_gid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_gid", value)

    @property
    @pulumi.getter(name="fileMode")
    def file_mode(self) -> Optional[pulumi.Input[int]]:
        """
        Represents represents the FileMode of the file. Defaults to `0o444`.
        """
        return pulumi.get(self, "file_mode")

    @file_mode.setter
    def file_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_mode", value)

    @property
    @pulumi.getter(name="fileUid")
    def file_uid(self) -> Optional[pulumi.Input[str]]:
        """
        Represents the file UID. Defaults to `0`.
        """
        return pulumi.get(self, "file_uid")

    @file_uid.setter
    def file_uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_uid", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecDnsConfigArgsDict(TypedDict):
        nameservers: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The IP addresses of the name servers
        """
        options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of internal resolver variables to be modified (e.g., `debug`, `ndots:3`, etc.)
        """
        searches: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A search list for host-name lookup
        """
elif False:
    ServiceTaskSpecContainerSpecDnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecDnsConfigArgs:
    def __init__(__self__, *,
                 nameservers: pulumi.Input[Sequence[pulumi.Input[str]]],
                 options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 searches: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nameservers: The IP addresses of the name servers
        :param pulumi.Input[Sequence[pulumi.Input[str]]] options: A list of internal resolver variables to be modified (e.g., `debug`, `ndots:3`, etc.)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] searches: A search list for host-name lookup
        """
        pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @property
    @pulumi.getter
    def nameservers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The IP addresses of the name servers
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "nameservers", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of internal resolver variables to be modified (e.g., `debug`, `ndots:3`, etc.)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def searches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A search list for host-name lookup
        """
        return pulumi.get(self, "searches")

    @searches.setter
    def searches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "searches", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecHealthcheckArgsDict(TypedDict):
        tests: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The test to perform as list
        """
        interval: NotRequired[pulumi.Input[str]]
        """
        Time between running the check (ms|s|m|h). Defaults to `0s`.
        """
        retries: NotRequired[pulumi.Input[int]]
        """
        Consecutive failures needed to report unhealthy. Defaults to `0`
        """
        start_period: NotRequired[pulumi.Input[str]]
        """
        Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.
        """
        timeout: NotRequired[pulumi.Input[str]]
        """
        Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.
        """
elif False:
    ServiceTaskSpecContainerSpecHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecHealthcheckArgs:
    def __init__(__self__, *,
                 tests: pulumi.Input[Sequence[pulumi.Input[str]]],
                 interval: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 start_period: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tests: The test to perform as list
        :param pulumi.Input[str] interval: Time between running the check (ms|s|m|h). Defaults to `0s`.
        :param pulumi.Input[int] retries: Consecutive failures needed to report unhealthy. Defaults to `0`
        :param pulumi.Input[str] start_period: Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.
        :param pulumi.Input[str] timeout: Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.
        """
        pulumi.set(__self__, "tests", tests)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if start_period is not None:
            pulumi.set(__self__, "start_period", start_period)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def tests(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The test to perform as list
        """
        return pulumi.get(self, "tests")

    @tests.setter
    def tests(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "tests", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time between running the check (ms|s|m|h). Defaults to `0s`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        Consecutive failures needed to report unhealthy. Defaults to `0`
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="startPeriod")
    def start_period(self) -> Optional[pulumi.Input[str]]:
        """
        Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.
        """
        return pulumi.get(self, "start_period")

    @start_period.setter
    def start_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_period", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecHostArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The name of the host
        """
        ip: pulumi.Input[str]
        """
        The ip of the host
        """
elif False:
    ServiceTaskSpecContainerSpecHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecHostArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] host: The name of the host
        :param pulumi.Input[str] ip: The ip of the host
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The name of the host
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The ip of the host
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    ServiceTaskSpecContainerSpecLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecMountArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        Container path
        """
        type: pulumi.Input[str]
        """
        The mount type
        """
        bind_options: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecMountBindOptionsArgsDict']]
        """
        Optional configuration for the bind type
        """
        read_only: NotRequired[pulumi.Input[bool]]
        """
        Whether the mount should be read-only
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Mount source (e.g. a volume name, a host path)
        """
        tmpfs_options: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecMountTmpfsOptionsArgsDict']]
        """
        Optional configuration for the tmpfs type
        """
        volume_options: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsArgsDict']]
        """
        Optional configuration for the volume type
        """
elif False:
    ServiceTaskSpecContainerSpecMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecMountArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 type: pulumi.Input[str],
                 bind_options: Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountBindOptionsArgs']] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 tmpfs_options: Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountTmpfsOptionsArgs']] = None,
                 volume_options: Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsArgs']] = None):
        """
        :param pulumi.Input[str] target: Container path
        :param pulumi.Input[str] type: The mount type
        :param pulumi.Input['ServiceTaskSpecContainerSpecMountBindOptionsArgs'] bind_options: Optional configuration for the bind type
        :param pulumi.Input[bool] read_only: Whether the mount should be read-only
        :param pulumi.Input[str] source: Mount source (e.g. a volume name, a host path)
        :param pulumi.Input['ServiceTaskSpecContainerSpecMountTmpfsOptionsArgs'] tmpfs_options: Optional configuration for the tmpfs type
        :param pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsArgs'] volume_options: Optional configuration for the volume type
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if bind_options is not None:
            pulumi.set(__self__, "bind_options", bind_options)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if tmpfs_options is not None:
            pulumi.set(__self__, "tmpfs_options", tmpfs_options)
        if volume_options is not None:
            pulumi.set(__self__, "volume_options", volume_options)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Container path
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The mount type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bindOptions")
    def bind_options(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountBindOptionsArgs']]:
        """
        Optional configuration for the bind type
        """
        return pulumi.get(self, "bind_options")

    @bind_options.setter
    def bind_options(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountBindOptionsArgs']]):
        pulumi.set(self, "bind_options", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the mount should be read-only
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Mount source (e.g. a volume name, a host path)
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="tmpfsOptions")
    def tmpfs_options(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountTmpfsOptionsArgs']]:
        """
        Optional configuration for the tmpfs type
        """
        return pulumi.get(self, "tmpfs_options")

    @tmpfs_options.setter
    def tmpfs_options(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountTmpfsOptionsArgs']]):
        pulumi.set(self, "tmpfs_options", value)

    @property
    @pulumi.getter(name="volumeOptions")
    def volume_options(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsArgs']]:
        """
        Optional configuration for the volume type
        """
        return pulumi.get(self, "volume_options")

    @volume_options.setter
    def volume_options(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsArgs']]):
        pulumi.set(self, "volume_options", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecMountBindOptionsArgsDict(TypedDict):
        propagation: NotRequired[pulumi.Input[str]]
        """
        Bind propagation refers to whether or not mounts created within a given bind-mount or named volume can be propagated to replicas of that mount. See the [docs](https://docs.docker.com/storage/bind-mounts/#configure-bind-propagation) for details. Defaults to `rprivate`
        """
elif False:
    ServiceTaskSpecContainerSpecMountBindOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecMountBindOptionsArgs:
    def __init__(__self__, *,
                 propagation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] propagation: Bind propagation refers to whether or not mounts created within a given bind-mount or named volume can be propagated to replicas of that mount. See the [docs](https://docs.docker.com/storage/bind-mounts/#configure-bind-propagation) for details. Defaults to `rprivate`
        """
        if propagation is not None:
            pulumi.set(__self__, "propagation", propagation)

    @property
    @pulumi.getter
    def propagation(self) -> Optional[pulumi.Input[str]]:
        """
        Bind propagation refers to whether or not mounts created within a given bind-mount or named volume can be propagated to replicas of that mount. See the [docs](https://docs.docker.com/storage/bind-mounts/#configure-bind-propagation) for details. Defaults to `rprivate`
        """
        return pulumi.get(self, "propagation")

    @propagation.setter
    def propagation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "propagation", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecMountTmpfsOptionsArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[int]]
        """
        The permission mode for the tmpfs mount in an integer
        """
        size_bytes: NotRequired[pulumi.Input[int]]
        """
        The size for the tmpfs mount in bytes
        """
elif False:
    ServiceTaskSpecContainerSpecMountTmpfsOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecMountTmpfsOptionsArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[int]] = None,
                 size_bytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] mode: The permission mode for the tmpfs mount in an integer
        :param pulumi.Input[int] size_bytes: The size for the tmpfs mount in bytes
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        """
        The permission mode for the tmpfs mount in an integer
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The size for the tmpfs mount in bytes
        """
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_bytes", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecMountVolumeOptionsArgsDict(TypedDict):
        driver_name: NotRequired[pulumi.Input[str]]
        """
        Name of the driver to use to create the volume
        """
        driver_options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        key/value map of driver specific options
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgsDict']]]]
        """
        User-defined key/value metadata
        """
        no_copy: NotRequired[pulumi.Input[bool]]
        """
        Populate volume with data from the target
        """
elif False:
    ServiceTaskSpecContainerSpecMountVolumeOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecMountVolumeOptionsArgs:
    def __init__(__self__, *,
                 driver_name: Optional[pulumi.Input[str]] = None,
                 driver_options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgs']]]] = None,
                 no_copy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] driver_name: Name of the driver to use to create the volume
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] driver_options: key/value map of driver specific options
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgs']]] labels: User-defined key/value metadata
        :param pulumi.Input[bool] no_copy: Populate volume with data from the target
        """
        if driver_name is not None:
            pulumi.set(__self__, "driver_name", driver_name)
        if driver_options is not None:
            pulumi.set(__self__, "driver_options", driver_options)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if no_copy is not None:
            pulumi.set(__self__, "no_copy", no_copy)

    @property
    @pulumi.getter(name="driverName")
    def driver_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the driver to use to create the volume
        """
        return pulumi.get(self, "driver_name")

    @driver_name.setter
    def driver_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_name", value)

    @property
    @pulumi.getter(name="driverOptions")
    def driver_options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        key/value map of driver specific options
        """
        return pulumi.get(self, "driver_options")

    @driver_options.setter
    def driver_options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "driver_options", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgs']]]]:
        """
        User-defined key/value metadata
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="noCopy")
    def no_copy(self) -> Optional[pulumi.Input[bool]]:
        """
        Populate volume with data from the target
        """
        return pulumi.get(self, "no_copy")

    @no_copy.setter
    def no_copy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_copy", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecMountVolumeOptionsLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecPrivilegesArgsDict(TypedDict):
        credential_spec: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgsDict']]
        """
        CredentialSpec for managed service account (Windows only)
        """
        se_linux_context: NotRequired[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgsDict']]
        """
        SELinux labels of the container
        """
elif False:
    ServiceTaskSpecContainerSpecPrivilegesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecPrivilegesArgs:
    def __init__(__self__, *,
                 credential_spec: Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgs']] = None,
                 se_linux_context: Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgs']] = None):
        """
        :param pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgs'] credential_spec: CredentialSpec for managed service account (Windows only)
        :param pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgs'] se_linux_context: SELinux labels of the container
        """
        if credential_spec is not None:
            pulumi.set(__self__, "credential_spec", credential_spec)
        if se_linux_context is not None:
            pulumi.set(__self__, "se_linux_context", se_linux_context)

    @property
    @pulumi.getter(name="credentialSpec")
    def credential_spec(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgs']]:
        """
        CredentialSpec for managed service account (Windows only)
        """
        return pulumi.get(self, "credential_spec")

    @credential_spec.setter
    def credential_spec(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgs']]):
        pulumi.set(self, "credential_spec", value)

    @property
    @pulumi.getter(name="seLinuxContext")
    def se_linux_context(self) -> Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgs']]:
        """
        SELinux labels of the container
        """
        return pulumi.get(self, "se_linux_context")

    @se_linux_context.setter
    def se_linux_context(self, value: Optional[pulumi.Input['ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgs']]):
        pulumi.set(self, "se_linux_context", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgsDict(TypedDict):
        file: NotRequired[pulumi.Input[str]]
        """
        Load credential spec from this file
        """
        registry: NotRequired[pulumi.Input[str]]
        """
        Load credential spec from this value in the Windows registry
        """
elif False:
    ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecPrivilegesCredentialSpecArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input[str]] = None,
                 registry: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file: Load credential spec from this file
        :param pulumi.Input[str] registry: Load credential spec from this value in the Windows registry
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input[str]]:
        """
        Load credential spec from this file
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[str]]:
        """
        Load credential spec from this value in the Windows registry
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        Disable SELinux
        """
        level: NotRequired[pulumi.Input[str]]
        """
        SELinux level label
        """
        role: NotRequired[pulumi.Input[str]]
        """
        SELinux role label
        """
        type: NotRequired[pulumi.Input[str]]
        """
        SELinux type label
        """
        user: NotRequired[pulumi.Input[str]]
        """
        SELinux user label
        """
elif False:
    ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecPrivilegesSeLinuxContextArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable: Disable SELinux
        :param pulumi.Input[str] level: SELinux level label
        :param pulumi.Input[str] role: SELinux role label
        :param pulumi.Input[str] type: SELinux type label
        :param pulumi.Input[str] user: SELinux user label
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable SELinux
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        SELinux level label
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        SELinux role label
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        SELinux type label
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        SELinux user label
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceTaskSpecContainerSpecSecretArgsDict(TypedDict):
        file_name: pulumi.Input[str]
        """
        Represents the final filename in the filesystem
        """
        secret_id: pulumi.Input[str]
        """
        ID of the specific secret that we're referencing
        """
        file_gid: NotRequired[pulumi.Input[str]]
        """
        Represents the file GID. Defaults to `0`
        """
        file_mode: NotRequired[pulumi.Input[int]]
        """
        Represents represents the FileMode of the file. Defaults to `0o444`
        """
        file_uid: NotRequired[pulumi.Input[str]]
        """
        Represents the file UID. Defaults to `0`
        """
        secret_name: NotRequired[pulumi.Input[str]]
        """
        Name of the secret that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID
        """
elif False:
    ServiceTaskSpecContainerSpecSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecContainerSpecSecretArgs:
    def __init__(__self__, *,
                 file_name: pulumi.Input[str],
                 secret_id: pulumi.Input[str],
                 file_gid: Optional[pulumi.Input[str]] = None,
                 file_mode: Optional[pulumi.Input[int]] = None,
                 file_uid: Optional[pulumi.Input[str]] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file_name: Represents the final filename in the filesystem
        :param pulumi.Input[str] secret_id: ID of the specific secret that we're referencing
        :param pulumi.Input[str] file_gid: Represents the file GID. Defaults to `0`
        :param pulumi.Input[int] file_mode: Represents represents the FileMode of the file. Defaults to `0o444`
        :param pulumi.Input[str] file_uid: Represents the file UID. Defaults to `0`
        :param pulumi.Input[str] secret_name: Name of the secret that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID
        """
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "secret_id", secret_id)
        if file_gid is not None:
            pulumi.set(__self__, "file_gid", file_gid)
        if file_mode is not None:
            pulumi.set(__self__, "file_mode", file_mode)
        if file_uid is not None:
            pulumi.set(__self__, "file_uid", file_uid)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[str]:
        """
        Represents the final filename in the filesystem
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[str]:
        """
        ID of the specific secret that we're referencing
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_id", value)

    @property
    @pulumi.getter(name="fileGid")
    def file_gid(self) -> Optional[pulumi.Input[str]]:
        """
        Represents the file GID. Defaults to `0`
        """
        return pulumi.get(self, "file_gid")

    @file_gid.setter
    def file_gid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_gid", value)

    @property
    @pulumi.getter(name="fileMode")
    def file_mode(self) -> Optional[pulumi.Input[int]]:
        """
        Represents represents the FileMode of the file. Defaults to `0o444`
        """
        return pulumi.get(self, "file_mode")

    @file_mode.setter
    def file_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_mode", value)

    @property
    @pulumi.getter(name="fileUid")
    def file_uid(self) -> Optional[pulumi.Input[str]]:
        """
        Represents the file UID. Defaults to `0`
        """
        return pulumi.get(self, "file_uid")

    @file_uid.setter
    def file_uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_uid", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the secret that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class ServiceTaskSpecLogDriverArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The logging driver to use
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The options for the logging driver
        """
elif False:
    ServiceTaskSpecLogDriverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecLogDriverArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The logging driver to use
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: The options for the logging driver
        """
        pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The logging driver to use
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The options for the logging driver
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class ServiceTaskSpecNetworksAdvancedArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name/id of the network.
        """
        aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The network aliases of the container in the specific network.
        """
        driver_opts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of driver options for the network, e.g. `opts1=value`
        """
elif False:
    ServiceTaskSpecNetworksAdvancedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecNetworksAdvancedArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 driver_opts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name/id of the network.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aliases: The network aliases of the container in the specific network.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] driver_opts: An array of driver options for the network, e.g. `opts1=value`
        """
        pulumi.set(__self__, "name", name)
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if driver_opts is not None:
            pulumi.set(__self__, "driver_opts", driver_opts)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name/id of the network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The network aliases of the container in the specific network.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter(name="driverOpts")
    def driver_opts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of driver options for the network, e.g. `opts1=value`
        """
        return pulumi.get(self, "driver_opts")

    @driver_opts.setter
    def driver_opts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "driver_opts", value)


if not MYPY:
    class ServiceTaskSpecPlacementArgsDict(TypedDict):
        constraints: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of constraints. e.g.: `node.role==manager`
        """
        max_replicas: NotRequired[pulumi.Input[int]]
        """
        Maximum number of replicas for per node (default value is `0`, which is unlimited)
        """
        platforms: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecPlacementPlatformArgsDict']]]]
        """
        Platforms stores all the platforms that the service's image can run on
        """
        prefs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence, e.g.: `spread=node.role.manager`
        """
elif False:
    ServiceTaskSpecPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecPlacementArgs:
    def __init__(__self__, *,
                 constraints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 platforms: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecPlacementPlatformArgs']]]] = None,
                 prefs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] constraints: An array of constraints. e.g.: `node.role==manager`
        :param pulumi.Input[int] max_replicas: Maximum number of replicas for per node (default value is `0`, which is unlimited)
        :param pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecPlacementPlatformArgs']]] platforms: Platforms stores all the platforms that the service's image can run on
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefs: Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence, e.g.: `spread=node.role.manager`
        """
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if platforms is not None:
            pulumi.set(__self__, "platforms", platforms)
        if prefs is not None:
            pulumi.set(__self__, "prefs", prefs)

    @property
    @pulumi.getter
    def constraints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of constraints. e.g.: `node.role==manager`
        """
        return pulumi.get(self, "constraints")

    @constraints.setter
    def constraints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "constraints", value)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of replicas for per node (default value is `0`, which is unlimited)
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter
    def platforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecPlacementPlatformArgs']]]]:
        """
        Platforms stores all the platforms that the service's image can run on
        """
        return pulumi.get(self, "platforms")

    @platforms.setter
    def platforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceTaskSpecPlacementPlatformArgs']]]]):
        pulumi.set(self, "platforms", value)

    @property
    @pulumi.getter
    def prefs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence, e.g.: `spread=node.role.manager`
        """
        return pulumi.get(self, "prefs")

    @prefs.setter
    def prefs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefs", value)


if not MYPY:
    class ServiceTaskSpecPlacementPlatformArgsDict(TypedDict):
        architecture: pulumi.Input[str]
        """
        The architecture, e.g. `amd64`
        """
        os: pulumi.Input[str]
        """
        The operation system, e.g. `linux`
        """
elif False:
    ServiceTaskSpecPlacementPlatformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecPlacementPlatformArgs:
    def __init__(__self__, *,
                 architecture: pulumi.Input[str],
                 os: pulumi.Input[str]):
        """
        :param pulumi.Input[str] architecture: The architecture, e.g. `amd64`
        :param pulumi.Input[str] os: The operation system, e.g. `linux`
        """
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "os", os)

    @property
    @pulumi.getter
    def architecture(self) -> pulumi.Input[str]:
        """
        The architecture, e.g. `amd64`
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: pulumi.Input[str]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def os(self) -> pulumi.Input[str]:
        """
        The operation system, e.g. `linux`
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: pulumi.Input[str]):
        pulumi.set(self, "os", value)


if not MYPY:
    class ServiceTaskSpecResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input['ServiceTaskSpecResourcesLimitsArgsDict']]
        """
        Describes the resources which can be advertised by a node and requested by a task
        """
        reservation: NotRequired[pulumi.Input['ServiceTaskSpecResourcesReservationArgsDict']]
        """
        An object describing the resources which can be advertised by a node and requested by a task
        """
elif False:
    ServiceTaskSpecResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input['ServiceTaskSpecResourcesLimitsArgs']] = None,
                 reservation: Optional[pulumi.Input['ServiceTaskSpecResourcesReservationArgs']] = None):
        """
        :param pulumi.Input['ServiceTaskSpecResourcesLimitsArgs'] limits: Describes the resources which can be advertised by a node and requested by a task
        :param pulumi.Input['ServiceTaskSpecResourcesReservationArgs'] reservation: An object describing the resources which can be advertised by a node and requested by a task
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if reservation is not None:
            pulumi.set(__self__, "reservation", reservation)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['ServiceTaskSpecResourcesLimitsArgs']]:
        """
        Describes the resources which can be advertised by a node and requested by a task
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['ServiceTaskSpecResourcesLimitsArgs']]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def reservation(self) -> Optional[pulumi.Input['ServiceTaskSpecResourcesReservationArgs']]:
        """
        An object describing the resources which can be advertised by a node and requested by a task
        """
        return pulumi.get(self, "reservation")

    @reservation.setter
    def reservation(self, value: Optional[pulumi.Input['ServiceTaskSpecResourcesReservationArgs']]):
        pulumi.set(self, "reservation", value)


if not MYPY:
    class ServiceTaskSpecResourcesLimitsArgsDict(TypedDict):
        memory_bytes: NotRequired[pulumi.Input[int]]
        """
        The amounf of memory in bytes the container allocates
        """
        nano_cpus: NotRequired[pulumi.Input[int]]
        """
        CPU shares in units of `1/1e9` (or `10^-9`) of the CPU. Should be at least `1000000`
        """
elif False:
    ServiceTaskSpecResourcesLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecResourcesLimitsArgs:
    def __init__(__self__, *,
                 memory_bytes: Optional[pulumi.Input[int]] = None,
                 nano_cpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] memory_bytes: The amounf of memory in bytes the container allocates
        :param pulumi.Input[int] nano_cpus: CPU shares in units of `1/1e9` (or `10^-9`) of the CPU. Should be at least `1000000`
        """
        if memory_bytes is not None:
            pulumi.set(__self__, "memory_bytes", memory_bytes)
        if nano_cpus is not None:
            pulumi.set(__self__, "nano_cpus", nano_cpus)

    @property
    @pulumi.getter(name="memoryBytes")
    def memory_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The amounf of memory in bytes the container allocates
        """
        return pulumi.get(self, "memory_bytes")

    @memory_bytes.setter
    def memory_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_bytes", value)

    @property
    @pulumi.getter(name="nanoCpus")
    def nano_cpus(self) -> Optional[pulumi.Input[int]]:
        """
        CPU shares in units of `1/1e9` (or `10^-9`) of the CPU. Should be at least `1000000`
        """
        return pulumi.get(self, "nano_cpus")

    @nano_cpus.setter
    def nano_cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nano_cpus", value)


if not MYPY:
    class ServiceTaskSpecResourcesReservationArgsDict(TypedDict):
        generic_resources: NotRequired[pulumi.Input['ServiceTaskSpecResourcesReservationGenericResourcesArgsDict']]
        """
        User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, GPU=UUID1)
        """
        memory_bytes: NotRequired[pulumi.Input[int]]
        """
        The amounf of memory in bytes the container allocates
        """
        nano_cpus: NotRequired[pulumi.Input[int]]
        """
        CPU shares in units of 1/1e9 (or 10^-9) of the CPU. Should be at least `1000000`
        """
elif False:
    ServiceTaskSpecResourcesReservationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecResourcesReservationArgs:
    def __init__(__self__, *,
                 generic_resources: Optional[pulumi.Input['ServiceTaskSpecResourcesReservationGenericResourcesArgs']] = None,
                 memory_bytes: Optional[pulumi.Input[int]] = None,
                 nano_cpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ServiceTaskSpecResourcesReservationGenericResourcesArgs'] generic_resources: User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, GPU=UUID1)
        :param pulumi.Input[int] memory_bytes: The amounf of memory in bytes the container allocates
        :param pulumi.Input[int] nano_cpus: CPU shares in units of 1/1e9 (or 10^-9) of the CPU. Should be at least `1000000`
        """
        if generic_resources is not None:
            pulumi.set(__self__, "generic_resources", generic_resources)
        if memory_bytes is not None:
            pulumi.set(__self__, "memory_bytes", memory_bytes)
        if nano_cpus is not None:
            pulumi.set(__self__, "nano_cpus", nano_cpus)

    @property
    @pulumi.getter(name="genericResources")
    def generic_resources(self) -> Optional[pulumi.Input['ServiceTaskSpecResourcesReservationGenericResourcesArgs']]:
        """
        User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, GPU=UUID1)
        """
        return pulumi.get(self, "generic_resources")

    @generic_resources.setter
    def generic_resources(self, value: Optional[pulumi.Input['ServiceTaskSpecResourcesReservationGenericResourcesArgs']]):
        pulumi.set(self, "generic_resources", value)

    @property
    @pulumi.getter(name="memoryBytes")
    def memory_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The amounf of memory in bytes the container allocates
        """
        return pulumi.get(self, "memory_bytes")

    @memory_bytes.setter
    def memory_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_bytes", value)

    @property
    @pulumi.getter(name="nanoCpus")
    def nano_cpus(self) -> Optional[pulumi.Input[int]]:
        """
        CPU shares in units of 1/1e9 (or 10^-9) of the CPU. Should be at least `1000000`
        """
        return pulumi.get(self, "nano_cpus")

    @nano_cpus.setter
    def nano_cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nano_cpus", value)


if not MYPY:
    class ServiceTaskSpecResourcesReservationGenericResourcesArgsDict(TypedDict):
        discrete_resources_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The Integer resources
        """
        named_resources_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The String resources
        """
elif False:
    ServiceTaskSpecResourcesReservationGenericResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecResourcesReservationGenericResourcesArgs:
    def __init__(__self__, *,
                 discrete_resources_specs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 named_resources_specs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] discrete_resources_specs: The Integer resources
        :param pulumi.Input[Sequence[pulumi.Input[str]]] named_resources_specs: The String resources
        """
        if discrete_resources_specs is not None:
            pulumi.set(__self__, "discrete_resources_specs", discrete_resources_specs)
        if named_resources_specs is not None:
            pulumi.set(__self__, "named_resources_specs", named_resources_specs)

    @property
    @pulumi.getter(name="discreteResourcesSpecs")
    def discrete_resources_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Integer resources
        """
        return pulumi.get(self, "discrete_resources_specs")

    @discrete_resources_specs.setter
    def discrete_resources_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "discrete_resources_specs", value)

    @property
    @pulumi.getter(name="namedResourcesSpecs")
    def named_resources_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The String resources
        """
        return pulumi.get(self, "named_resources_specs")

    @named_resources_specs.setter
    def named_resources_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "named_resources_specs", value)


if not MYPY:
    class ServiceTaskSpecRestartPolicyArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        Condition for restart
        """
        delay: NotRequired[pulumi.Input[str]]
        """
        Delay between restart attempts (ms|s|m|h)
        """
        max_attempts: NotRequired[pulumi.Input[int]]
        """
        Maximum attempts to restart a given container before giving up (default value is `0`, which is ignored)
        """
        window: NotRequired[pulumi.Input[str]]
        """
        The time window used to evaluate the restart policy (default value is `0`, which is unbounded) (ms|s|m|h)
        """
elif False:
    ServiceTaskSpecRestartPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTaskSpecRestartPolicyArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 delay: Optional[pulumi.Input[str]] = None,
                 max_attempts: Optional[pulumi.Input[int]] = None,
                 window: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: Condition for restart
        :param pulumi.Input[str] delay: Delay between restart attempts (ms|s|m|h)
        :param pulumi.Input[int] max_attempts: Maximum attempts to restart a given container before giving up (default value is `0`, which is ignored)
        :param pulumi.Input[str] window: The time window used to evaluate the restart policy (default value is `0`, which is unbounded) (ms|s|m|h)
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        Condition for restart
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[str]]:
        """
        Delay between restart attempts (ms|s|m|h)
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum attempts to restart a given container before giving up (default value is `0`, which is ignored)
        """
        return pulumi.get(self, "max_attempts")

    @max_attempts.setter
    def max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_attempts", value)

    @property
    @pulumi.getter
    def window(self) -> Optional[pulumi.Input[str]]:
        """
        The time window used to evaluate the restart policy (default value is `0`, which is unbounded) (ms|s|m|h)
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "window", value)


if not MYPY:
    class ServiceUpdateConfigArgsDict(TypedDict):
        delay: NotRequired[pulumi.Input[str]]
        """
        Delay between task updates `(ns|us|ms|s|m|h)`. Defaults to `0s`.
        """
        failure_action: NotRequired[pulumi.Input[str]]
        """
        Action on update failure: `pause`, `continue` or `rollback`. Defaults to `pause`.
        """
        max_failure_ratio: NotRequired[pulumi.Input[str]]
        """
        Failure rate to tolerate during an update. Defaults to `0.0`.
        """
        monitor: NotRequired[pulumi.Input[str]]
        """
        Duration after each task update to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.
        """
        order: NotRequired[pulumi.Input[str]]
        """
        Update order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.
        """
        parallelism: NotRequired[pulumi.Input[int]]
        """
        Maximum number of tasks to be updated in one iteration. Defaults to `1`
        """
elif False:
    ServiceUpdateConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceUpdateConfigArgs:
    def __init__(__self__, *,
                 delay: Optional[pulumi.Input[str]] = None,
                 failure_action: Optional[pulumi.Input[str]] = None,
                 max_failure_ratio: Optional[pulumi.Input[str]] = None,
                 monitor: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None,
                 parallelism: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delay: Delay between task updates `(ns|us|ms|s|m|h)`. Defaults to `0s`.
        :param pulumi.Input[str] failure_action: Action on update failure: `pause`, `continue` or `rollback`. Defaults to `pause`.
        :param pulumi.Input[str] max_failure_ratio: Failure rate to tolerate during an update. Defaults to `0.0`.
        :param pulumi.Input[str] monitor: Duration after each task update to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.
        :param pulumi.Input[str] order: Update order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.
        :param pulumi.Input[int] parallelism: Maximum number of tasks to be updated in one iteration. Defaults to `1`
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if failure_action is not None:
            pulumi.set(__self__, "failure_action", failure_action)
        if max_failure_ratio is not None:
            pulumi.set(__self__, "max_failure_ratio", max_failure_ratio)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)

    @property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[str]]:
        """
        Delay between task updates `(ns|us|ms|s|m|h)`. Defaults to `0s`.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter(name="failureAction")
    def failure_action(self) -> Optional[pulumi.Input[str]]:
        """
        Action on update failure: `pause`, `continue` or `rollback`. Defaults to `pause`.
        """
        return pulumi.get(self, "failure_action")

    @failure_action.setter
    def failure_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_action", value)

    @property
    @pulumi.getter(name="maxFailureRatio")
    def max_failure_ratio(self) -> Optional[pulumi.Input[str]]:
        """
        Failure rate to tolerate during an update. Defaults to `0.0`.
        """
        return pulumi.get(self, "max_failure_ratio")

    @max_failure_ratio.setter
    def max_failure_ratio(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_failure_ratio", value)

    @property
    @pulumi.getter
    def monitor(self) -> Optional[pulumi.Input[str]]:
        """
        Duration after each task update to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.
        """
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitor", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Update order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of tasks to be updated in one iteration. Defaults to `1`
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelism", value)


if not MYPY:
    class VolumeLabelArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        Name of the label
        """
        value: pulumi.Input[str]
        """
        Value of the label
        """
elif False:
    VolumeLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeLabelArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: Name of the label
        :param pulumi.Input[str] value: Value of the label
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Name of the label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CacheFromArgsDict(TypedDict):
        """
        Contains a list of images to reference when building using a cache
        """
        images: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies cached images
        """
elif False:
    CacheFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheFromArgs:
    def __init__(__self__, *,
                 images: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Contains a list of images to reference when building using a cache
        :param pulumi.Input[Sequence[pulumi.Input[str]]] images: Specifies cached images
        """
        if images is not None:
            pulumi.set(__self__, "images", images)

    @property
    @pulumi.getter
    def images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies cached images
        """
        return pulumi.get(self, "images")

    @images.setter
    def images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "images", value)


if not MYPY:
    class DockerBuildArgsDict(TypedDict):
        """
        The Docker build context
        """
        add_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Custom host-to-IP mappings to use while building (format: "host:ip")
        """
        args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        An optional map of named build-time argument variables to set during the Docker build. This flag allows you to pass build-time variables that can be accessed like environment variables inside the RUN instruction.
        """
        builder_version: NotRequired[pulumi.Input['BuilderVersion']]
        """
        The version of the Docker builder.
        """
        cache_from: NotRequired[pulumi.Input['CacheFromArgsDict']]
        """
        A list of image names to use as build cache. Images provided must have a cache manifest. Must provide authentication to cache registry.
        """
        context: NotRequired[pulumi.Input[str]]
        """
        The path to the build context to use.
        """
        dockerfile: NotRequired[pulumi.Input[str]]
        """
        The path to the Dockerfile to use.
        """
        network: NotRequired[pulumi.Input[str]]
        """
        Set the networking mode for RUN instructions
        """
        platform: NotRequired[pulumi.Input[str]]
        """
        The architecture of the platform you want to build this image for, e.g. `linux/arm64`.
        """
        target: NotRequired[pulumi.Input[str]]
        """
        The target of the Dockerfile to build
        """
elif False:
    DockerBuildArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DockerBuildArgs:
    def __init__(__self__, *,
                 add_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 builder_version: Optional[pulumi.Input['BuilderVersion']] = None,
                 cache_from: Optional[pulumi.Input['CacheFromArgs']] = None,
                 context: Optional[pulumi.Input[str]] = None,
                 dockerfile: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 platform: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        The Docker build context
        :param pulumi.Input[Sequence[pulumi.Input[str]]] add_hosts: Custom host-to-IP mappings to use while building (format: "host:ip")
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] args: An optional map of named build-time argument variables to set during the Docker build. This flag allows you to pass build-time variables that can be accessed like environment variables inside the RUN instruction.
        :param pulumi.Input['BuilderVersion'] builder_version: The version of the Docker builder.
        :param pulumi.Input['CacheFromArgs'] cache_from: A list of image names to use as build cache. Images provided must have a cache manifest. Must provide authentication to cache registry.
        :param pulumi.Input[str] context: The path to the build context to use.
        :param pulumi.Input[str] dockerfile: The path to the Dockerfile to use.
        :param pulumi.Input[str] network: Set the networking mode for RUN instructions
        :param pulumi.Input[str] platform: The architecture of the platform you want to build this image for, e.g. `linux/arm64`.
        :param pulumi.Input[str] target: The target of the Dockerfile to build
        """
        if add_hosts is not None:
            pulumi.set(__self__, "add_hosts", add_hosts)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if builder_version is not None:
            pulumi.set(__self__, "builder_version", builder_version)
        if cache_from is not None:
            pulumi.set(__self__, "cache_from", cache_from)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if dockerfile is not None:
            pulumi.set(__self__, "dockerfile", dockerfile)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="addHosts")
    def add_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Custom host-to-IP mappings to use while building (format: "host:ip")
        """
        return pulumi.get(self, "add_hosts")

    @add_hosts.setter
    def add_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add_hosts", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        An optional map of named build-time argument variables to set during the Docker build. This flag allows you to pass build-time variables that can be accessed like environment variables inside the RUN instruction.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="builderVersion")
    def builder_version(self) -> Optional[pulumi.Input['BuilderVersion']]:
        """
        The version of the Docker builder.
        """
        return pulumi.get(self, "builder_version")

    @builder_version.setter
    def builder_version(self, value: Optional[pulumi.Input['BuilderVersion']]):
        pulumi.set(self, "builder_version", value)

    @property
    @pulumi.getter(name="cacheFrom")
    def cache_from(self) -> Optional[pulumi.Input['CacheFromArgs']]:
        """
        A list of image names to use as build cache. Images provided must have a cache manifest. Must provide authentication to cache registry.
        """
        return pulumi.get(self, "cache_from")

    @cache_from.setter
    def cache_from(self, value: Optional[pulumi.Input['CacheFromArgs']]):
        pulumi.set(self, "cache_from", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the build context to use.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter
    def dockerfile(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the Dockerfile to use.
        """
        return pulumi.get(self, "dockerfile")

    @dockerfile.setter
    def dockerfile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dockerfile", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        Set the networking mode for RUN instructions
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        The architecture of the platform you want to build this image for, e.g. `linux/arm64`.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The target of the Dockerfile to build
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class RegistryArgsDict(TypedDict):
        """
        Describes a Docker container registry
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password to authenticate to the registry. Does not cause image rebuild when changed.
        """
        server: NotRequired[pulumi.Input[str]]
        """
        The URL of the Docker registry server
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username to authenticate to the registry. Does not cause image rebuild when changed.
        """
elif False:
    RegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Describes a Docker container registry
        :param pulumi.Input[str] password: The password to authenticate to the registry. Does not cause image rebuild when changed.
        :param pulumi.Input[str] server: The URL of the Docker registry server
        :param pulumi.Input[str] username: The username to authenticate to the registry. Does not cause image rebuild when changed.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to authenticate to the registry. Does not cause image rebuild when changed.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Docker registry server
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username to authenticate to the registry. Does not cause image rebuild when changed.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


