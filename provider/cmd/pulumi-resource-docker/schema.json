{
    "name": "docker",
    "description": "A Pulumi package for interacting with Docker in Pulumi programs",
    "keywords": [
        "pulumi",
        "docker"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`docker` Terraform Provider](https://github.com/kreuzwerker/terraform-provider-docker).",
    "repository": "https://github.com/pulumi/pulumi-docker",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "docker": "Docker"
            },
            "compatibility": "tfbridge20"
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-docker/sdk/v4/go/docker",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for interacting with Docker in Pulumi programs",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/kreuzwerker/terraform-provider-docker)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-docker` repo](https://github.com/pulumi/pulumi-docker/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-docker` repo](https://github.com/kreuzwerker/terraform-provider-docker/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0",
                "semver": "^5.4.0"
            },
            "devDependencies": {
                "@types/node": "^10.0.0",
                "@types/semver": "^5.4.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/kreuzwerker/terraform-provider-docker)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-docker` repo](https://github.com/pulumi/pulumi-docker/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-docker` repo](https://github.com/kreuzwerker/terraform-provider-docker/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "caMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker host CA certificate.\n"
            },
            "certMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker client certificate.\n"
            },
            "certPath": {
                "type": "string",
                "description": "Path to a directory with Docker TLS config. This directory is expected to contain `ca.pem`, `cert.pem`, and `key.pem`\nfiles.\n"
            },
            "host": {
                "type": "string",
                "description": "The Docker daemon's address.\n",
                "defaultInfo": {
                    "environment": [
                        "DOCKER_HOST"
                    ]
                }
            },
            "keyMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker client private key.\n"
            },
            "registryAuth": {
                "type": "array",
                "items": {
                    "$ref": "#/types/docker:config/registryAuth:registryAuth"
                }
            },
            "sshOpts": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "description": "Additional SSH option flags to be appended when using `ssh://` protocol. The `ssh://` protocol is not supported for\n`buildx.Image` resources. Instead, use a [remote](https://docs.docker.com/build/drivers/remote/) driver.\n"
            }
        },
        "defaults": [
            "host"
        ]
    },
    "types": {
        "docker:buildx/image:BuildContext": {
            "properties": {
                "location": {
                    "type": "string",
                    "description": "Resources to use for build context.\n\nThe location can be:\n* A relative or absolute path to a local directory (`.`, `./app`,\n  `/app`, etc.).\n* A remote URL of a Git repository, tarball, or plain text file\n  (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,\n  etc.)."
                },
                "named": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/types/docker:buildx/image:Context"
                    },
                    "description": "Additional build contexts to use. \n\nThese contexts are accessed with `FROM name` or `--from=name`\nstatements when using Dockerfile 1.4+ syntax.\n\nValues can be local paths, HTTP URLs, or  `docker-image://` images."
                }
            },
            "type": "object",
            "required": [
                "location"
            ]
        },
        "docker:buildx/image:BuilderConfig": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of an existing buildx builder to use.\n\nOnly `docker-container`, `kubernetes`, or `remote` drivers are\nsupported. The legacy `docker` driver is not supported.\n\nEquivalent to Docker's `--builder` flag."
                }
            },
            "type": "object"
        },
        "docker:buildx/image:CacheFromAzureBlob": {
            "properties": {
                "accountUrl": {
                    "type": "string",
                    "description": "Base URL of the storage account."
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cache image."
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "Blob storage account key.",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "docker:buildx/image:CacheFromEntry": {
            "properties": {
                "azblob": {
                    "$ref": "#/types/docker:buildx/image:CacheFromAzureBlob",
                    "description": "Upload build caches to Azure's blob storage service."
                },
                "disabled": {
                    "type": "boolean",
                    "description": "When `true` this entry will be excluded. Defaults to `false`."
                },
                "gha": {
                    "$ref": "#/types/docker:buildx/image:CacheFromGitHubActions",
                    "description": "Recommended for use with GitHub Actions workflows.\n\nAn action like `crazy-max/ghaction-github-runtime` is recommended to\nexpose appropriate credentials to your GitHub workflow."
                },
                "local": {
                    "$ref": "#/types/docker:buildx/image:CacheFromLocal",
                    "description": "A simple backend which caches images on your local filesystem."
                },
                "raw": {
                    "type": "string",
                    "description": "A raw string as you would provide it to the Docker CLI (e.g.,\n`type=inline`)."
                },
                "registry": {
                    "$ref": "#/types/docker:buildx/image:CacheFromRegistry",
                    "description": "Upload build caches to remote registries."
                },
                "s3": {
                    "$ref": "#/types/docker:buildx/image:CacheFromS3",
                    "description": "Upload build caches to AWS S3 or an S3-compatible services such as\nMinIO."
                }
            },
            "type": "object"
        },
        "docker:buildx/image:CacheFromGitHubActions": {
            "properties": {
                "scope": {
                    "type": "string",
                    "description": "The scope to use for cache keys. Defaults to `buildkit`.\n\nThis should be set if building and caching multiple images in one\nworkflow, otherwise caches will overwrite each other.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "buildkit"
                        ]
                    }
                },
                "token": {
                    "type": "string",
                    "description": "The GitHub Actions token to use. This is not a personal access tokens\nand is typically generated automatically as part of each job.\n\nDefaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "ACTIONS_RUNTIME_TOKEN"
                        ]
                    },
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The cache server URL to use for artifacts.\n\nDefaults to `$ACTIONS_RUNTIME_URL`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "ACTIONS_RUNTIME_URL"
                        ]
                    }
                }
            },
            "type": "object"
        },
        "docker:buildx/image:CacheFromLocal": {
            "properties": {
                "digest": {
                    "type": "string",
                    "description": "Digest of manifest to import."
                },
                "src": {
                    "type": "string",
                    "description": "Path of the local directory where cache gets imported from."
                }
            },
            "type": "object",
            "required": [
                "src"
            ]
        },
        "docker:buildx/image:CacheFromRegistry": {
            "properties": {
                "ref": {
                    "type": "string",
                    "description": "Fully qualified name of the cache image to import."
                }
            },
            "type": "object",
            "required": [
                "ref"
            ]
        },
        "docker:buildx/image:CacheFromS3": {
            "properties": {
                "accessKeyId": {
                    "type": "string",
                    "description": "Defaults to `$AWS_ACCESS_KEY_ID`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_ACCESS_KEY_ID"
                        ]
                    }
                },
                "blobsPrefix": {
                    "type": "string",
                    "description": "Prefix to prepend to blob filenames."
                },
                "bucket": {
                    "type": "string",
                    "description": "Name of the S3 bucket."
                },
                "endpointUrl": {
                    "type": "string",
                    "description": "Endpoint of the S3 bucket."
                },
                "manifestsPrefix": {
                    "type": "string",
                    "description": "Prefix to prepend on manifest filenames."
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cache image."
                },
                "region": {
                    "type": "string",
                    "description": "The geographic location of the bucket. Defaults to `$AWS_REGION`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_REGION"
                        ]
                    }
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "Defaults to `$AWS_SECRET_ACCESS_KEY`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_SECRET_ACCESS_KEY"
                        ]
                    },
                    "secret": true
                },
                "sessionToken": {
                    "type": "string",
                    "description": "Defaults to `$AWS_SESSION_TOKEN`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_SESSION_TOKEN"
                        ]
                    },
                    "secret": true
                },
                "usePathStyle": {
                    "type": "boolean",
                    "description": "Uses `bucket` in the URL instead of hostname when `true`."
                }
            },
            "type": "object",
            "required": [
                "region",
                "bucket"
            ]
        },
        "docker:buildx/image:CacheMode": {
            "type": "string",
            "enum": [
                {
                    "description": "Only layers that are exported into the resulting image are cached.",
                    "value": "min"
                },
                {
                    "description": "All layers are cached, even those of intermediate steps.",
                    "value": "max"
                }
            ]
        },
        "docker:buildx/image:CacheToAzureBlob": {
            "properties": {
                "accountUrl": {
                    "type": "string",
                    "description": "Base URL of the storage account."
                },
                "ignoreError": {
                    "type": "boolean",
                    "description": "Ignore errors caused by failed cache exports.",
                    "default": false
                },
                "mode": {
                    "$ref": "#/types/docker:buildx/image:CacheMode",
                    "description": "The cache mode to use. Defaults to `min`.",
                    "default": "min"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cache image."
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "Blob storage account key.",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "docker:buildx/image:CacheToEntry": {
            "properties": {
                "azblob": {
                    "$ref": "#/types/docker:buildx/image:CacheToAzureBlob",
                    "description": "Push cache to Azure's blob storage service."
                },
                "disabled": {
                    "type": "boolean",
                    "description": "When `true` this entry will be excluded. Defaults to `false`."
                },
                "gha": {
                    "$ref": "#/types/docker:buildx/image:CacheToGitHubActions",
                    "description": "Recommended for use with GitHub Actions workflows.\n\nAn action like `crazy-max/ghaction-github-runtime` is recommended to\nexpose appropriate credentials to your GitHub workflow."
                },
                "inline": {
                    "$ref": "#/types/docker:buildx/image:CacheToInline",
                    "description": "The inline cache storage backend is the simplest implementation to get\nstarted with, but it does not handle multi-stage builds. Consider the\n`registry` cache backend instead."
                },
                "local": {
                    "$ref": "#/types/docker:buildx/image:CacheToLocal",
                    "description": "A simple backend which caches imagines on your local filesystem."
                },
                "raw": {
                    "type": "string",
                    "description": "A raw string as you would provide it to the Docker CLI (e.g.,\n`type=inline`)"
                },
                "registry": {
                    "$ref": "#/types/docker:buildx/image:CacheToRegistry",
                    "description": "Push caches to remote registries. Incompatible with the `docker` build\ndriver."
                },
                "s3": {
                    "$ref": "#/types/docker:buildx/image:CacheToS3",
                    "description": "Push cache to AWS S3 or S3-compatible services such as MinIO."
                }
            },
            "type": "object"
        },
        "docker:buildx/image:CacheToGitHubActions": {
            "properties": {
                "ignoreError": {
                    "type": "boolean",
                    "description": "Ignore errors caused by failed cache exports.",
                    "default": false
                },
                "mode": {
                    "$ref": "#/types/docker:buildx/image:CacheMode",
                    "description": "The cache mode to use. Defaults to `min`.",
                    "default": "min"
                },
                "scope": {
                    "type": "string",
                    "description": "The scope to use for cache keys. Defaults to `buildkit`.\n\nThis should be set if building and caching multiple images in one\nworkflow, otherwise caches will overwrite each other.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "buildkit"
                        ]
                    }
                },
                "token": {
                    "type": "string",
                    "description": "The GitHub Actions token to use. This is not a personal access tokens\nand is typically generated automatically as part of each job.\n\nDefaults to `$ACTIONS_RUNTIME_TOKEN`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "ACTIONS_RUNTIME_TOKEN"
                        ]
                    },
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The cache server URL to use for artifacts.\n\nDefaults to `$ACTIONS_RUNTIME_URL`, although a separate action like\n`crazy-max/ghaction-github-runtime` is recommended to expose this\nenvironment variable to your jobs.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "ACTIONS_RUNTIME_URL"
                        ]
                    }
                }
            },
            "type": "object"
        },
        "docker:buildx/image:CacheToInline": {
            "type": "object"
        },
        "docker:buildx/image:CacheToLocal": {
            "properties": {
                "compression": {
                    "$ref": "#/types/docker:buildx/image:CompressionType",
                    "description": "The compression type to use.",
                    "default": "gzip"
                },
                "compressionLevel": {
                    "type": "integer",
                    "description": "Compression level from 0 to 22.",
                    "default": 0
                },
                "dest": {
                    "type": "string",
                    "description": "Path of the local directory to export the cache."
                },
                "forceCompression": {
                    "type": "boolean",
                    "description": "Forcefully apply compression.",
                    "default": false
                },
                "ignoreError": {
                    "type": "boolean",
                    "description": "Ignore errors caused by failed cache exports.",
                    "default": false
                },
                "mode": {
                    "$ref": "#/types/docker:buildx/image:CacheMode",
                    "description": "The cache mode to use. Defaults to `min`.",
                    "default": "min"
                }
            },
            "type": "object",
            "required": [
                "dest"
            ]
        },
        "docker:buildx/image:CacheToRegistry": {
            "properties": {
                "compression": {
                    "$ref": "#/types/docker:buildx/image:CompressionType",
                    "description": "The compression type to use.",
                    "default": "gzip"
                },
                "compressionLevel": {
                    "type": "integer",
                    "description": "Compression level from 0 to 22.",
                    "default": 0
                },
                "forceCompression": {
                    "type": "boolean",
                    "description": "Forcefully apply compression.",
                    "default": false
                },
                "ignoreError": {
                    "type": "boolean",
                    "description": "Ignore errors caused by failed cache exports.",
                    "default": false
                },
                "imageManifest": {
                    "type": "boolean",
                    "description": "Export cache manifest as an OCI-compatible image manifest instead of a\nmanifest list (requires OCI media types).\n\nDefaults to `false`.",
                    "default": false
                },
                "mode": {
                    "$ref": "#/types/docker:buildx/image:CacheMode",
                    "description": "The cache mode to use. Defaults to `min`.",
                    "default": "min"
                },
                "ociMediaTypes": {
                    "type": "boolean",
                    "description": "Whether to use OCI media types in exported manifests. Defaults to\n`true`.",
                    "default": true
                },
                "ref": {
                    "type": "string",
                    "description": "Fully qualified name of the cache image to import."
                }
            },
            "type": "object",
            "required": [
                "ref"
            ]
        },
        "docker:buildx/image:CacheToS3": {
            "properties": {
                "accessKeyId": {
                    "type": "string",
                    "description": "Defaults to `$AWS_ACCESS_KEY_ID`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_ACCESS_KEY_ID"
                        ]
                    }
                },
                "blobsPrefix": {
                    "type": "string",
                    "description": "Prefix to prepend to blob filenames."
                },
                "bucket": {
                    "type": "string",
                    "description": "Name of the S3 bucket."
                },
                "endpointUrl": {
                    "type": "string",
                    "description": "Endpoint of the S3 bucket."
                },
                "ignoreError": {
                    "type": "boolean",
                    "description": "Ignore errors caused by failed cache exports.",
                    "default": false
                },
                "manifestsPrefix": {
                    "type": "string",
                    "description": "Prefix to prepend on manifest filenames."
                },
                "mode": {
                    "$ref": "#/types/docker:buildx/image:CacheMode",
                    "description": "The cache mode to use. Defaults to `min`.",
                    "default": "min"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cache image."
                },
                "region": {
                    "type": "string",
                    "description": "The geographic location of the bucket. Defaults to `$AWS_REGION`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_REGION"
                        ]
                    }
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "Defaults to `$AWS_SECRET_ACCESS_KEY`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_SECRET_ACCESS_KEY"
                        ]
                    },
                    "secret": true
                },
                "sessionToken": {
                    "type": "string",
                    "description": "Defaults to `$AWS_SESSION_TOKEN`.",
                    "default": "",
                    "defaultInfo": {
                        "environment": [
                            "AWS_SESSION_TOKEN"
                        ]
                    },
                    "secret": true
                },
                "usePathStyle": {
                    "type": "boolean",
                    "description": "Uses `bucket` in the URL instead of hostname when `true`."
                }
            },
            "type": "object",
            "required": [
                "region",
                "bucket"
            ]
        },
        "docker:buildx/image:CompressionType": {
            "type": "string",
            "enum": [
                {
                    "description": "Use `gzip` for compression.",
                    "value": "gzip"
                },
                {
                    "description": "Use `estargz` for compression.",
                    "value": "estargz"
                },
                {
                    "description": "Use `zstd` for compression.",
                    "value": "zstd"
                }
            ]
        },
        "docker:buildx/image:Context": {
            "properties": {
                "location": {
                    "type": "string",
                    "description": "Resources to use for build context.\n\nThe location can be:\n* A relative or absolute path to a local directory (`.`, `./app`,\n  `/app`, etc.).\n* A remote URL of a Git repository, tarball, or plain text file\n  (`https://github.com/user/myrepo.git`, `http://server/context.tar.gz`,\n  etc.)."
                }
            },
            "type": "object",
            "required": [
                "location"
            ]
        },
        "docker:buildx/image:Dockerfile": {
            "properties": {
                "inline": {
                    "type": "string",
                    "description": "Raw Dockerfile contents.\n\nConflicts with `location`.\n\nEquivalent to invoking Docker with `-f -`."
                },
                "location": {
                    "type": "string",
                    "description": "Location of the Dockerfile to use.\n\nCan be a relative or absolute path to a local file, or a remote URL.\n\nDefaults to `${context.location}/Dockerfile` if context is on-disk.\n\nConflicts with `inline`."
                }
            },
            "type": "object"
        },
        "docker:buildx/image:ExportDocker": {
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Attach an arbitrary key/value annotation to the image."
                },
                "compression": {
                    "$ref": "#/types/docker:buildx/image:CompressionType",
                    "description": "The compression type to use.",
                    "default": "gzip"
                },
                "compressionLevel": {
                    "type": "integer",
                    "description": "Compression level from 0 to 22.",
                    "default": 0
                },
                "dest": {
                    "type": "string",
                    "description": "The local export path."
                },
                "forceCompression": {
                    "type": "boolean",
                    "description": "Forcefully apply compression.",
                    "default": false
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify images names to export. This is overridden if tags are already specified."
                },
                "ociMediaTypes": {
                    "type": "boolean",
                    "description": "Use OCI media types in exporter manifests.",
                    "default": false
                },
                "tar": {
                    "type": "boolean",
                    "description": "Bundle the output into a tarball layout.",
                    "default": true
                }
            },
            "type": "object"
        },
        "docker:buildx/image:ExportEntry": {
            "properties": {
                "disabled": {
                    "type": "boolean",
                    "description": "When `true` this entry will be excluded. Defaults to `false`."
                },
                "docker": {
                    "$ref": "#/types/docker:buildx/image:ExportDocker",
                    "description": "Export as a Docker image layout."
                },
                "image": {
                    "$ref": "#/types/docker:buildx/image:ExportImage",
                    "description": "Outputs the build result into a container image format."
                },
                "local": {
                    "$ref": "#/types/docker:buildx/image:ExportLocal",
                    "description": "Export to a local directory as files and directories."
                },
                "oci": {
                    "$ref": "#/types/docker:buildx/image:ExportOCI",
                    "description": "Identical to the Docker exporter but uses OCI media types by default."
                },
                "raw": {
                    "type": "string",
                    "description": "A raw string as you would provide it to the Docker CLI (e.g.,\n`type=docker`)"
                },
                "registry": {
                    "$ref": "#/types/docker:buildx/image:ExportRegistry",
                    "description": "Identical to the Image exporter, but pushes by default."
                },
                "tar": {
                    "$ref": "#/types/docker:buildx/image:ExportTar",
                    "description": "Export to a local directory as a tarball."
                }
            },
            "type": "object"
        },
        "docker:buildx/image:ExportImage": {
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Attach an arbitrary key/value annotation to the image."
                },
                "compression": {
                    "$ref": "#/types/docker:buildx/image:CompressionType",
                    "description": "The compression type to use.",
                    "default": "gzip"
                },
                "compressionLevel": {
                    "type": "integer",
                    "description": "Compression level from 0 to 22.",
                    "default": 0
                },
                "danglingNamePrefix": {
                    "type": "string",
                    "description": "Name image with `prefix@\u003cdigest\u003e`, used for anonymous images."
                },
                "forceCompression": {
                    "type": "boolean",
                    "description": "Forcefully apply compression.",
                    "default": false
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Allow pushing to an insecure registry."
                },
                "nameCanonical": {
                    "type": "boolean",
                    "description": "Add additional canonical name (`name@\u003cdigest\u003e`)."
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify images names to export. This is overridden if tags are already specified."
                },
                "ociMediaTypes": {
                    "type": "boolean",
                    "description": "Use OCI media types in exporter manifests.",
                    "default": false
                },
                "push": {
                    "type": "boolean",
                    "description": "Push after creating the image."
                },
                "pushByDigest": {
                    "type": "boolean",
                    "description": "Push image without name."
                },
                "store": {
                    "type": "boolean",
                    "description": "Store resulting images to the worker's image store and ensure all of\nits blobs are in the content store.\n\nDefaults to `true`.\n\nIgnored if the worker doesn't have image store (when using OCI workers,\nfor example).",
                    "default": true
                },
                "unpack": {
                    "type": "boolean",
                    "description": "Unpack image after creation (for use with containerd). Defaults to\n`false`."
                }
            },
            "type": "object"
        },
        "docker:buildx/image:ExportLocal": {
            "properties": {
                "dest": {
                    "type": "string",
                    "description": "Output path."
                }
            },
            "type": "object",
            "required": [
                "dest"
            ]
        },
        "docker:buildx/image:ExportOCI": {
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Attach an arbitrary key/value annotation to the image."
                },
                "compression": {
                    "$ref": "#/types/docker:buildx/image:CompressionType",
                    "description": "The compression type to use.",
                    "default": "gzip"
                },
                "compressionLevel": {
                    "type": "integer",
                    "description": "Compression level from 0 to 22.",
                    "default": 0
                },
                "dest": {
                    "type": "string",
                    "description": "The local export path."
                },
                "forceCompression": {
                    "type": "boolean",
                    "description": "Forcefully apply compression.",
                    "default": false
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify images names to export. This is overridden if tags are already specified."
                },
                "ociMediaTypes": {
                    "type": "boolean",
                    "description": "Use OCI media types in exporter manifests.",
                    "default": true
                },
                "tar": {
                    "type": "boolean",
                    "description": "Bundle the output into a tarball layout.",
                    "default": true
                }
            },
            "type": "object"
        },
        "docker:buildx/image:ExportRegistry": {
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Attach an arbitrary key/value annotation to the image."
                },
                "compression": {
                    "$ref": "#/types/docker:buildx/image:CompressionType",
                    "description": "The compression type to use.",
                    "default": "gzip"
                },
                "compressionLevel": {
                    "type": "integer",
                    "description": "Compression level from 0 to 22.",
                    "default": 0
                },
                "danglingNamePrefix": {
                    "type": "string",
                    "description": "Name image with `prefix@\u003cdigest\u003e`, used for anonymous images."
                },
                "forceCompression": {
                    "type": "boolean",
                    "description": "Forcefully apply compression.",
                    "default": false
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Allow pushing to an insecure registry."
                },
                "nameCanonical": {
                    "type": "boolean",
                    "description": "Add additional canonical name (`name@\u003cdigest\u003e`)."
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify images names to export. This is overridden if tags are already specified."
                },
                "ociMediaTypes": {
                    "type": "boolean",
                    "description": "Use OCI media types in exporter manifests.",
                    "default": false
                },
                "push": {
                    "type": "boolean",
                    "description": "Push after creating the image.",
                    "default": true
                },
                "pushByDigest": {
                    "type": "boolean",
                    "description": "Push image without name."
                },
                "store": {
                    "type": "boolean",
                    "description": "Store resulting images to the worker's image store and ensure all of\nits blobs are in the content store.\n\nDefaults to `true`.\n\nIgnored if the worker doesn't have image store (when using OCI workers,\nfor example).",
                    "default": true
                },
                "unpack": {
                    "type": "boolean",
                    "description": "Unpack image after creation (for use with containerd). Defaults to\n`false`."
                }
            },
            "type": "object"
        },
        "docker:buildx/image:ExportTar": {
            "properties": {
                "dest": {
                    "type": "string",
                    "description": "Output path."
                }
            },
            "type": "object",
            "required": [
                "dest"
            ]
        },
        "docker:buildx/image:NetworkMode": {
            "type": "string",
            "enum": [
                {
                    "description": "The default sandbox network mode.",
                    "value": "default"
                },
                {
                    "description": "Host network mode.",
                    "value": "host"
                },
                {
                    "description": "Disable network access.",
                    "value": "none"
                }
            ]
        },
        "docker:buildx/image:Platform": {
            "type": "string",
            "enum": [
                {
                    "value": "darwin/386"
                },
                {
                    "value": "darwin/amd64"
                },
                {
                    "value": "darwin/arm"
                },
                {
                    "value": "darwin/arm64"
                },
                {
                    "value": "dragonfly/amd64"
                },
                {
                    "value": "freebsd/386"
                },
                {
                    "value": "freebsd/amd64"
                },
                {
                    "value": "freebsd/arm"
                },
                {
                    "value": "linux/386"
                },
                {
                    "value": "linux/amd64"
                },
                {
                    "value": "linux/arm"
                },
                {
                    "value": "linux/arm64"
                },
                {
                    "value": "linux/mips64"
                },
                {
                    "value": "linux/mips64le"
                },
                {
                    "value": "linux/ppc64le"
                },
                {
                    "value": "linux/riscv64"
                },
                {
                    "value": "linux/s390x"
                },
                {
                    "value": "netbsd/386"
                },
                {
                    "value": "netbsd/amd64"
                },
                {
                    "value": "netbsd/arm"
                },
                {
                    "value": "openbsd/386"
                },
                {
                    "value": "openbsd/amd64"
                },
                {
                    "value": "openbsd/arm"
                },
                {
                    "value": "plan9/386"
                },
                {
                    "value": "plan9/amd64"
                },
                {
                    "value": "solaris/amd64"
                },
                {
                    "value": "windows/386"
                },
                {
                    "value": "windows/amd64"
                }
            ]
        },
        "docker:buildx/image:RegistryAuth": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The registry's address (e.g. \"docker.io\")."
                },
                "password": {
                    "type": "string",
                    "description": "Password or token for the registry.",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username for the registry."
                }
            },
            "type": "object",
            "required": [
                "address"
            ]
        },
        "docker:buildx/image:SSH": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Useful for distinguishing different servers that are part of the same\nbuild.\n\nA value of `default` is appropriate if only dealing with a single host."
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "SSH agent socket or private keys to expose to the build under the given\nidentifier.\n\nDefaults to `[$SSH_AUTH_SOCK]`.\n\nNote that your keys are **not** automatically added when using an\nagent. Run `ssh-add -l` locally to confirm which public keys are\nvisible to the agent; these will be exposed to your build."
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "docker:config/registryAuth:registryAuth": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Address of the registry.\n"
                },
                "authDisabled": {
                    "type": "boolean"
                },
                "configFile": {
                    "type": "string",
                    "description": "Path to docker json file for registry auth. Defaults to `~/.docker/config.json`. If `DOCKER_CONFIG` is set, the value of `DOCKER_CONFIG` is used as the path. `config_file` has predencen over all other options.\n"
                },
                "configFileContent": {
                    "type": "string",
                    "description": "Plain content of the docker json file for registry auth. `config_file_content` has precedence over username/password.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for the registry. Defaults to `DOCKER_REGISTRY_PASS` env variable if set.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username for the registry. Defaults to `DOCKER_REGISTRY_USER` env variable if set.\n"
                }
            },
            "type": "object",
            "required": [
                "address"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "docker:index/ContainerCapabilities:ContainerCapabilities": {
            "properties": {
                "adds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of linux capabilities to add.\n",
                    "willReplaceOnChanges": true
                },
                "drops": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of linux capabilities to drop.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "docker:index/ContainerDevice:ContainerDevice": {
            "properties": {
                "containerPath": {
                    "type": "string",
                    "description": "The path in the container where the device will be bound.\n",
                    "willReplaceOnChanges": true
                },
                "hostPath": {
                    "type": "string",
                    "description": "The path on the host where the device is located.\n",
                    "willReplaceOnChanges": true
                },
                "permissions": {
                    "type": "string",
                    "description": "The cgroup permissions given to the container to access the device. Defaults to `rwm`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "hostPath"
            ]
        },
        "docker:index/ContainerHealthcheck:ContainerHealthcheck": {
            "properties": {
                "interval": {
                    "type": "string",
                    "description": "Time between running the check (ms|s|m|h). Defaults to `0s`.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Consecutive failures needed to report unhealthy. Defaults to `0`.\n"
                },
                "startPeriod": {
                    "type": "string",
                    "description": "Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.\n"
                },
                "tests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Command to run to check health. For example, to run `curl -f localhost/health` set the command to be `[\"CMD\", \"curl\", \"-f\", \"localhost/health\"]`.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.\n"
                }
            },
            "type": "object",
            "required": [
                "tests"
            ]
        },
        "docker:index/ContainerHost:ContainerHost": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Hostname to add\n",
                    "willReplaceOnChanges": true
                },
                "ip": {
                    "type": "string",
                    "description": "IP address this hostname should resolve to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "host",
                "ip"
            ]
        },
        "docker:index/ContainerLabel:ContainerLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/ContainerMount:ContainerMount": {
            "properties": {
                "bindOptions": {
                    "$ref": "#/types/docker:index/ContainerMountBindOptions:ContainerMountBindOptions",
                    "description": "Optional configuration for the bind type.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Whether the mount should be read-only.\n"
                },
                "source": {
                    "type": "string",
                    "description": "Mount source (e.g. a volume name, a host path).\n"
                },
                "target": {
                    "type": "string",
                    "description": "Container path\n"
                },
                "tmpfsOptions": {
                    "$ref": "#/types/docker:index/ContainerMountTmpfsOptions:ContainerMountTmpfsOptions",
                    "description": "Optional configuration for the tmpfs type.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The mount type\n"
                },
                "volumeOptions": {
                    "$ref": "#/types/docker:index/ContainerMountVolumeOptions:ContainerMountVolumeOptions",
                    "description": "Optional configuration for the volume type.\n"
                }
            },
            "type": "object",
            "required": [
                "target",
                "type"
            ]
        },
        "docker:index/ContainerMountBindOptions:ContainerMountBindOptions": {
            "properties": {
                "propagation": {
                    "type": "string",
                    "description": "A propagation mode with the value.\n"
                }
            },
            "type": "object"
        },
        "docker:index/ContainerMountTmpfsOptions:ContainerMountTmpfsOptions": {
            "properties": {
                "mode": {
                    "type": "integer",
                    "description": "The permission mode for the tmpfs mount in an integer.\n"
                },
                "sizeBytes": {
                    "type": "integer",
                    "description": "The size for the tmpfs mount in bytes.\n"
                }
            },
            "type": "object"
        },
        "docker:index/ContainerMountVolumeOptions:ContainerMountVolumeOptions": {
            "properties": {
                "driverName": {
                    "type": "string",
                    "description": "Name of the driver to use to create the volume.\n"
                },
                "driverOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "key/value map of driver specific options.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerMountVolumeOptionsLabel:ContainerMountVolumeOptionsLabel"
                    },
                    "description": "User-defined key/value metadata.\n"
                },
                "noCopy": {
                    "type": "boolean",
                    "description": "Populate volume with data from the target.\n"
                }
            },
            "type": "object"
        },
        "docker:index/ContainerMountVolumeOptionsLabel:ContainerMountVolumeOptionsLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/ContainerNetworkData:ContainerNetworkData": {
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "The network gateway of the container.\n"
                },
                "globalIpv6Address": {
                    "type": "string",
                    "description": "The IPV6 address of the container.\n"
                },
                "globalIpv6PrefixLength": {
                    "type": "integer",
                    "description": "The IPV6 prefix length address of the container.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "The IP address of the container.\n"
                },
                "ipPrefixLength": {
                    "type": "integer",
                    "description": "The IP prefix length of the container.\n"
                },
                "ipv6Gateway": {
                    "type": "string",
                    "description": "The IPV6 gateway of the container.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of the container.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "The name of the network\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "gateway",
                        "globalIpv6Address",
                        "globalIpv6PrefixLength",
                        "ipAddress",
                        "ipPrefixLength",
                        "ipv6Gateway",
                        "macAddress",
                        "networkName"
                    ]
                }
            }
        },
        "docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced": {
            "properties": {
                "aliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network aliases of the container in the specific network.\n",
                    "willReplaceOnChanges": true
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "The IPV4 address of the container in the specific network.\n",
                    "willReplaceOnChanges": true
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "The IPV6 address of the container in the specific network.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name or id of the network to use. You can use `name` or `id` attribute from a `docker.Network` resource.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "docker:index/ContainerPort:ContainerPort": {
            "properties": {
                "external": {
                    "type": "integer",
                    "description": "Port exposed out of the container. If not given a free random port `\u003e= 32768` will be used.\n",
                    "willReplaceOnChanges": true
                },
                "internal": {
                    "type": "integer",
                    "description": "Port within the container.\n",
                    "willReplaceOnChanges": true
                },
                "ip": {
                    "type": "string",
                    "description": "IP address/mask that can access this port. Defaults to `0.0.0.0`.\n",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "description": "Protocol that can be used over this port. Defaults to `tcp`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "internal"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "external",
                        "internal"
                    ]
                }
            }
        },
        "docker:index/ContainerUlimit:ContainerUlimit": {
            "properties": {
                "hard": {
                    "type": "integer",
                    "description": "The hard limit\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ulimit\n",
                    "willReplaceOnChanges": true
                },
                "soft": {
                    "type": "integer",
                    "description": "The soft limit\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "hard",
                "name",
                "soft"
            ]
        },
        "docker:index/ContainerUpload:ContainerUpload": {
            "properties": {
                "content": {
                    "type": "string",
                    "description": "Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text. Conflicts with `content_base64` \u0026 `source`\n",
                    "willReplaceOnChanges": true
                },
                "contentBase64": {
                    "type": "string",
                    "description": "Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for larger binary content such as the result of the `base64encode` interpolation function. See here for the reason. Conflicts with `content` \u0026 `source`\n",
                    "willReplaceOnChanges": true
                },
                "executable": {
                    "type": "boolean",
                    "description": "If `true`, the file will be uploaded with user executable permission. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "file": {
                    "type": "string",
                    "description": "Path to the file in the container where is upload goes to\n",
                    "willReplaceOnChanges": true
                },
                "source": {
                    "type": "string",
                    "description": "A filename that references a file which will be uploaded as the object content. This allows for large file uploads that do not get stored in state. Conflicts with `content` \u0026 `content_base64`\n",
                    "willReplaceOnChanges": true
                },
                "sourceHash": {
                    "type": "string",
                    "description": "If using `source`, this will force an update if the file content has updated but the filename has not.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "file"
            ]
        },
        "docker:index/ContainerVolume:ContainerVolume": {
            "properties": {
                "containerPath": {
                    "type": "string",
                    "description": "The path in the container where the volume will be mounted.\n",
                    "willReplaceOnChanges": true
                },
                "fromContainer": {
                    "type": "string",
                    "description": "The container where the volume is coming from.\n",
                    "willReplaceOnChanges": true
                },
                "hostPath": {
                    "type": "string",
                    "description": "The path on the host where the volume is coming from.\n",
                    "willReplaceOnChanges": true
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "If `true`, this volume will be readonly. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "volumeName": {
                    "type": "string",
                    "description": "The name of the docker volume which should be mounted.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "docker:index/NetworkIpamConfig:NetworkIpamConfig": {
            "properties": {
                "auxAddress": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Auxiliary IPv4 or IPv6 addresses used by Network driver\n",
                    "willReplaceOnChanges": true
                },
                "gateway": {
                    "type": "string",
                    "description": "The IP address of the gateway\n",
                    "willReplaceOnChanges": true
                },
                "ipRange": {
                    "type": "string",
                    "description": "The ip range in CIDR form\n",
                    "willReplaceOnChanges": true
                },
                "subnet": {
                    "type": "string",
                    "description": "The subnet in CIDR form\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "docker:index/NetworkLabel:NetworkLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/PluginGrantPermission:PluginGrantPermission": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the permission\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The value of the permission\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "values"
            ]
        },
        "docker:index/ProviderRegistryAuth:ProviderRegistryAuth": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Address of the registry.\n"
                },
                "authDisabled": {
                    "type": "boolean"
                },
                "configFile": {
                    "type": "string",
                    "description": "Path to docker json file for registry auth. Defaults to `~/.docker/config.json`. If `DOCKER_CONFIG` is set, the value of `DOCKER_CONFIG` is used as the path. `config_file` has predencen over all other options.\n"
                },
                "configFileContent": {
                    "type": "string",
                    "description": "Plain content of the docker json file for registry auth. `config_file_content` has precedence over username/password.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for the registry. Defaults to `DOCKER_REGISTRY_PASS` env variable if set.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username for the registry. Defaults to `DOCKER_REGISTRY_USER` env variable if set.\n"
                }
            },
            "type": "object",
            "required": [
                "address"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "docker:index/RemoteImageBuild:RemoteImageBuild": {
            "properties": {
                "authConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/RemoteImageBuildAuthConfig:RemoteImageBuildAuthConfig"
                    },
                    "description": "The configuration for the authentication\n"
                },
                "buildArg": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Set build-time variables\n",
                    "willReplaceOnChanges": true
                },
                "buildArgs": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Pairs for build-time variables in the form TODO\n",
                    "willReplaceOnChanges": true
                },
                "buildId": {
                    "type": "string",
                    "description": "BuildID is an optional identifier that can be passed together with the build request. The same identifier can be used to gracefully cancel the build with the cancel request.\n",
                    "willReplaceOnChanges": true
                },
                "cacheFroms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Images to consider as cache sources\n",
                    "willReplaceOnChanges": true
                },
                "cgroupParent": {
                    "type": "string",
                    "description": "Optional parent cgroup for the container\n",
                    "willReplaceOnChanges": true
                },
                "context": {
                    "type": "string",
                    "description": "Value to specify the build context. Currently, only a `PATH` context is supported. You can use the helper function '${path.cwd}/context-dir'. Please see https://docs.docker.com/build/building/context/ for more information about build contexts.\n",
                    "willReplaceOnChanges": true
                },
                "cpuPeriod": {
                    "type": "integer",
                    "description": "The length of a CPU period in microseconds\n",
                    "willReplaceOnChanges": true
                },
                "cpuQuota": {
                    "type": "integer",
                    "description": "Microseconds of CPU time that the container can get in a CPU period\n",
                    "willReplaceOnChanges": true
                },
                "cpuSetCpus": {
                    "type": "string",
                    "description": "CPUs in which to allow execution (e.g., `0-3`, `0`, `1`)\n",
                    "willReplaceOnChanges": true
                },
                "cpuSetMems": {
                    "type": "string",
                    "description": "MEMs in which to allow execution (`0-3`, `0`, `1`)\n",
                    "willReplaceOnChanges": true
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "CPU shares (relative weight)\n",
                    "willReplaceOnChanges": true
                },
                "dockerfile": {
                    "type": "string",
                    "description": "Name of the Dockerfile. Defaults to `Dockerfile`.\n",
                    "willReplaceOnChanges": true
                },
                "extraHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of hostnames/IP mappings to add to the container’s /etc/hosts file. Specified in the form [\"hostname:IP\"]\n",
                    "willReplaceOnChanges": true
                },
                "forceRemove": {
                    "type": "boolean",
                    "description": "Always remove intermediate containers\n",
                    "willReplaceOnChanges": true
                },
                "isolation": {
                    "type": "string",
                    "description": "Isolation represents the isolation technology of a container. The supported values are\n",
                    "willReplaceOnChanges": true
                },
                "label": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Set metadata for an image\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User-defined key/value metadata\n",
                    "willReplaceOnChanges": true
                },
                "memory": {
                    "type": "integer",
                    "description": "Set memory limit for build\n",
                    "willReplaceOnChanges": true
                },
                "memorySwap": {
                    "type": "integer",
                    "description": "Total memory (memory + swap), -1 to enable unlimited swap\n",
                    "willReplaceOnChanges": true
                },
                "networkMode": {
                    "type": "string",
                    "description": "Set the networking mode for the RUN instructions during build\n",
                    "willReplaceOnChanges": true
                },
                "noCache": {
                    "type": "boolean",
                    "description": "Do not use the cache when building the image\n",
                    "willReplaceOnChanges": true
                },
                "platform": {
                    "type": "string",
                    "description": "Set platform if server is multi-platform capable\n",
                    "willReplaceOnChanges": true
                },
                "pullParent": {
                    "type": "boolean",
                    "description": "Attempt to pull the image even if an older image exists locally\n",
                    "willReplaceOnChanges": true
                },
                "remoteContext": {
                    "type": "string",
                    "description": "A Git repository URI or HTTP/HTTPS context URI\n",
                    "willReplaceOnChanges": true
                },
                "remove": {
                    "type": "boolean",
                    "description": "Remove intermediate containers after a successful build. Defaults to `true`.\n"
                },
                "securityOpts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The security options\n",
                    "willReplaceOnChanges": true
                },
                "sessionId": {
                    "type": "string",
                    "description": "Set an ID for the build session\n",
                    "willReplaceOnChanges": true
                },
                "shmSize": {
                    "type": "integer",
                    "description": "Size of /dev/shm in bytes. The size must be greater than 0\n",
                    "willReplaceOnChanges": true
                },
                "squash": {
                    "type": "boolean",
                    "description": "If true the new layers are squashed into a new image with a single new layer\n",
                    "willReplaceOnChanges": true
                },
                "suppressOutput": {
                    "type": "boolean",
                    "description": "Suppress the build output and print image ID on success\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name and optionally a tag in the 'name:tag' format\n"
                },
                "target": {
                    "type": "string",
                    "description": "Set the target build stage to build\n",
                    "willReplaceOnChanges": true
                },
                "ulimits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/RemoteImageBuildUlimit:RemoteImageBuildUlimit"
                    },
                    "description": "Configuration for ulimits\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the underlying builder to use\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "context"
            ]
        },
        "docker:index/RemoteImageBuildAuthConfig:RemoteImageBuildAuthConfig": {
            "properties": {
                "auth": {
                    "type": "string",
                    "description": "the auth token\n"
                },
                "email": {
                    "type": "string",
                    "description": "the user emal\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "hostname of the registry\n"
                },
                "identityToken": {
                    "type": "string",
                    "description": "the identity token\n"
                },
                "password": {
                    "type": "string",
                    "description": "the registry password\n"
                },
                "registryToken": {
                    "type": "string",
                    "description": "the registry token\n"
                },
                "serverAddress": {
                    "type": "string",
                    "description": "the server address\n"
                },
                "userName": {
                    "type": "string",
                    "description": "the registry user name\n"
                }
            },
            "type": "object",
            "required": [
                "hostName"
            ]
        },
        "docker:index/RemoteImageBuildUlimit:RemoteImageBuildUlimit": {
            "properties": {
                "hard": {
                    "type": "integer",
                    "description": "soft limit\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "type of ulimit, e.g. `nofile`\n",
                    "willReplaceOnChanges": true
                },
                "soft": {
                    "type": "integer",
                    "description": "hard limit\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "hard",
                "name",
                "soft"
            ]
        },
        "docker:index/SecretLabel:SecretLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/ServiceAuth:ServiceAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The password\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "serverAddress": {
                    "type": "string",
                    "description": "The address of the server for the authentication\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "The username\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "serverAddress"
            ]
        },
        "docker:index/ServiceConvergeConfig:ServiceConvergeConfig": {
            "properties": {
                "delay": {
                    "type": "string",
                    "description": "The interval to check if the desired state is reached `(ms|s)`. Defaults to `7s`.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "The timeout of the service to reach the desired state `(s|m)`. Defaults to `3m`\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceEndpointSpec:ServiceEndpointSpec": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The mode of resolution to use for internal load balancing between tasks\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceEndpointSpecPort:ServiceEndpointSpecPort"
                    },
                    "description": "List of exposed ports that this service is accessible on from the outside. Ports can only be provided if 'vip' resolution mode is used\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "mode"
                    ]
                }
            }
        },
        "docker:index/ServiceEndpointSpecPort:ServiceEndpointSpecPort": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "A random name for the port\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Rrepresents the protocol of a port: `tcp`, `udp` or `sctp`. Defaults to `tcp`.\n"
                },
                "publishMode": {
                    "type": "string",
                    "description": "Represents the mode in which the port is to be published: 'ingress' or 'host'. Defaults to `ingress`.\n"
                },
                "publishedPort": {
                    "type": "integer",
                    "description": "The port on the swarm hosts\n"
                },
                "targetPort": {
                    "type": "integer",
                    "description": "The port inside the container\n"
                }
            },
            "type": "object",
            "required": [
                "targetPort"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "publishedPort",
                        "targetPort"
                    ]
                }
            }
        },
        "docker:index/ServiceLabel:ServiceLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/ServiceMode:ServiceMode": {
            "properties": {
                "global": {
                    "type": "boolean",
                    "description": "When `true`, tasks will run on every worker node. Conflicts with `replicated`\n"
                },
                "replicated": {
                    "$ref": "#/types/docker:index/ServiceModeReplicated:ServiceModeReplicated",
                    "description": "The replicated service mode\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "replicated"
                    ]
                }
            }
        },
        "docker:index/ServiceModeReplicated:ServiceModeReplicated": {
            "properties": {
                "replicas": {
                    "type": "integer",
                    "description": "The amount of replicas of the service. Defaults to `1`\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceRollbackConfig:ServiceRollbackConfig": {
            "properties": {
                "delay": {
                    "type": "string",
                    "description": "Delay between task rollbacks (ns|us|ms|s|m|h). Defaults to `0s`.\n"
                },
                "failureAction": {
                    "type": "string",
                    "description": "Action on rollback failure: pause | continue. Defaults to `pause`.\n"
                },
                "maxFailureRatio": {
                    "type": "string",
                    "description": "Failure rate to tolerate during a rollback. Defaults to `0.0`.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "Duration after each task rollback to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.\n"
                },
                "order": {
                    "type": "string",
                    "description": "Rollback order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.\n"
                },
                "parallelism": {
                    "type": "integer",
                    "description": "Maximum number of tasks to be rollbacked in one iteration. Defaults to `1`\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpec:ServiceTaskSpec": {
            "properties": {
                "containerSpec": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpec:ServiceTaskSpecContainerSpec",
                    "description": "The spec for each container\n"
                },
                "forceUpdate": {
                    "type": "integer",
                    "description": "A counter that triggers an update even if no relevant parameters have been changed. See the [spec](https://github.com/docker/swarmkit/blob/master/api/specs.proto#L126).\n"
                },
                "logDriver": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecLogDriver:ServiceTaskSpecLogDriver",
                    "description": "Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified\n"
                },
                "networksAdvanceds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecNetworksAdvanced:ServiceTaskSpecNetworksAdvanced"
                    },
                    "description": "The networks the container is attached to\n"
                },
                "placement": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecPlacement:ServiceTaskSpecPlacement",
                    "description": "The placement preferences\n"
                },
                "resources": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecResources:ServiceTaskSpecResources",
                    "description": "Resource requirements which apply to each individual container created as part of the service\n"
                },
                "restartPolicy": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecRestartPolicy:ServiceTaskSpecRestartPolicy",
                    "description": "Specification for the restart policy which applies to containers created as part of this service.\n"
                },
                "runtime": {
                    "type": "string",
                    "description": "Runtime is the type of runtime specified for the task executor. See the [types](https://github.com/moby/moby/blob/master/api/types/swarm/runtime.go).\n"
                }
            },
            "type": "object",
            "required": [
                "containerSpec"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "containerSpec",
                        "forceUpdate",
                        "placement",
                        "resources",
                        "restartPolicy",
                        "runtime"
                    ]
                }
            }
        },
        "docker:index/ServiceTaskSpecContainerSpec:ServiceTaskSpecContainerSpec": {
            "properties": {
                "args": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Arguments to the command\n"
                },
                "commands": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The command/entrypoint to be run in the image. According to the [docker cli](https://github.com/docker/cli/blob/v20.10.7/cli/command/service/opts.go#L705) the override of the entrypoint is also passed to the `command` property and there is no `entrypoint` attribute in the `ContainerSpec` of the service.\n"
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecConfig:ServiceTaskSpecContainerSpecConfig"
                    },
                    "description": "References to zero or more configs that will be exposed to the service\n"
                },
                "dir": {
                    "type": "string",
                    "description": "The working directory for commands to run in\n"
                },
                "dnsConfig": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecDnsConfig:ServiceTaskSpecContainerSpecDnsConfig",
                    "description": "Specification for DNS related configurations in resolver configuration file (`resolv.conf`)\n"
                },
                "env": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of environment variables in the form VAR=\"value\"\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of additional groups that the container process will run as\n"
                },
                "healthcheck": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecHealthcheck:ServiceTaskSpecContainerSpecHealthcheck",
                    "description": "A test to perform to check that the container is healthy\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname to use for the container, as a valid RFC 1123 hostname\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecHost:ServiceTaskSpecContainerSpecHost"
                    },
                    "description": "A list of hostname/IP mappings to add to the container's hosts file\n",
                    "willReplaceOnChanges": true
                },
                "image": {
                    "type": "string",
                    "description": "The image name to use for the containers of the service, like `nginx:1.17.6`. Also use the data-source or resource of `docker.RemoteImage` with the `repo_digest` or `docker.RegistryImage` with the `name` attribute for this, as shown in the examples.\n"
                },
                "isolation": {
                    "type": "string",
                    "description": "Isolation technology of the containers running the service. (Windows only). Defaults to `default`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecLabel:ServiceTaskSpecContainerSpecLabel"
                    },
                    "description": "User-defined key/value metadata\n"
                },
                "mounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMount:ServiceTaskSpecContainerSpecMount"
                    },
                    "description": "Specification for mounts to be added to containers created as part of the service\n"
                },
                "privileges": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecPrivileges:ServiceTaskSpecContainerSpecPrivileges",
                    "description": "Security options for the container\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Mount the container's root filesystem as read only\n"
                },
                "secrets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecSecret:ServiceTaskSpecContainerSpecSecret"
                    },
                    "description": "References to zero or more secrets that will be exposed to the service\n"
                },
                "stopGracePeriod": {
                    "type": "string",
                    "description": "Amount of time to wait for the container to terminate before forcefully removing it (ms|s|m|h). If not specified or '0s' the destroy will not check if all tasks/containers of the service terminate.\n"
                },
                "stopSignal": {
                    "type": "string",
                    "description": "Signal to stop the container\n"
                },
                "sysctl": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Sysctls config (Linux only)\n",
                    "willReplaceOnChanges": true
                },
                "user": {
                    "type": "string",
                    "description": "The user inside the container\n"
                }
            },
            "type": "object",
            "required": [
                "image"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dnsConfig",
                        "healthcheck",
                        "image",
                        "stopGracePeriod"
                    ]
                }
            }
        },
        "docker:index/ServiceTaskSpecContainerSpecConfig:ServiceTaskSpecContainerSpecConfig": {
            "properties": {
                "configId": {
                    "type": "string",
                    "description": "ID of the specific config that we're referencing\n"
                },
                "configName": {
                    "type": "string",
                    "description": "Name of the config that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID\n"
                },
                "fileGid": {
                    "type": "string",
                    "description": "Represents the file GID. Defaults to `0`.\n"
                },
                "fileMode": {
                    "type": "integer",
                    "description": "Represents represents the FileMode of the file. Defaults to `0o444`.\n"
                },
                "fileName": {
                    "type": "string",
                    "description": "Represents the final filename in the filesystem\n"
                },
                "fileUid": {
                    "type": "string",
                    "description": "Represents the file UID. Defaults to `0`.\n"
                }
            },
            "type": "object",
            "required": [
                "configId",
                "fileName"
            ]
        },
        "docker:index/ServiceTaskSpecContainerSpecDnsConfig:ServiceTaskSpecContainerSpecDnsConfig": {
            "properties": {
                "nameservers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IP addresses of the name servers\n"
                },
                "options": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of internal resolver variables to be modified (e.g., `debug`, `ndots:3`, etc.)\n"
                },
                "searches": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A search list for host-name lookup\n"
                }
            },
            "type": "object",
            "required": [
                "nameservers"
            ]
        },
        "docker:index/ServiceTaskSpecContainerSpecHealthcheck:ServiceTaskSpecContainerSpecHealthcheck": {
            "properties": {
                "interval": {
                    "type": "string",
                    "description": "Time between running the check (ms|s|m|h). Defaults to `0s`.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Consecutive failures needed to report unhealthy. Defaults to `0`\n"
                },
                "startPeriod": {
                    "type": "string",
                    "description": "Start period for the container to initialize before counting retries towards unstable (ms|s|m|h). Defaults to `0s`.\n"
                },
                "tests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The test to perform as list\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "Maximum time to allow one check to run (ms|s|m|h). Defaults to `0s`.\n"
                }
            },
            "type": "object",
            "required": [
                "tests"
            ]
        },
        "docker:index/ServiceTaskSpecContainerSpecHost:ServiceTaskSpecContainerSpecHost": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "The name of the host\n",
                    "willReplaceOnChanges": true
                },
                "ip": {
                    "type": "string",
                    "description": "The ip of the host\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "host",
                "ip"
            ]
        },
        "docker:index/ServiceTaskSpecContainerSpecLabel:ServiceTaskSpecContainerSpecLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/ServiceTaskSpecContainerSpecMount:ServiceTaskSpecContainerSpecMount": {
            "properties": {
                "bindOptions": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountBindOptions:ServiceTaskSpecContainerSpecMountBindOptions",
                    "description": "Optional configuration for the bind type\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Whether the mount should be read-only\n"
                },
                "source": {
                    "type": "string",
                    "description": "Mount source (e.g. a volume name, a host path)\n"
                },
                "target": {
                    "type": "string",
                    "description": "Container path\n"
                },
                "tmpfsOptions": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountTmpfsOptions:ServiceTaskSpecContainerSpecMountTmpfsOptions",
                    "description": "Optional configuration for the tmpfs type\n"
                },
                "type": {
                    "type": "string",
                    "description": "The mount type\n"
                },
                "volumeOptions": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountVolumeOptions:ServiceTaskSpecContainerSpecMountVolumeOptions",
                    "description": "Optional configuration for the volume type\n"
                }
            },
            "type": "object",
            "required": [
                "target",
                "type"
            ]
        },
        "docker:index/ServiceTaskSpecContainerSpecMountBindOptions:ServiceTaskSpecContainerSpecMountBindOptions": {
            "properties": {
                "propagation": {
                    "type": "string",
                    "description": "Bind propagation refers to whether or not mounts created within a given bind-mount or named volume can be propagated to replicas of that mount. See the [docs](https://docs.docker.com/storage/bind-mounts/#configure-bind-propagation) for details. Defaults to `rprivate`\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecContainerSpecMountTmpfsOptions:ServiceTaskSpecContainerSpecMountTmpfsOptions": {
            "properties": {
                "mode": {
                    "type": "integer",
                    "description": "The permission mode for the tmpfs mount in an integer\n"
                },
                "sizeBytes": {
                    "type": "integer",
                    "description": "The size for the tmpfs mount in bytes\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecContainerSpecMountVolumeOptions:ServiceTaskSpecContainerSpecMountVolumeOptions": {
            "properties": {
                "driverName": {
                    "type": "string",
                    "description": "Name of the driver to use to create the volume\n"
                },
                "driverOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "key/value map of driver specific options\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecMountVolumeOptionsLabel:ServiceTaskSpecContainerSpecMountVolumeOptionsLabel"
                    },
                    "description": "User-defined key/value metadata\n"
                },
                "noCopy": {
                    "type": "boolean",
                    "description": "Populate volume with data from the target\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecContainerSpecMountVolumeOptionsLabel:ServiceTaskSpecContainerSpecMountVolumeOptionsLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/ServiceTaskSpecContainerSpecPrivileges:ServiceTaskSpecContainerSpecPrivileges": {
            "properties": {
                "credentialSpec": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecPrivilegesCredentialSpec:ServiceTaskSpecContainerSpecPrivilegesCredentialSpec",
                    "description": "CredentialSpec for managed service account (Windows only)\n"
                },
                "seLinuxContext": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext:ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext",
                    "description": "SELinux labels of the container\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecContainerSpecPrivilegesCredentialSpec:ServiceTaskSpecContainerSpecPrivilegesCredentialSpec": {
            "properties": {
                "file": {
                    "type": "string",
                    "description": "Load credential spec from this file\n"
                },
                "registry": {
                    "type": "string",
                    "description": "Load credential spec from this value in the Windows registry\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext:ServiceTaskSpecContainerSpecPrivilegesSeLinuxContext": {
            "properties": {
                "disable": {
                    "type": "boolean",
                    "description": "Disable SELinux\n"
                },
                "level": {
                    "type": "string",
                    "description": "SELinux level label\n"
                },
                "role": {
                    "type": "string",
                    "description": "SELinux role label\n"
                },
                "type": {
                    "type": "string",
                    "description": "SELinux type label\n"
                },
                "user": {
                    "type": "string",
                    "description": "SELinux user label\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecContainerSpecSecret:ServiceTaskSpecContainerSpecSecret": {
            "properties": {
                "fileGid": {
                    "type": "string",
                    "description": "Represents the file GID. Defaults to `0`\n"
                },
                "fileMode": {
                    "type": "integer",
                    "description": "Represents represents the FileMode of the file. Defaults to `0o444`\n"
                },
                "fileName": {
                    "type": "string",
                    "description": "Represents the final filename in the filesystem\n"
                },
                "fileUid": {
                    "type": "string",
                    "description": "Represents the file UID. Defaults to `0`\n"
                },
                "secretId": {
                    "type": "string",
                    "description": "ID of the specific secret that we're referencing\n"
                },
                "secretName": {
                    "type": "string",
                    "description": "Name of the secret that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID\n"
                }
            },
            "type": "object",
            "required": [
                "fileName",
                "secretId"
            ]
        },
        "docker:index/ServiceTaskSpecLogDriver:ServiceTaskSpecLogDriver": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The logging driver to use\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The options for the logging driver\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "docker:index/ServiceTaskSpecNetworksAdvanced:ServiceTaskSpecNetworksAdvanced": {
            "properties": {
                "aliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network aliases of the container in the specific network.\n",
                    "willReplaceOnChanges": true
                },
                "driverOpts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of driver options for the network, e.g. `opts1=value`\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name/id of the network.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "docker:index/ServiceTaskSpecPlacement:ServiceTaskSpecPlacement": {
            "properties": {
                "constraints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of constraints. e.g.: `node.role==manager`\n"
                },
                "maxReplicas": {
                    "type": "integer",
                    "description": "Maximum number of replicas for per node (default value is `0`, which is unlimited)\n"
                },
                "platforms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceTaskSpecPlacementPlatform:ServiceTaskSpecPlacementPlatform"
                    },
                    "description": "Platforms stores all the platforms that the service's image can run on\n"
                },
                "prefs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence, e.g.: `spread=node.role.manager`\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecPlacementPlatform:ServiceTaskSpecPlacementPlatform": {
            "properties": {
                "architecture": {
                    "type": "string",
                    "description": "The architecture, e.g. `amd64`\n"
                },
                "os": {
                    "type": "string",
                    "description": "The operation system, e.g. `linux`\n"
                }
            },
            "type": "object",
            "required": [
                "architecture",
                "os"
            ]
        },
        "docker:index/ServiceTaskSpecResources:ServiceTaskSpecResources": {
            "properties": {
                "limits": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecResourcesLimits:ServiceTaskSpecResourcesLimits",
                    "description": "Describes the resources which can be advertised by a node and requested by a task\n"
                },
                "reservation": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecResourcesReservation:ServiceTaskSpecResourcesReservation",
                    "description": "An object describing the resources which can be advertised by a node and requested by a task\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecResourcesLimits:ServiceTaskSpecResourcesLimits": {
            "properties": {
                "memoryBytes": {
                    "type": "integer",
                    "description": "The amounf of memory in bytes the container allocates\n"
                },
                "nanoCpus": {
                    "type": "integer",
                    "description": "CPU shares in units of `1/1e9` (or `10^-9`) of the CPU. Should be at least `1000000`\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecResourcesReservation:ServiceTaskSpecResourcesReservation": {
            "properties": {
                "genericResources": {
                    "$ref": "#/types/docker:index/ServiceTaskSpecResourcesReservationGenericResources:ServiceTaskSpecResourcesReservationGenericResources",
                    "description": "User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, GPU=UUID1)\n"
                },
                "memoryBytes": {
                    "type": "integer",
                    "description": "The amounf of memory in bytes the container allocates\n"
                },
                "nanoCpus": {
                    "type": "integer",
                    "description": "CPU shares in units of 1/1e9 (or 10^-9) of the CPU. Should be at least `1000000`\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecResourcesReservationGenericResources:ServiceTaskSpecResourcesReservationGenericResources": {
            "properties": {
                "discreteResourcesSpecs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Integer resources\n"
                },
                "namedResourcesSpecs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The String resources\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceTaskSpecRestartPolicy:ServiceTaskSpecRestartPolicy": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "Condition for restart\n"
                },
                "delay": {
                    "type": "string",
                    "description": "Delay between restart attempts (ms|s|m|h)\n"
                },
                "maxAttempts": {
                    "type": "integer",
                    "description": "Maximum attempts to restart a given container before giving up (default value is `0`, which is ignored)\n"
                },
                "window": {
                    "type": "string",
                    "description": "The time window used to evaluate the restart policy (default value is `0`, which is unbounded) (ms|s|m|h)\n"
                }
            },
            "type": "object"
        },
        "docker:index/ServiceUpdateConfig:ServiceUpdateConfig": {
            "properties": {
                "delay": {
                    "type": "string",
                    "description": "Delay between task updates `(ns|us|ms|s|m|h)`. Defaults to `0s`.\n"
                },
                "failureAction": {
                    "type": "string",
                    "description": "Action on update failure: `pause`, `continue` or `rollback`. Defaults to `pause`.\n"
                },
                "maxFailureRatio": {
                    "type": "string",
                    "description": "Failure rate to tolerate during an update. Defaults to `0.0`.\n"
                },
                "monitor": {
                    "type": "string",
                    "description": "Duration after each task update to monitor for failure (ns|us|ms|s|m|h). Defaults to `5s`.\n"
                },
                "order": {
                    "type": "string",
                    "description": "Update order: either 'stop-first' or 'start-first'. Defaults to `stop-first`.\n"
                },
                "parallelism": {
                    "type": "integer",
                    "description": "Maximum number of tasks to be updated in one iteration. Defaults to `1`\n"
                }
            },
            "type": "object"
        },
        "docker:index/VolumeLabel:VolumeLabel": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "Name of the label\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the label\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "label",
                "value"
            ]
        },
        "docker:index/builderVersion:BuilderVersion": {
            "description": "The version of the Docker builder.",
            "type": "string",
            "enum": [
                {
                    "name": "BuilderV1",
                    "description": "The first generation builder for Docker Daemon",
                    "value": "BuilderV1"
                },
                {
                    "name": "BuilderBuildKit",
                    "description": "The builder based on moby/buildkit project",
                    "value": "BuilderBuildKit"
                }
            ]
        },
        "docker:index/cacheFrom:CacheFrom": {
            "description": "Contains a list of images to reference when building using a cache",
            "properties": {
                "images": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies cached images"
                }
            },
            "type": "object"
        },
        "docker:index/dockerBuild:DockerBuild": {
            "description": "The Docker build context",
            "properties": {
                "addHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Custom host-to-IP mappings to use while building (format: \"host:ip\")"
                },
                "args": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "An optional map of named build-time argument variables to set during the Docker build. This flag allows you to pass build-time variables that can be accessed like environment variables inside the RUN instruction."
                },
                "builderVersion": {
                    "$ref": "#/types/docker:index/builderVersion:BuilderVersion",
                    "description": "The version of the Docker builder."
                },
                "cacheFrom": {
                    "$ref": "#/types/docker:index/cacheFrom:CacheFrom",
                    "description": "A list of image names to use as build cache. Images provided must have a cache manifest. Must provide authentication to cache registry."
                },
                "context": {
                    "type": "string",
                    "description": "The path to the build context to use."
                },
                "dockerfile": {
                    "type": "string",
                    "description": "The path to the Dockerfile to use."
                },
                "network": {
                    "type": "string",
                    "description": "Set the networking mode for RUN instructions"
                },
                "platform": {
                    "type": "string",
                    "description": "The architecture of the platform you want to build this image for, e.g. `linux/arm64`."
                },
                "target": {
                    "type": "string",
                    "description": "The target of the Dockerfile to build"
                }
            },
            "type": "object"
        },
        "docker:index/getNetworkIpamConfig:getNetworkIpamConfig": {
            "properties": {
                "auxAddress": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Auxiliary IPv4 or IPv6 addresses used by Network driver\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The IP address of the gateway\n"
                },
                "ipRange": {
                    "type": "string",
                    "description": "The ip range in CIDR form\n"
                },
                "subnet": {
                    "type": "string",
                    "description": "The subnet in CIDR form\n"
                }
            },
            "type": "object"
        },
        "docker:index/registry:Registry": {
            "description": "Describes a Docker container registry",
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The password to authenticate to the registry. Does not cause image rebuild when changed.",
                    "secret": true
                },
                "server": {
                    "type": "string",
                    "description": "The URL of the Docker registry server"
                },
                "username": {
                    "type": "string",
                    "description": "The username to authenticate to the registry. Does not cause image rebuild when changed."
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the docker package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "caMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker host CA certificate.\n"
            },
            "certMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker client certificate.\n"
            },
            "certPath": {
                "type": "string",
                "description": "Path to a directory with Docker TLS config. This directory is expected to contain `ca.pem`, `cert.pem`, and `key.pem`\nfiles.\n"
            },
            "host": {
                "type": "string",
                "description": "The Docker daemon's address.\n"
            },
            "keyMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker client private key.\n"
            },
            "registryAuth": {
                "type": "array",
                "items": {
                    "$ref": "#/types/docker:index/ProviderRegistryAuth:ProviderRegistryAuth"
                }
            },
            "sshOpts": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "description": "Additional SSH option flags to be appended when using `ssh://` protocol. The `ssh://` protocol is not supported for\n`buildx.Image` resources. Instead, use a [remote](https://docs.docker.com/build/drivers/remote/) driver.\n"
            }
        },
        "inputProperties": {
            "caMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker host CA certificate.\n"
            },
            "certMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker client certificate.\n"
            },
            "certPath": {
                "type": "string",
                "description": "Path to a directory with Docker TLS config. This directory is expected to contain `ca.pem`, `cert.pem`, and `key.pem`\nfiles.\n"
            },
            "host": {
                "type": "string",
                "description": "The Docker daemon's address.\n",
                "defaultInfo": {
                    "environment": [
                        "DOCKER_HOST"
                    ]
                }
            },
            "keyMaterial": {
                "type": "string",
                "description": "PEM-encoded content of Docker client private key.\n"
            },
            "registryAuth": {
                "type": "array",
                "items": {
                    "$ref": "#/types/docker:index/ProviderRegistryAuth:ProviderRegistryAuth"
                }
            },
            "sshOpts": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "description": "Additional SSH option flags to be appended when using `ssh://` protocol. The `ssh://` protocol is not supported for\n`buildx.Image` resources. Instead, use a [remote](https://docs.docker.com/build/drivers/remote/) driver.\n"
            }
        }
    },
    "resources": {
        "docker:buildx/image:Image": {
            "description": "A Docker image built using buildx -- Docker's interface to the improved\nBuildKit backend.\n\n## Stability\n\n**This resource is experimental and subject to change.**\n\nAPI types are unstable. Subsequent releases _may_ require manual edits\nto your state file(s) in order to adopt API changes.\n\n`retainOnDelete: true` is recommended with this resource until it is\nstable. This enables future API changes to be adopted more easily by renaming\nresources.\n\nOnly use this resource if you understand and accept the risks.\n\n## Migrating v3 and v4 Image resources\n\nThe `buildx.Image` resource provides a superset of functionality over the `Image` resources available in versions 3 and 4 of the Pulumi Docker provider.\nExisting `Image` resources can be converted to `build.Image` resources with minor modifications.\n\n### Behavioral differences\n\nThere are several key behavioral differences to keep in mind when transitioning images to the new `buildx.Image` resource.\n\n#### Previews\n\nVersion `3.x` of the Pulumi Docker provider always builds images during preview operations.\nThis is helpful as a safeguard to prevent \"broken\" images from merging, but users found the behavior unnecessarily redundant when running previews and updates locally.\n\nVersion `4.x` changed build-on-preview behavior to be opt-in.\nBy default, `v4.x` `Image` resources do _not_ build during previews, but this behavior can be toggled with the `buildOnPreview` option.\nSome users felt this made previews in CI less helpful because they no longer detected bad images by default.\n\nThe default behavior of the `buildx.Image` resource has been changed to strike a better balance between CI use cases and manual updates.\nBy default, Pulumi will now only build `buildx.Image` resources during previews when it detects a CI environment like GitHub Actions.\nPreviews run in non-CI environments will not build images.\nThis behavior is still configurable with `buildOnPreview`.\n\n#### Push behavior\n\nVersions `3.x` and `4.x` of the Pulumi Docker provider attempt to push images to remote registries by default.\nThey expose a `skipPush: true` option to disable pushing.\n\nThe `buildx.Image` resource matches the Docker CLI's behavior and does not push images anywhere by default.\n\nTo push images to a registry you can include `push: true` (equivalent to Docker's `--push` flag) or configure an `export` of type `registry` (equivalent to Docker's `--output type=registry`).\nLike Docker, if an image is configured without exports you will see a warning with instructions for how to enable pushing, but the build will still proceed normally.\n\n#### Secrets\n\nVersion `3.x` of the Pulumi Docker provider supports secrets by way of the `extraOptions` field.\n\nVersion `4.x` of the Pulumi Docker provider does not support secrets.\n\nThe `buildx.Image` resource supports secrets but does not require those secrets to exist on-disk or in environment variables.\nInstead, they should be passed directly as values.\n(Please be sure to familiarize yourself with Pulumi's [native secret handling](https://www.pulumi.com/docs/concepts/secrets/).)\nPulumi also provides [ESC](https://www.pulumi.com/product/esc/) to make it easier to share secrets across stacks and environments.\n\n#### Caching\n\nVersion `3.x` of the Pulumi Docker provider exposes `cacheFrom: bool | { stages: [...] }`.\nIt builds targets individually and pushes them to separate images for caching.\n\nVersion `4.x` exposes a similar parameter `cacheFrom: { images: [...] }` which pushes and pulls inline caches.\n\nBoth versions 3 and 4 require specific environment variables to be set and deviate from Docker's native caching behavior.\nThis can result in inefficient builds due to unnecessary image pulls, repeated file transfers, etc.\n\nThe `buildx.Image` resource delegates all caching behavior to Docker.\n`cacheFrom` and `cacheTo` options (equivalent to Docker's `--cache-to` and `--cache-from`) are exposed and provide additional cache targets, such as local disk, S3 storage, etc.\n\n#### Outputs\n\nTODO:\n\n#### Tag deletion and refreshes\n\nVersions 3 and 4 of Pulumi Docker provider do not delete tags when the `Image` resource is deleted, nor do they confirm expected tags exist during `refresh` operations.\n\nThe `buidx.Image` will query your registries during `refresh` to ensure the expected tags exist.\nIf any are missing a subsequent `update` will push them.\n\nWhen a `buildx.Image` is deleted, it will _attempt_ to also delete any pushed tags.\nDeletion of remote tags is not guaranteed, because not all registries currently support this operation (`docker.io` in particular).\n\nUse the [`retainOnDelete: true`](https://www.pulumi.com/docs/concepts/options/retainondelete/) option if you do not want tags deleted.\n\n### Example migration\n\nExamples of \"fully-featured\" `v3` and `v4` `Image` resources are shown below, along with an example `buildx.Image` resource showing how they would look after migration.\n\nThe `v3` resource leverages `buildx` via a `DOCKER_BUILDKIT` environment variable and CLI flags passed in with `extraOption`.\nAfter migration, the environment variable is no longer needed and CLI flags are now properties on the `buildx.Image`.\nIn almost all cases, properties of `buildx.Image` are named after the Docker CLI flag they correspond to.\n\nThe `v4` resource is less functional than its `v3` counterpart because it lacks the flexibility of `extraOptions`.\nIt it is shown with parameters similar to the `v3` example for completeness.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### v3/v4 migration\n\n```typescript\n\n// v3 Image\nconst v3 = new docker.Image(\"v3-image\", {\n  imageName: \"myregistry.com/user/repo:latest\",\n  localImageName: \"local-tag\",\n  skipPush: false,\n  build: {\n    dockerfile: \"./Dockerfile\",\n    context: \"../app\",\n    target: \"mytarget\",\n    args: {\n      MY_BUILD_ARG: \"foo\",\n    },\n    env: {\n      DOCKER_BUILDKIT: \"1\",\n    },\n    extraOptions: [\n      \"--cache-from\",\n      \"type=registry,myregistry.com/user/repo:cache\",\n      \"--cache-to\",\n      \"type=registry,myregistry.com/user/repo:cache\",\n      \"--add-host\",\n      \"metadata.google.internal:169.254.169.254\",\n      \"--secret\",\n      \"id=mysecret,src=/local/secret\",\n      \"--ssh\",\n      \"default=/home/runner/.ssh/id_ed25519\",\n      \"--network\",\n      \"host\",\n      \"--platform\",\n      \"linux/amd64\",\n    ],\n  },\n  registry: {\n    server: \"myregistry.com\",\n    username: \"username\",\n    password: pulumi.secret(\"password\"),\n  },\n});\n\n// v3 Image after migrating to buildx.Image\nconst v3Migrated = new docker.buildx.Image(\"v3-to-buildx\", {\n    tags: [\"myregistry.com/user/repo:latest\", \"local-tag\"],\n    push: true,\n    dockerfile: {\n        location: \"./Dockerfile\",\n    },\n    context: {\n        location: \"../app\",\n    },\n    targets: [\"mytarget\"],\n    buildArgs: {\n        MY_BUILD_ARG: \"foo\",\n    },\n    cacheFrom: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    cacheTo: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    secrets: {\n        mysecret: \"value\",\n    },\n    addHosts: [\"metadata.google.internal:169.254.169.254\"],\n    ssh: {\n        default: [\"/home/runner/.ssh/id_ed25519\"],\n    },\n    network: \"host\",\n    platforms: [\"linux/amd64\"],\n    registries: [{\n        address: \"myregistry.com\",\n        username: \"username\",\n        password: pulumi.secret(\"password\"),\n    }],\n});\n\n\n// v4 Image\nconst v4 = new docker.Image(\"v4-image\", {\n    imageName: \"myregistry.com/user/repo:latest\",\n    skipPush: false,\n    build: {\n        dockerfile: \"./Dockerfile\",\n        context: \"../app\",\n        target: \"mytarget\",\n        args: {\n            MY_BUILD_ARG: \"foo\",\n        },\n        cacheFrom: {\n            images: [\"myregistry.com/user/repo:cache\"],\n        },\n        addHosts: [\"metadata.google.internal:169.254.169.254\"],\n        network: \"host\",\n        platform: \"linux/amd64\",\n    },\n    buildOnPreview: true,\n    registry: {\n        server: \"myregistry.com\",\n        username: \"username\",\n        password: pulumi.secret(\"password\"),\n    },\n});\n\n// v4 Image after migrating to buildx.Image\nconst v4Migrated = new docker.buildx.Image(\"v4-to-buildx\", {\n    tags: [\"myregistry.com/user/repo:latest\"],\n    push: true,\n    dockerfile: {\n        location: \"./Dockerfile\",\n    },\n    context: {\n        location: \"../app\",\n    },\n    targets: [\"mytarget\"],\n    buildArgs: {\n        MY_BUILD_ARG: \"foo\",\n    },\n    cacheFrom: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    cacheTo: [{ registry: { ref: \"myregistry.com/user/repo:cache\" } }],\n    addHosts: [\"metadata.google.internal:169.254.169.254\"],\n    network: \"host\",\n    platforms: [\"linux/amd64\"],\n    registries: [{\n        address: \"myregistry.com\",\n        username: \"username\",\n        password: pulumi.secret(\"password\"),\n    }],\n});\n\n```\n\n{{% /example %}}\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Push to AWS ECR with caching\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ecrRepository = new aws.ecr.Repository(\"ecr-repository\", {});\nconst authToken = aws.ecr.getAuthorizationTokenOutput({\n    registryId: ecrRepository.registryId,\n});\nconst myImage = new docker.buildx.Image(\"my-image\", {\n    cacheFrom: [{\n        registry: {\n            ref: pulumi.interpolate`${ecrRepository.repositoryUrl}:cache`,\n        },\n    }],\n    cacheTo: [{\n        registry: {\n            imageManifest: true,\n            ociMediaTypes: true,\n            ref: pulumi.interpolate`${ecrRepository.repositoryUrl}:cache`,\n        },\n    }],\n    context: {\n        location: \"./app\",\n    },\n    dockerfile: {\n        location: \"./Dockerfile\",\n    },\n    push: true,\n    registries: [{\n        address: ecrRepository.repositoryUrl,\n        password: authToken.apply(authToken =\u003e authToken.password),\n        username: authToken.apply(authToken =\u003e authToken.userName),\n    }],\n    tags: [pulumi.interpolate`${ecrRepository.repositoryUrl}:latest`],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_docker as docker\n\necr_repository = aws.ecr.Repository(\"ecr-repository\")\nauth_token = aws.ecr.get_authorization_token_output(registry_id=ecr_repository.registry_id)\nmy_image = docker.buildx.Image(\"my-image\",\n    cache_from=[docker.buildx.CacheFromEntryArgs(\n        registry=docker.buildx.CacheFromRegistryArgs(\n            ref=ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:cache\"),\n        ),\n    )],\n    cache_to=[docker.buildx.CacheToEntryArgs(\n        registry=docker.buildx.CacheToRegistryArgs(\n            image_manifest=True,\n            oci_media_types=True,\n            ref=ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:cache\"),\n        ),\n    )],\n    context=docker.buildx.BuildContextArgs(\n        location=\"./app\",\n    ),\n    dockerfile=docker.buildx.DockerfileArgs(\n        location=\"./Dockerfile\",\n    ),\n    push=True,\n    registries=[docker.buildx.RegistryAuthArgs(\n        address=ecr_repository.repository_url,\n        password=auth_token.password,\n        username=auth_token.user_name,\n    )],\n    tags=[ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:latest\")])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ecrRepository = new Aws.Ecr.Repository(\"ecr-repository\");\n\n    var authToken = Aws.Ecr.GetAuthorizationToken.Invoke(new()\n    {\n        RegistryId = ecrRepository.RegistryId,\n    });\n\n    var myImage = new Docker.Buildx.Image(\"my-image\", new()\n    {\n        CacheFrom = new[]\n        {\n            new Docker.Buildx.Inputs.CacheFromEntryArgs\n            {\n                Registry = new Docker.Buildx.Inputs.CacheFromRegistryArgs\n                {\n                    Ref = ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:cache\"),\n                },\n            },\n        },\n        CacheTo = new[]\n        {\n            new Docker.Buildx.Inputs.CacheToEntryArgs\n            {\n                Registry = new Docker.Buildx.Inputs.CacheToRegistryArgs\n                {\n                    ImageManifest = true,\n                    OciMediaTypes = true,\n                    Ref = ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:cache\"),\n                },\n            },\n        },\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"./app\",\n        },\n        Dockerfile = new Docker.Buildx.Inputs.DockerfileArgs\n        {\n            Location = \"./Dockerfile\",\n        },\n        Push = true,\n        Registries = new[]\n        {\n            new Docker.Buildx.Inputs.RegistryAuthArgs\n            {\n                Address = ecrRepository.RepositoryUrl,\n                Password = authToken.Apply(getAuthorizationTokenResult =\u003e getAuthorizationTokenResult.Password),\n                Username = authToken.Apply(getAuthorizationTokenResult =\u003e getAuthorizationTokenResult.UserName),\n            },\n        },\n        Tags = new[]\n        {\n            ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:latest\"),\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ecr\"\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tecrRepository, err := ecr.NewRepository(ctx, \"ecr-repository\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tauthToken := ecr.GetAuthorizationTokenOutput(ctx, ecr.GetAuthorizationTokenOutputArgs{\n\t\t\tRegistryId: ecrRepository.RegistryId,\n\t\t}, nil)\n\t\t_, err = buildx.NewImage(ctx, \"my-image\", \u0026buildx.ImageArgs{\n\t\t\tCacheFrom: buildx.CacheFromEntryArray{\n\t\t\t\t\u0026buildx.CacheFromEntryArgs{\n\t\t\t\t\tRegistry: \u0026buildx.CacheFromRegistryArgs{\n\t\t\t\t\t\tRef: ecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\t\t\t\treturn fmt.Sprintf(\"%v:cache\", repositoryUrl), nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCacheTo: buildx.CacheToEntryArray{\n\t\t\t\t\u0026buildx.CacheToEntryArgs{\n\t\t\t\t\tRegistry: \u0026buildx.CacheToRegistryArgs{\n\t\t\t\t\t\tImageManifest: pulumi.Bool(true),\n\t\t\t\t\t\tOciMediaTypes: pulumi.Bool(true),\n\t\t\t\t\t\tRef: ecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\t\t\t\treturn fmt.Sprintf(\"%v:cache\", repositoryUrl), nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"./app\"),\n\t\t\t},\n\t\t\tDockerfile: \u0026buildx.DockerfileArgs{\n\t\t\t\tLocation: pulumi.String(\"./Dockerfile\"),\n\t\t\t},\n\t\t\tPush: pulumi.Bool(true),\n\t\t\tRegistries: buildx.RegistryAuthArray{\n\t\t\t\t\u0026buildx.RegistryAuthArgs{\n\t\t\t\t\tAddress: ecrRepository.RepositoryUrl,\n\t\t\t\t\tPassword: authToken.ApplyT(func(authToken ecr.GetAuthorizationTokenResult) (*string, error) {\n\t\t\t\t\t\treturn \u0026authToken.Password, nil\n\t\t\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\t\t\tUsername: authToken.ApplyT(func(authToken ecr.GetAuthorizationTokenResult) (*string, error) {\n\t\t\t\t\t\treturn \u0026authToken.UserName, nil\n\t\t\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\t\treturn fmt.Sprintf(\"%v:latest\", repositoryUrl), nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Push to AWS ECR with caching\nname: ecr\nresources:\n    ecr-repository:\n        type: aws:ecr:Repository\n    my-image:\n        properties:\n            cacheFrom:\n                - registry:\n                    ref: ${ecr-repository.repositoryUrl}:cache\n            cacheTo:\n                - registry:\n                    imageManifest: true\n                    ociMediaTypes: true\n                    ref: ${ecr-repository.repositoryUrl}:cache\n            context:\n                location: ./app\n            dockerfile:\n                location: ./Dockerfile\n            push: true\n            registries:\n                - address: ${ecr-repository.repositoryUrl}\n                  password: ${auth-token.password}\n                  username: ${auth-token.userName}\n            tags:\n                - ${ecr-repository.repositoryUrl}:latest\n        type: docker:buildx/image:Image\nruntime: yaml\nvariables:\n    auth-token:\n        fn::aws:ecr:getAuthorizationToken:\n            registryId: ${ecr-repository.registryId}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ecr.Repository;\nimport com.pulumi.aws.ecr.EcrFunctions;\nimport com.pulumi.aws.ecr.inputs.GetAuthorizationTokenArgs;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.CacheFromEntryArgs;\nimport com.pulumi.docker.buildx.inputs.CacheFromRegistryArgs;\nimport com.pulumi.docker.buildx.inputs.CacheToEntryArgs;\nimport com.pulumi.docker.buildx.inputs.CacheToRegistryArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport com.pulumi.docker.buildx.inputs.DockerfileArgs;\nimport com.pulumi.docker.buildx.inputs.RegistryAuthArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ecrRepository = new Repository(\"ecrRepository\");\n\n        final var authToken = EcrFunctions.getAuthorizationToken(GetAuthorizationTokenArgs.builder()\n            .registryId(ecrRepository.registryId())\n            .build());\n\n        var myImage = new Image(\"myImage\", ImageArgs.builder()        \n            .cacheFrom(CacheFromEntryArgs.builder()\n                .registry(CacheFromRegistryArgs.builder()\n                    .ref(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:cache\", repositoryUrl)))\n                    .build())\n                .build())\n            .cacheTo(CacheToEntryArgs.builder()\n                .registry(CacheToRegistryArgs.builder()\n                    .imageManifest(true)\n                    .ociMediaTypes(true)\n                    .ref(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:cache\", repositoryUrl)))\n                    .build())\n                .build())\n            .context(BuildContextArgs.builder()\n                .location(\"./app\")\n                .build())\n            .dockerfile(DockerfileArgs.builder()\n                .location(\"./Dockerfile\")\n                .build())\n            .push(true)\n            .registries(RegistryAuthArgs.builder()\n                .address(ecrRepository.repositoryUrl())\n                .password(authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult).applyValue(authToken -\u003e authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult.password())))\n                .username(authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult).applyValue(authToken -\u003e authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult.userName())))\n                .build())\n            .tags(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:latest\", repositoryUrl)))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Multi-platform image\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    platforms: [\n        docker.buildx.image.Platform.Plan9_amd64,\n        docker.buildx.image.Platform.Plan9_386,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    context=docker.buildx.BuildContextArgs(\n        location=\"app\",\n    ),\n    platforms=[\n        docker.buildx/image.Platform.PLAN9_AMD64,\n        docker.buildx/image.Platform.PLAN9_386,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Platforms = new[]\n        {\n            Docker.Buildx.Image.Platform.Plan9_amd64,\n            Docker.Buildx.Image.Platform.Plan9_386,\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tPlatforms: buildx.PlatformArray{\n\t\t\t\tbuildx.Platform_Plan9_amd64,\n\t\t\t\tbuildx.Platform_Plan9_386,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Multi-platform image\nname: multi-platform\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            platforms:\n                - plan9/amd64\n                - plan9/386\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .platforms(            \n                \"plan9/amd64\",\n                \"plan9/386\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Registry export\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    push: true,\n    registries: [{\n        address: \"docker.io\",\n        password: dockerHubPassword,\n        username: \"pulumibot\",\n    }],\n    tags: [\"docker.io/pulumi/pulumi:3.107.0\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    context=docker.buildx.BuildContextArgs(\n        location=\"app\",\n    ),\n    push=True,\n    registries=[docker.buildx.RegistryAuthArgs(\n        address=\"docker.io\",\n        password=docker_hub_password,\n        username=\"pulumibot\",\n    )],\n    tags=[\"docker.io/pulumi/pulumi:3.107.0\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Push = true,\n        Registries = new[]\n        {\n            new Docker.Buildx.Inputs.RegistryAuthArgs\n            {\n                Address = \"docker.io\",\n                Password = dockerHubPassword,\n                Username = \"pulumibot\",\n            },\n        },\n        Tags = new[]\n        {\n            \"docker.io/pulumi/pulumi:3.107.0\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tPush: pulumi.Bool(true),\n\t\t\tRegistries: buildx.RegistryAuthArray{\n\t\t\t\t\u0026buildx.RegistryAuthArgs{\n\t\t\t\t\tAddress:  pulumi.String(\"docker.io\"),\n\t\t\t\t\tPassword: pulumi.Any(dockerHubPassword),\n\t\t\t\t\tUsername: pulumi.String(\"pulumibot\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"docker.io/pulumi/pulumi:3.107.0\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Registry export\nname: registry\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            push: true\n            registries:\n                - address: docker.io\n                  password: ${dockerHubPassword}\n                  username: pulumibot\n            tags:\n                - docker.io/pulumi/pulumi:3.107.0\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport com.pulumi.docker.buildx.inputs.RegistryAuthArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .push(true)\n            .registries(RegistryAuthArgs.builder()\n                .address(\"docker.io\")\n                .password(dockerHubPassword)\n                .username(\"pulumibot\")\n                .build())\n            .tags(\"docker.io/pulumi/pulumi:3.107.0\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Caching\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    cacheFrom: [{\n        local: {\n            src: \"tmp/cache\",\n        },\n    }],\n    cacheTo: [{\n        local: {\n            dest: \"tmp/cache\",\n            mode: docker.buildx.image.CacheMode.Max,\n        },\n    }],\n    context: {\n        location: \"app\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    cache_from=[docker.buildx.CacheFromEntryArgs(\n        local=docker.buildx.CacheFromLocalArgs(\n            src=\"tmp/cache\",\n        ),\n    )],\n    cache_to=[docker.buildx.CacheToEntryArgs(\n        local=docker.buildx.CacheToLocalArgs(\n            dest=\"tmp/cache\",\n            mode=docker.buildx/image.CacheMode.MAX,\n        ),\n    )],\n    context=docker.buildx.BuildContextArgs(\n        location=\"app\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        CacheFrom = new[]\n        {\n            new Docker.Buildx.Inputs.CacheFromEntryArgs\n            {\n                Local = new Docker.Buildx.Inputs.CacheFromLocalArgs\n                {\n                    Src = \"tmp/cache\",\n                },\n            },\n        },\n        CacheTo = new[]\n        {\n            new Docker.Buildx.Inputs.CacheToEntryArgs\n            {\n                Local = new Docker.Buildx.Inputs.CacheToLocalArgs\n                {\n                    Dest = \"tmp/cache\",\n                    Mode = Docker.Buildx.Image.CacheMode.Max,\n                },\n            },\n        },\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tCacheFrom: buildx.CacheFromEntryArray{\n\t\t\t\t\u0026buildx.CacheFromEntryArgs{\n\t\t\t\t\tLocal: \u0026buildx.CacheFromLocalArgs{\n\t\t\t\t\t\tSrc: pulumi.String(\"tmp/cache\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCacheTo: buildx.CacheToEntryArray{\n\t\t\t\t\u0026buildx.CacheToEntryArgs{\n\t\t\t\t\tLocal: \u0026buildx.CacheToLocalArgs{\n\t\t\t\t\t\tDest: pulumi.String(\"tmp/cache\"),\n\t\t\t\t\t\tMode: buildx.CacheModeMax,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Caching\nname: caching\nresources:\n    image:\n        properties:\n            cacheFrom:\n                - local:\n                    src: tmp/cache\n            cacheTo:\n                - local:\n                    dest: tmp/cache\n                    mode: max\n            context:\n                location: app\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.CacheFromEntryArgs;\nimport com.pulumi.docker.buildx.inputs.CacheFromLocalArgs;\nimport com.pulumi.docker.buildx.inputs.CacheToEntryArgs;\nimport com.pulumi.docker.buildx.inputs.CacheToLocalArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .cacheFrom(CacheFromEntryArgs.builder()\n                .local(CacheFromLocalArgs.builder()\n                    .src(\"tmp/cache\")\n                    .build())\n                .build())\n            .cacheTo(CacheToEntryArgs.builder()\n                .local(CacheToLocalArgs.builder()\n                    .dest(\"tmp/cache\")\n                    .mode(\"max\")\n                    .build())\n                .build())\n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Build arguments\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    buildArgs: {\n        SET_ME_TO_TRUE: \"true\",\n    },\n    context: {\n        location: \"app\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    build_args={\n        \"SET_ME_TO_TRUE\": \"true\",\n    },\n    context=docker.buildx.BuildContextArgs(\n        location=\"app\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        BuildArgs = \n        {\n            { \"SET_ME_TO_TRUE\", \"true\" },\n        },\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tBuildArgs: pulumi.StringMap{\n\t\t\t\t\"SET_ME_TO_TRUE\": pulumi.String(\"true\"),\n\t\t\t},\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Build arguments\nname: build-args\nresources:\n    image:\n        properties:\n            buildArgs:\n                SET_ME_TO_TRUE: \"true\"\n            context:\n                location: app\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .buildArgs(Map.of(\"SET_ME_TO_TRUE\", \"true\"))\n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Build targets\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    targets: [\n        \"build-me\",\n        \"also-build-me\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    context=docker.buildx.BuildContextArgs(\n        location=\"app\",\n    ),\n    targets=[\n        \"build-me\",\n        \"also-build-me\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Targets = new[]\n        {\n            \"build-me\",\n            \"also-build-me\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tTargets: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"build-me\"),\n\t\t\t\tpulumi.String(\"also-build-me\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Build targets\nname: build-targets\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            targets:\n                - build-me\n                - also-build-me\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .targets(            \n                \"build-me\",\n                \"also-build-me\")\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Named contexts\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {context: {\n    location: \"app\",\n    named: {\n        \"golang:latest\": {\n            location: \"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\",\n        },\n    },\n}});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\", context=docker.buildx.BuildContextArgs(\n    location=\"app\",\n    named={\n        \"golang:latest\": docker.buildx.ContextArgs(\n            location=\"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\",\n        ),\n    },\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n            Named = \n            {\n                { \"golang:latest\", new Docker.Buildx.Inputs.ContextArgs\n                {\n                    Location = \"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\",\n                } },\n            },\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t\tNamed: buildx.ContextMap{\n\t\t\t\t\t\"golang:latest\": \u0026buildx.ContextArgs{\n\t\t\t\t\t\tLocation: pulumi.String(\"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Named contexts\nname: named-contexts\nresources:\n    image:\n        properties:\n            context:\n                location: app\n                named:\n                    golang:latest:\n                        location: docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .named(Map.of(\"golang:latest\", Map.of(\"location\", \"docker-image://golang@sha256:b8e62cf593cdaff36efd90aa3a37de268e6781a2e68c6610940c48f7cdf36984\")))\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Remote context\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {context: {\n    location: \"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\",\n}});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\", context=docker.buildx.BuildContextArgs(\n    location=\"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Remote context\nname: remote-context\nresources:\n    image:\n        properties:\n            context:\n                location: https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"https://raw.githubusercontent.com/pulumi/pulumi-docker/api-types/provider/testdata/Dockerfile\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Inline Dockerfile\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    dockerfile: {\n        inline: `FROM busybox\nCOPY hello.c ./\n`,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    context=docker.buildx.BuildContextArgs(\n        location=\"app\",\n    ),\n    dockerfile=docker.buildx.DockerfileArgs(\n        inline=\"\"\"FROM busybox\nCOPY hello.c ./\n\"\"\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Dockerfile = new Docker.Buildx.Inputs.DockerfileArgs\n        {\n            Inline = @\"FROM busybox\nCOPY hello.c ./\n\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tDockerfile: \u0026buildx.DockerfileArgs{\n\t\t\t\tInline: pulumi.String(\"FROM busybox\\nCOPY hello.c ./\\n\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Inline Dockerfile\nname: inline\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            dockerfile:\n                inline: |\n                    FROM busybox\n                    COPY hello.c ./\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport com.pulumi.docker.buildx.inputs.DockerfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .dockerfile(DockerfileArgs.builder()\n                .inline(\"\"\"\nFROM busybox\nCOPY hello.c ./\n                \"\"\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Remote context\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    context: {\n        location: \"https://github.com/docker-library/hello-world.git\",\n    },\n    dockerfile: {\n        location: \"app/Dockerfile\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    context=docker.buildx.BuildContextArgs(\n        location=\"https://github.com/docker-library/hello-world.git\",\n    ),\n    dockerfile=docker.buildx.DockerfileArgs(\n        location=\"app/Dockerfile\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"https://github.com/docker-library/hello-world.git\",\n        },\n        Dockerfile = new Docker.Buildx.Inputs.DockerfileArgs\n        {\n            Location = \"app/Dockerfile\",\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"https://github.com/docker-library/hello-world.git\"),\n\t\t\t},\n\t\t\tDockerfile: \u0026buildx.DockerfileArgs{\n\t\t\t\tLocation: pulumi.String(\"app/Dockerfile\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Remote context\nname: remote-context\nresources:\n    image:\n        properties:\n            context:\n                location: https://github.com/docker-library/hello-world.git\n            dockerfile:\n                location: app/Dockerfile\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport com.pulumi.docker.buildx.inputs.DockerfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"https://github.com/docker-library/hello-world.git\")\n                .build())\n            .dockerfile(DockerfileArgs.builder()\n                .location(\"app/Dockerfile\")\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Local export\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst image = new docker.buildx.Image(\"image\", {\n    context: {\n        location: \"app\",\n    },\n    exports: [{\n        docker: {\n            tar: true,\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nimage = docker.buildx.Image(\"image\",\n    context=docker.buildx.BuildContextArgs(\n        location=\"app\",\n    ),\n    exports=[docker.buildx.ExportEntryArgs(\n        docker=docker.buildx.ExportDockerArgs(\n            tar=True,\n        ),\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var image = new Docker.Buildx.Image(\"image\", new()\n    {\n        Context = new Docker.Buildx.Inputs.BuildContextArgs\n        {\n            Location = \"app\",\n        },\n        Exports = new[]\n        {\n            new Docker.Buildx.Inputs.ExportEntryArgs\n            {\n                Docker = new Docker.Buildx.Inputs.ExportDockerArgs\n                {\n                    Tar = true,\n                },\n            },\n        },\n    });\n\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker/buildx\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := buildx.NewImage(ctx, \"image\", \u0026buildx.ImageArgs{\n\t\t\tContext: \u0026buildx.BuildContextArgs{\n\t\t\t\tLocation: pulumi.String(\"app\"),\n\t\t\t},\n\t\t\tExports: buildx.ExportEntryArray{\n\t\t\t\t\u0026buildx.ExportEntryArgs{\n\t\t\t\t\tDocker: \u0026buildx.ExportDockerArgs{\n\t\t\t\t\t\tTar: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```yaml\ndescription: Local export\nname: docker-load\nresources:\n    image:\n        properties:\n            context:\n                location: app\n            exports:\n                - docker:\n                    tar: true\n        type: docker:buildx/image:Image\nruntime: yaml\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.buildx.Image;\nimport com.pulumi.docker.buildx.ImageArgs;\nimport com.pulumi.docker.buildx.inputs.BuildContextArgs;\nimport com.pulumi.docker.buildx.inputs.ExportEntryArgs;\nimport com.pulumi.docker.buildx.inputs.ExportDockerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var image = new Image(\"image\", ImageArgs.builder()        \n            .context(BuildContextArgs.builder()\n                .location(\"app\")\n                .build())\n            .exports(ExportEntryArgs.builder()\n                .docker(ExportDockerArgs.builder()\n                    .tar(true)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Custom `host:ip` mappings to use during the build.\n\nEquivalent to Docker's `--add-host` flag."
                },
                "buildArgs": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`ARG` names and values to set during the build.\n\nThese variables are accessed like environment variables inside `RUN`\ninstructions.\n\nBuild arguments are persisted in the image, so you should use `secrets`\nif these arguments are sensitive.\n\nEquivalent to Docker's `--build-arg` flag."
                },
                "buildOnPreview": {
                    "type": "boolean",
                    "description": "By default, preview behavior depends on the execution environment. If\nPulumi detects the operation is running on a CI system (GitHub Actions,\nTravis CI, Azure Pipelines, etc.) then it will build images during\npreviews as a safeguard. Otherwise, if not running on CI, previews will\nnot build images.\n\nSetting this to `false` forces previews to never perform builds, and\nsetting it to `true` will always build the image during previews.\n\nImages built during previews are never exported to registries, however\ncache manifests are still exported.\n\nOn-disk Dockerfiles are always validated for syntactic correctness\nregardless of this setting."
                },
                "builder": {
                    "$ref": "#/types/docker:buildx/image:BuilderConfig",
                    "description": "Builder configuration."
                },
                "cacheFrom": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:CacheFromEntry"
                    },
                    "description": "Cache export configuration.\n\nEquivalent to Docker's `--cache-from` flag."
                },
                "cacheTo": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:CacheToEntry"
                    },
                    "description": "Cache import configuration.\n\nEquivalent to Docker's `--cache-to` flag."
                },
                "context": {
                    "$ref": "#/types/docker:buildx/image:BuildContext",
                    "description": "Build context settings.\n\nEquivalent to Docker's `PATH | URL | -` positional argument."
                },
                "contextHash": {
                    "type": "string",
                    "description": "A preliminary hash of the image's build context.\n\nPulumi uses this to determine if an image _may_ need to be re-built."
                },
                "digests": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping of target names to the SHA256 digest of their pushed manifest.\n\nIf no target was specified 'default' is used as the target name.\n\nPushed manifests can be referenced as `\u003ctag\u003e@\u003cdigest\u003e`."
                },
                "dockerfile": {
                    "$ref": "#/types/docker:buildx/image:Dockerfile",
                    "description": "Dockerfile settings.\n\nEquivalent to Docker's `--file` flag."
                },
                "exports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:ExportEntry"
                    },
                    "description": "Controls where images are persisted after building.\n\nImages are only stored in the local cache unless `exports` are\nexplicitly configured.\n\nEquivalent to Docker's `--output` flag."
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Attach arbitrary key/value metadata to the image.\n\nEquivalent to Docker's `--label` flag."
                },
                "load": {
                    "type": "boolean",
                    "description": "When `true` the build will automatically include a `docker` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--load` flag."
                },
                "network": {
                    "$ref": "#/types/docker:buildx/image:NetworkMode",
                    "description": "Set the network mode for `RUN` instructions. Defaults to `default`.\n\nFor custom networks, configure your builder with `--driver-opt network=...`.\n\nEquivalent to Docker's `--network` flag.",
                    "default": "default"
                },
                "noCache": {
                    "type": "boolean",
                    "description": "Do not import cache manifests when building the image.\n\nEquivalent to Docker's `--no-cache` flag."
                },
                "platforms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:Platform"
                    },
                    "description": "Set target platform(s) for the build. Defaults to the host's platform.\n\nEquivalent to Docker's `--platform` flag."
                },
                "pull": {
                    "type": "boolean",
                    "description": "Always pull referenced images.\n\nEquivalent to Docker's `--pull` flag."
                },
                "push": {
                    "type": "boolean",
                    "description": "When `true` the build will automatically include a `registry` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--push` flag."
                },
                "ref": {
                    "type": "string",
                    "description": "If the image was pushed to any registries then this will contain a\nsingle fully-qualified tag including the build's digest.\n\nThis is only for convenience and may not be appropriate for situations\nwhere multiple tags or registries are involved. In those cases this\noutput is not guaranteed to be stable.\n\nFor more control over tags consumed by downstream resources you should\nuse the `Digests` output."
                },
                "registries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:RegistryAuth"
                    },
                    "description": "Registry credentials. Required if reading or exporting to private\nrepositories.\n\nCredentials are kept in-memory and do not pollute pre-existing\ncredentials on the host.\n\nSimilar to `docker login`."
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping of secret names to their corresponding values.\n\nUnlike the Docker CLI, these can be passed by value and do not need to\nexist on-disk or in environment variables.\n\nBuild arguments and environment variables are persistent in the final\nimage, so you should use this for sensitive values.\n\nSimilar to Docker's `--secret` flag."
                },
                "ssh": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:SSH"
                    },
                    "description": "SSH agent socket or keys to expose to the build.\n\nEquivalent to Docker's `--ssh` flag."
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name and optionally a tag (format: `name:tag`).\n\nIf exporting to a registry, the name should include the fully qualified\nregistry address (e.g. `docker.io/pulumi/pulumi:latest`).\n\nEquivalent to Docker's `--tag` flag."
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set the target build stage(s) to build.\n\nIf not specified all targets will be built by default.\n\nEquivalent to Docker's `--target` flag."
                }
            },
            "required": [
                "digests",
                "contextHash",
                "ref"
            ],
            "inputProperties": {
                "addHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Custom `host:ip` mappings to use during the build.\n\nEquivalent to Docker's `--add-host` flag."
                },
                "buildArgs": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "`ARG` names and values to set during the build.\n\nThese variables are accessed like environment variables inside `RUN`\ninstructions.\n\nBuild arguments are persisted in the image, so you should use `secrets`\nif these arguments are sensitive.\n\nEquivalent to Docker's `--build-arg` flag."
                },
                "buildOnPreview": {
                    "type": "boolean",
                    "description": "By default, preview behavior depends on the execution environment. If\nPulumi detects the operation is running on a CI system (GitHub Actions,\nTravis CI, Azure Pipelines, etc.) then it will build images during\npreviews as a safeguard. Otherwise, if not running on CI, previews will\nnot build images.\n\nSetting this to `false` forces previews to never perform builds, and\nsetting it to `true` will always build the image during previews.\n\nImages built during previews are never exported to registries, however\ncache manifests are still exported.\n\nOn-disk Dockerfiles are always validated for syntactic correctness\nregardless of this setting."
                },
                "builder": {
                    "$ref": "#/types/docker:buildx/image:BuilderConfig",
                    "description": "Builder configuration."
                },
                "cacheFrom": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:CacheFromEntry"
                    },
                    "description": "Cache export configuration.\n\nEquivalent to Docker's `--cache-from` flag."
                },
                "cacheTo": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:CacheToEntry"
                    },
                    "description": "Cache import configuration.\n\nEquivalent to Docker's `--cache-to` flag."
                },
                "context": {
                    "$ref": "#/types/docker:buildx/image:BuildContext",
                    "description": "Build context settings.\n\nEquivalent to Docker's `PATH | URL | -` positional argument."
                },
                "dockerfile": {
                    "$ref": "#/types/docker:buildx/image:Dockerfile",
                    "description": "Dockerfile settings.\n\nEquivalent to Docker's `--file` flag."
                },
                "exports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:ExportEntry"
                    },
                    "description": "Controls where images are persisted after building.\n\nImages are only stored in the local cache unless `exports` are\nexplicitly configured.\n\nEquivalent to Docker's `--output` flag."
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Attach arbitrary key/value metadata to the image.\n\nEquivalent to Docker's `--label` flag."
                },
                "load": {
                    "type": "boolean",
                    "description": "When `true` the build will automatically include a `docker` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--load` flag."
                },
                "network": {
                    "$ref": "#/types/docker:buildx/image:NetworkMode",
                    "description": "Set the network mode for `RUN` instructions. Defaults to `default`.\n\nFor custom networks, configure your builder with `--driver-opt network=...`.\n\nEquivalent to Docker's `--network` flag.",
                    "default": "default"
                },
                "noCache": {
                    "type": "boolean",
                    "description": "Do not import cache manifests when building the image.\n\nEquivalent to Docker's `--no-cache` flag."
                },
                "platforms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:Platform"
                    },
                    "description": "Set target platform(s) for the build. Defaults to the host's platform.\n\nEquivalent to Docker's `--platform` flag."
                },
                "pull": {
                    "type": "boolean",
                    "description": "Always pull referenced images.\n\nEquivalent to Docker's `--pull` flag."
                },
                "push": {
                    "type": "boolean",
                    "description": "When `true` the build will automatically include a `registry` export.\n\nDefaults to `false`.\n\nEquivalent to Docker's `--push` flag."
                },
                "registries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:RegistryAuth"
                    },
                    "description": "Registry credentials. Required if reading or exporting to private\nrepositories.\n\nCredentials are kept in-memory and do not pollute pre-existing\ncredentials on the host.\n\nSimilar to `docker login`."
                },
                "secrets": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping of secret names to their corresponding values.\n\nUnlike the Docker CLI, these can be passed by value and do not need to\nexist on-disk or in environment variables.\n\nBuild arguments and environment variables are persistent in the final\nimage, so you should use this for sensitive values.\n\nSimilar to Docker's `--secret` flag."
                },
                "ssh": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:buildx/image:SSH"
                    },
                    "description": "SSH agent socket or keys to expose to the build.\n\nEquivalent to Docker's `--ssh` flag."
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name and optionally a tag (format: `name:tag`).\n\nIf exporting to a registry, the name should include the fully qualified\nregistry address (e.g. `docker.io/pulumi/pulumi:latest`).\n\nEquivalent to Docker's `--tag` flag."
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set the target build stage(s) to build.\n\nIf not specified all targets will be built by default.\n\nEquivalent to Docker's `--target` flag."
                }
            }
        },
        "docker:index/container:Container": {
            "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nManages the lifecycle of a Docker container.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\n// Find the latest Ubuntu precise image.\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {name: \"ubuntu:precise\"});\n// Start a container\nconst ubuntuContainer = new docker.Container(\"ubuntuContainer\", {image: ubuntuRemoteImage.imageId});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\n# Find the latest Ubuntu precise image.\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\", name=\"ubuntu:precise\")\n# Start a container\nubuntu_container = docker.Container(\"ubuntuContainer\", image=ubuntu_remote_image.image_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Find the latest Ubuntu precise image.\n    var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n    // Start a container\n    var ubuntuContainer = new Docker.Container(\"ubuntuContainer\", new()\n    {\n        Image = ubuntuRemoteImage.ImageId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Find the latest Ubuntu precise image.\n\t\tubuntuRemoteImage, err := docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", \u0026docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(\"ubuntu:precise\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Start a container\n\t\t_, err = docker.NewContainer(ctx, \"ubuntuContainer\", \u0026docker.ContainerArgs{\n\t\t\tImage: ubuntuRemoteImage.ImageId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport com.pulumi.docker.Container;\nimport com.pulumi.docker.ContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuRemoteImage = new RemoteImage(\"ubuntuRemoteImage\", RemoteImageArgs.builder()        \n            .name(\"ubuntu:precise\")\n            .build());\n\n        var ubuntuContainer = new Container(\"ubuntuContainer\", ContainerArgs.builder()        \n            .image(ubuntuRemoteImage.imageId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Start a container\n  ubuntuContainer:\n    type: docker:Container\n    properties:\n      image: ${ubuntuRemoteImage.imageId}\n  # Find the latest Ubuntu precise image.\n  ubuntuRemoteImage:\n    type: docker:RemoteImage\n    properties:\n      name: ubuntu:precise\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n### Example\n\n Assuming you created a `container` as follows\n\n #!/bin/bash\n\n docker run --name foo -p8080:80 -d nginx\n\n prints the container ID\n\n 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd\n\n you provide the definition for the resource as follows\n\n terraform\n\n resource \"docker_container\" \"foo\" {\n\n\n\n name\n\n= \"foo\"\n\n\n\n image = \"nginx\"\n\n\n\n ports {\n\n\n\n\n\n internal = \"80\"\n\n\n\n\n\n external = \"8080\"\n\n\n\n }\n\n }\n\n then the import command is as follows\n\n #!/bin/bash\n\n ```sh\n $ pulumi import docker:index/container:Container foo 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd\n```\n\n ",
            "properties": {
                "attach": {
                    "type": "boolean",
                    "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The network bridge of the container as read from its NetworkSettings.\n"
                },
                "capabilities": {
                    "$ref": "#/types/docker:index/ContainerCapabilities:ContainerCapabilities",
                    "description": "Add or drop certrain linux capabilities.\n"
                },
                "cgroupnsMode": {
                    "type": "string",
                    "description": "Cgroup namespace mode to use for the container. Possible values are: `private`, `host`.\n"
                },
                "command": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[\"/usr/bin/myprogram\",\"-f\",\"baz.con\"]`.\n"
                },
                "containerLogs": {
                    "type": "string",
                    "description": "The logs of the container if its execution is done (`attach` must be disabled).\n"
                },
                "containerReadRefreshTimeoutMilliseconds": {
                    "type": "integer",
                    "description": "The total number of milliseconds to wait for the container to reach status 'running'\n"
                },
                "cpuSet": {
                    "type": "string",
                    "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "CPU shares (relative weight) for the container.\n"
                },
                "destroyGraceSeconds": {
                    "type": "integer",
                    "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.\n"
                },
                "devices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerDevice:ContainerDevice"
                    },
                    "description": "Bind devices to the container.\n"
                },
                "dns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "DNS servers to use.\n"
                },
                "dnsOpts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n"
                },
                "dnsSearches": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n"
                },
                "domainname": {
                    "type": "string",
                    "description": "Domain name of the container.\n"
                },
                "entrypoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `\"/usr/bin/myprogra\"]`.\n"
                },
                "envs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
                },
                "exitCode": {
                    "type": "integer",
                    "description": "The exit code of the container if its execution is done (`must_run` must be disabled).\n"
                },
                "gpus": {
                    "type": "string",
                    "description": "GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.\n"
                },
                "groupAdds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional groups for the container user\n"
                },
                "healthcheck": {
                    "$ref": "#/types/docker:index/ContainerHealthcheck:ContainerHealthcheck",
                    "description": "A test to perform to check that the container is healthy\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname of the container.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerHost:ContainerHost"
                    },
                    "description": "Hostname to add\n"
                },
                "image": {
                    "type": "string",
                    "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.\n"
                },
                "init": {
                    "type": "boolean",
                    "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.\n"
                },
                "ipcMode": {
                    "type": "string",
                    "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:\u003cname|id\u003e` or `host`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerLabel:ContainerLabel"
                    },
                    "description": "User-defined key/value metadata.\n"
                },
                "logDriver": {
                    "type": "string",
                    "description": "The logging driver to use for the container.\n"
                },
                "logOpts": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value pairs to use as options for the logging driver.\n"
                },
                "logs": {
                    "type": "boolean",
                    "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
                },
                "maxRetryCount": {
                    "type": "integer",
                    "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The memory limit for the container in MBs.\n"
                },
                "memorySwap": {
                    "type": "integer",
                    "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `pulumi up` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
                },
                "mounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerMount:ContainerMount"
                    },
                    "description": "Specification for mounts to be added to containers created as part of the service.\n"
                },
                "mustRun": {
                    "type": "boolean",
                    "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name or id of the network to use. You can use `name` or `id` attribute from a `docker.Network` resource.\n"
                },
                "networkDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerNetworkData:ContainerNetworkData"
                    },
                    "description": "The data of the networks the container is connected to.\n"
                },
                "networkMode": {
                    "type": "string",
                    "description": "Network mode of the container.\n"
                },
                "networksAdvanced": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced"
                    },
                    "description": "The networks the container is attached to\n"
                },
                "pidMode": {
                    "type": "string",
                    "description": "he PID (Process) Namespace mode for the container. Either `container:\u003cname|id\u003e` or `host`.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerPort:ContainerPort"
                    },
                    "description": "Publish a container's port(s) to the host.\n"
                },
                "privileged": {
                    "type": "boolean",
                    "description": "If `true`, the container runs in privileged mode.\n"
                },
                "publishAllPorts": {
                    "type": "boolean",
                    "description": "Publish all ports of the container.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Whether the mount should be read-only.\n"
                },
                "removeVolumes": {
                    "type": "boolean",
                    "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
                },
                "restart": {
                    "type": "string",
                    "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
                },
                "rm": {
                    "type": "boolean",
                    "description": "If `true`, then the container will be automatically removed when it exits. Defaults to `false`.\n"
                },
                "runtime": {
                    "type": "string",
                    "description": "Runtime to use for the container.\n"
                },
                "securityOpts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.\n"
                },
                "shmSize": {
                    "type": "integer",
                    "description": "Size of `/dev/shm` in MBs.\n"
                },
                "start": {
                    "type": "boolean",
                    "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.\n"
                },
                "stdinOpen": {
                    "type": "boolean",
                    "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n"
                },
                "stopSignal": {
                    "type": "string",
                    "description": "Signal to stop a container (default `SIGTERM`).\n"
                },
                "stopTimeout": {
                    "type": "integer",
                    "description": "Timeout (in seconds) to stop a container.\n"
                },
                "storageOpts": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n"
                },
                "sysctls": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of kernel parameters (sysctls) to set in the container.\n"
                },
                "tmpfs": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
                },
                "tty": {
                    "type": "boolean",
                    "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n"
                },
                "ulimits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerUlimit:ContainerUlimit"
                    },
                    "description": "Ulimit options to add.\n"
                },
                "uploads": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerUpload:ContainerUpload"
                    },
                    "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.\n"
                },
                "user": {
                    "type": "string",
                    "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.\n"
                },
                "usernsMode": {
                    "type": "string",
                    "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerVolume:ContainerVolume"
                    },
                    "description": "Spec for mounting volumes in the container.\n"
                },
                "wait": {
                    "type": "boolean",
                    "description": "If `true`, then the Docker container is waited for being healthy state after creation. If `false`, then the container health state is not checked. Defaults to `false`.\n"
                },
                "waitTimeout": {
                    "type": "integer",
                    "description": "The timeout in seconds to wait the container to be healthy after creation. Defaults to `60`.\n"
                },
                "workingDir": {
                    "type": "string",
                    "description": "The working directory for commands to run in.\n"
                }
            },
            "required": [
                "bridge",
                "command",
                "containerLogs",
                "entrypoints",
                "envs",
                "exitCode",
                "healthcheck",
                "hostname",
                "image",
                "init",
                "ipcMode",
                "labels",
                "logDriver",
                "name",
                "networkDatas",
                "runtime",
                "securityOpts",
                "shmSize",
                "stopSignal",
                "stopTimeout"
            ],
            "inputProperties": {
                "attach": {
                    "type": "boolean",
                    "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
                },
                "capabilities": {
                    "$ref": "#/types/docker:index/ContainerCapabilities:ContainerCapabilities",
                    "description": "Add or drop certrain linux capabilities.\n",
                    "willReplaceOnChanges": true
                },
                "cgroupnsMode": {
                    "type": "string",
                    "description": "Cgroup namespace mode to use for the container. Possible values are: `private`, `host`.\n",
                    "willReplaceOnChanges": true
                },
                "command": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[\"/usr/bin/myprogram\",\"-f\",\"baz.con\"]`.\n",
                    "willReplaceOnChanges": true
                },
                "containerReadRefreshTimeoutMilliseconds": {
                    "type": "integer",
                    "description": "The total number of milliseconds to wait for the container to reach status 'running'\n"
                },
                "cpuSet": {
                    "type": "string",
                    "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "CPU shares (relative weight) for the container.\n"
                },
                "destroyGraceSeconds": {
                    "type": "integer",
                    "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.\n"
                },
                "devices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerDevice:ContainerDevice"
                    },
                    "description": "Bind devices to the container.\n",
                    "willReplaceOnChanges": true
                },
                "dns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "DNS servers to use.\n",
                    "willReplaceOnChanges": true
                },
                "dnsOpts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n",
                    "willReplaceOnChanges": true
                },
                "dnsSearches": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n",
                    "willReplaceOnChanges": true
                },
                "domainname": {
                    "type": "string",
                    "description": "Domain name of the container.\n",
                    "willReplaceOnChanges": true
                },
                "entrypoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `\"/usr/bin/myprogra\"]`.\n",
                    "willReplaceOnChanges": true
                },
                "envs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n",
                    "willReplaceOnChanges": true
                },
                "gpus": {
                    "type": "string",
                    "description": "GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.\n",
                    "willReplaceOnChanges": true
                },
                "groupAdds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Additional groups for the container user\n",
                    "willReplaceOnChanges": true
                },
                "healthcheck": {
                    "$ref": "#/types/docker:index/ContainerHealthcheck:ContainerHealthcheck",
                    "description": "A test to perform to check that the container is healthy\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "Hostname of the container.\n",
                    "willReplaceOnChanges": true
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerHost:ContainerHost"
                    },
                    "description": "Hostname to add\n",
                    "willReplaceOnChanges": true
                },
                "image": {
                    "type": "string",
                    "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.\n",
                    "willReplaceOnChanges": true
                },
                "init": {
                    "type": "boolean",
                    "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.\n"
                },
                "ipcMode": {
                    "type": "string",
                    "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:\u003cname|id\u003e` or `host`.\n",
                    "willReplaceOnChanges": true
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerLabel:ContainerLabel"
                    },
                    "description": "User-defined key/value metadata.\n",
                    "willReplaceOnChanges": true
                },
                "logDriver": {
                    "type": "string",
                    "description": "The logging driver to use for the container.\n",
                    "willReplaceOnChanges": true
                },
                "logOpts": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value pairs to use as options for the logging driver.\n",
                    "willReplaceOnChanges": true
                },
                "logs": {
                    "type": "boolean",
                    "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
                },
                "maxRetryCount": {
                    "type": "integer",
                    "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The memory limit for the container in MBs.\n"
                },
                "memorySwap": {
                    "type": "integer",
                    "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `pulumi up` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
                },
                "mounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerMount:ContainerMount"
                    },
                    "description": "Specification for mounts to be added to containers created as part of the service.\n",
                    "willReplaceOnChanges": true
                },
                "mustRun": {
                    "type": "boolean",
                    "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name or id of the network to use. You can use `name` or `id` attribute from a `docker.Network` resource.\n",
                    "willReplaceOnChanges": true
                },
                "networkMode": {
                    "type": "string",
                    "description": "Network mode of the container.\n",
                    "willReplaceOnChanges": true
                },
                "networksAdvanced": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced"
                    },
                    "description": "The networks the container is attached to\n",
                    "willReplaceOnChanges": true
                },
                "pidMode": {
                    "type": "string",
                    "description": "he PID (Process) Namespace mode for the container. Either `container:\u003cname|id\u003e` or `host`.\n",
                    "willReplaceOnChanges": true
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerPort:ContainerPort"
                    },
                    "description": "Publish a container's port(s) to the host.\n",
                    "willReplaceOnChanges": true
                },
                "privileged": {
                    "type": "boolean",
                    "description": "If `true`, the container runs in privileged mode.\n",
                    "willReplaceOnChanges": true
                },
                "publishAllPorts": {
                    "type": "boolean",
                    "description": "Publish all ports of the container.\n",
                    "willReplaceOnChanges": true
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "Whether the mount should be read-only.\n",
                    "willReplaceOnChanges": true
                },
                "removeVolumes": {
                    "type": "boolean",
                    "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
                },
                "restart": {
                    "type": "string",
                    "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
                },
                "rm": {
                    "type": "boolean",
                    "description": "If `true`, then the container will be automatically removed when it exits. Defaults to `false`.\n"
                },
                "runtime": {
                    "type": "string",
                    "description": "Runtime to use for the container.\n",
                    "willReplaceOnChanges": true
                },
                "securityOpts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.\n",
                    "willReplaceOnChanges": true
                },
                "shmSize": {
                    "type": "integer",
                    "description": "Size of `/dev/shm` in MBs.\n",
                    "willReplaceOnChanges": true
                },
                "start": {
                    "type": "boolean",
                    "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.\n"
                },
                "stdinOpen": {
                    "type": "boolean",
                    "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "stopSignal": {
                    "type": "string",
                    "description": "Signal to stop a container (default `SIGTERM`).\n",
                    "willReplaceOnChanges": true
                },
                "stopTimeout": {
                    "type": "integer",
                    "description": "Timeout (in seconds) to stop a container.\n",
                    "willReplaceOnChanges": true
                },
                "storageOpts": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n",
                    "willReplaceOnChanges": true
                },
                "sysctls": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of kernel parameters (sysctls) to set in the container.\n",
                    "willReplaceOnChanges": true
                },
                "tmpfs": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
                },
                "tty": {
                    "type": "boolean",
                    "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "ulimits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerUlimit:ContainerUlimit"
                    },
                    "description": "Ulimit options to add.\n",
                    "willReplaceOnChanges": true
                },
                "uploads": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerUpload:ContainerUpload"
                    },
                    "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.\n",
                    "willReplaceOnChanges": true
                },
                "user": {
                    "type": "string",
                    "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.\n",
                    "willReplaceOnChanges": true
                },
                "usernsMode": {
                    "type": "string",
                    "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n",
                    "willReplaceOnChanges": true
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ContainerVolume:ContainerVolume"
                    },
                    "description": "Spec for mounting volumes in the container.\n",
                    "willReplaceOnChanges": true
                },
                "wait": {
                    "type": "boolean",
                    "description": "If `true`, then the Docker container is waited for being healthy state after creation. If `false`, then the container health state is not checked. Defaults to `false`.\n"
                },
                "waitTimeout": {
                    "type": "integer",
                    "description": "The timeout in seconds to wait the container to be healthy after creation. Defaults to `60`.\n"
                },
                "workingDir": {
                    "type": "string",
                    "description": "The working directory for commands to run in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "image"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Container resources.\n",
                "properties": {
                    "attach": {
                        "type": "boolean",
                        "description": "If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.\n"
                    },
                    "bridge": {
                        "type": "string",
                        "description": "The network bridge of the container as read from its NetworkSettings.\n"
                    },
                    "capabilities": {
                        "$ref": "#/types/docker:index/ContainerCapabilities:ContainerCapabilities",
                        "description": "Add or drop certrain linux capabilities.\n",
                        "willReplaceOnChanges": true
                    },
                    "cgroupnsMode": {
                        "type": "string",
                        "description": "Cgroup namespace mode to use for the container. Possible values are: `private`, `host`.\n",
                        "willReplaceOnChanges": true
                    },
                    "command": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be `[\"/usr/bin/myprogram\",\"-f\",\"baz.con\"]`.\n",
                        "willReplaceOnChanges": true
                    },
                    "containerLogs": {
                        "type": "string",
                        "description": "The logs of the container if its execution is done (`attach` must be disabled).\n"
                    },
                    "containerReadRefreshTimeoutMilliseconds": {
                        "type": "integer",
                        "description": "The total number of milliseconds to wait for the container to reach status 'running'\n"
                    },
                    "cpuSet": {
                        "type": "string",
                        "description": "A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "CPU shares (relative weight) for the container.\n"
                    },
                    "destroyGraceSeconds": {
                        "type": "integer",
                        "description": "If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on successful stop.\n"
                    },
                    "devices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerDevice:ContainerDevice"
                        },
                        "description": "Bind devices to the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "dns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "DNS servers to use.\n",
                        "willReplaceOnChanges": true
                    },
                    "dnsOpts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.\n",
                        "willReplaceOnChanges": true
                    },
                    "dnsSearches": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "DNS search domains that are used when bare unqualified hostnames are used inside of the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "domainname": {
                        "type": "string",
                        "description": "Domain name of the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "entrypoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be `\"/usr/bin/myprogra\"]`.\n",
                        "willReplaceOnChanges": true
                    },
                    "envs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n",
                        "willReplaceOnChanges": true
                    },
                    "exitCode": {
                        "type": "integer",
                        "description": "The exit code of the container if its execution is done (`must_run` must be disabled).\n"
                    },
                    "gpus": {
                        "type": "string",
                        "description": "GPU devices to add to the container. Currently, only the value `all` is supported. Passing any other value will result in unexpected behavior.\n",
                        "willReplaceOnChanges": true
                    },
                    "groupAdds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Additional groups for the container user\n",
                        "willReplaceOnChanges": true
                    },
                    "healthcheck": {
                        "$ref": "#/types/docker:index/ContainerHealthcheck:ContainerHealthcheck",
                        "description": "A test to perform to check that the container is healthy\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "Hostname of the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerHost:ContainerHost"
                        },
                        "description": "Hostname to add\n",
                        "willReplaceOnChanges": true
                    },
                    "image": {
                        "type": "string",
                        "description": "The ID of the image to back this container. The easiest way to get this value is to use the `docker.RemoteImage` resource as is shown in the example.\n",
                        "willReplaceOnChanges": true
                    },
                    "init": {
                        "type": "boolean",
                        "description": "Configured whether an init process should be injected for this container. If unset this will default to the `dockerd` defaults.\n"
                    },
                    "ipcMode": {
                        "type": "string",
                        "description": "IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:\u003cname|id\u003e` or `host`.\n",
                        "willReplaceOnChanges": true
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerLabel:ContainerLabel"
                        },
                        "description": "User-defined key/value metadata.\n",
                        "willReplaceOnChanges": true
                    },
                    "logDriver": {
                        "type": "string",
                        "description": "The logging driver to use for the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "logOpts": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value pairs to use as options for the logging driver.\n",
                        "willReplaceOnChanges": true
                    },
                    "logs": {
                        "type": "boolean",
                        "description": "Save the container logs (`attach` must be enabled). Defaults to `false`.\n"
                    },
                    "maxRetryCount": {
                        "type": "integer",
                        "description": "The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The memory limit for the container in MBs.\n"
                    },
                    "memorySwap": {
                        "type": "integer",
                        "description": "The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `pulumi up` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.\n"
                    },
                    "mounts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerMount:ContainerMount"
                        },
                        "description": "Specification for mounts to be added to containers created as part of the service.\n",
                        "willReplaceOnChanges": true
                    },
                    "mustRun": {
                        "type": "boolean",
                        "description": "If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform\nassumes it is successful. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or id of the network to use. You can use `name` or `id` attribute from a `docker.Network` resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkDatas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerNetworkData:ContainerNetworkData"
                        },
                        "description": "The data of the networks the container is connected to.\n"
                    },
                    "networkMode": {
                        "type": "string",
                        "description": "Network mode of the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "networksAdvanced": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerNetworksAdvanced:ContainerNetworksAdvanced"
                        },
                        "description": "The networks the container is attached to\n",
                        "willReplaceOnChanges": true
                    },
                    "pidMode": {
                        "type": "string",
                        "description": "he PID (Process) Namespace mode for the container. Either `container:\u003cname|id\u003e` or `host`.\n",
                        "willReplaceOnChanges": true
                    },
                    "ports": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerPort:ContainerPort"
                        },
                        "description": "Publish a container's port(s) to the host.\n",
                        "willReplaceOnChanges": true
                    },
                    "privileged": {
                        "type": "boolean",
                        "description": "If `true`, the container runs in privileged mode.\n",
                        "willReplaceOnChanges": true
                    },
                    "publishAllPorts": {
                        "type": "boolean",
                        "description": "Publish all ports of the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "Whether the mount should be read-only.\n",
                        "willReplaceOnChanges": true
                    },
                    "removeVolumes": {
                        "type": "boolean",
                        "description": "If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.\n"
                    },
                    "restart": {
                        "type": "string",
                        "description": "The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.\n"
                    },
                    "rm": {
                        "type": "boolean",
                        "description": "If `true`, then the container will be automatically removed when it exits. Defaults to `false`.\n"
                    },
                    "runtime": {
                        "type": "string",
                        "description": "Runtime to use for the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "securityOpts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of string values to customize labels for MLS systems, such as SELinux. See https://docs.docker.com/engine/reference/run/#security-configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "shmSize": {
                        "type": "integer",
                        "description": "Size of `/dev/shm` in MBs.\n",
                        "willReplaceOnChanges": true
                    },
                    "start": {
                        "type": "boolean",
                        "description": "If `true`, then the Docker container will be started after creation. If `false`, then the container is only created. Defaults to `true`.\n"
                    },
                    "stdinOpen": {
                        "type": "boolean",
                        "description": "If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "stopSignal": {
                        "type": "string",
                        "description": "Signal to stop a container (default `SIGTERM`).\n",
                        "willReplaceOnChanges": true
                    },
                    "stopTimeout": {
                        "type": "integer",
                        "description": "Timeout (in seconds) to stop a container.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageOpts": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value pairs for the storage driver options, e.g. `size`: `120G`\n",
                        "willReplaceOnChanges": true
                    },
                    "sysctls": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of kernel parameters (sysctls) to set in the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "tmpfs": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.\n"
                    },
                    "tty": {
                        "type": "boolean",
                        "description": "If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "ulimits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerUlimit:ContainerUlimit"
                        },
                        "description": "Ulimit options to add.\n",
                        "willReplaceOnChanges": true
                    },
                    "uploads": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerUpload:ContainerUpload"
                        },
                        "description": "Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and at least one of them has to be set.\n",
                        "willReplaceOnChanges": true
                    },
                    "user": {
                        "type": "string",
                        "description": "User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by name.\n",
                        "willReplaceOnChanges": true
                    },
                    "usernsMode": {
                        "type": "string",
                        "description": "Sets the usernamespace mode for the container when usernamespace remapping option is enabled.\n",
                        "willReplaceOnChanges": true
                    },
                    "volumes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ContainerVolume:ContainerVolume"
                        },
                        "description": "Spec for mounting volumes in the container.\n",
                        "willReplaceOnChanges": true
                    },
                    "wait": {
                        "type": "boolean",
                        "description": "If `true`, then the Docker container is waited for being healthy state after creation. If `false`, then the container health state is not checked. Defaults to `false`.\n"
                    },
                    "waitTimeout": {
                        "type": "integer",
                        "description": "The timeout in seconds to wait the container to be healthy after creation. Defaults to `60`.\n"
                    },
                    "workingDir": {
                        "type": "string",
                        "description": "The working directory for commands to run in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "docker:index/image:Image": {
            "description": "`Image` builds a Docker image and pushes it Docker and OCI compatible registries.\nThis resource enables running Docker builds as part of a Pulumi deployment.\n\nNote: This resource does not delete tags, locally or remotely, when destroyed.\n\n## Image name\n\nThe Image resource uses `imageName` to refer to a fully qualified Docker image name, by the format `repository:tag`.\nNote that this does not include any digest information and thus will not cause any updates when passed to dependencies,\neven when using `latest` tag. To trigger such updates, e.g. when referencing pushed images in container orchestration \nand management resources, please use the `repoDigest` Output instead, which is of the format \n`repository@\u003calgorithm\u003e:\u003chash\u003e` and unique per build/push. \nAs of Docker v4.4, `repoDigest` is now available for local Images.\n\n## Cross-platform builds\n\nThe Image resource supports cross-platform builds when the [Docker engine has cross-platform support enabled via emulators](https://docs.docker.com/build/building/multi-platform/#building-multi-platform-images).\nThe Image resource currently supports providing only a single operating system and architecture in the `platform` field, e.g.: `linux/amd64`.\nTo enable this support, you may need to install the emulators in the environment running your Pulumi program.\n\nIf you are using Linux, you may be using Docker Engine or Docker Desktop for Linux, depending on how you have installed Docker. The [FAQ for Docker Desktop for Linux](https://docs.docker.com/desktop/faqs/linuxfaqs/#context) describes the differences and how to select which Docker context is in use.\n\n* For local development using Docker Desktop, this is enabled by default.\n* For systems using Docker Engine, install the QEMU binaries and register them with using the docker image from [github.com/tonistiigi/binfmt](https://github.com/tonistiigi/binfmt):\n\n  ```shell\n  docker run --privileged --rm tonistiigi/binfmt --install all\n  ```\n* In a GitHub Actions workflow, the [docker/setup-qemu-action](https://github.com/docker/setup-qemu-action) can be used instead by adding this step to your workflow file. Example workflow usage:\n\n  ```yaml\n  name: Pulumi\n  on:\n    push:\n      branches:\n        - master\n  jobs:\n    up:\n      name: Preview\n      runs-on: ubuntu-latest\n      steps:\n          # This is the step added:\n        - name: Set up QEMU\n          uses: docker/setup-qemu-action@v2\n          # The ordinary pulumi/actions workflow:\n        - uses: actions/checkout@v3\n        - uses: pulumi/actions@v4\n          with:\n            command: preview\n            stack-name: org-name/stack-name\n          env:\n            PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}\n  ```\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### A Docker image build\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst demoImage = new docker.Image(\"demo-image\", {\n    build: {\n        args: {\n            platform: \"linux/amd64\",\n        },\n        context: \".\",\n        dockerfile: \"Dockerfile\",\n    },\n    imageName: \"username/image:tag1\",\n    skipPush: true,\n});\nexport const imageName = demoImage.imageName;\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\ndemo_image = docker.Image(\"demo-image\",\n    build=docker.DockerBuildArgs(\n        args={\n            \"platform\": \"linux/amd64\",\n        },\n        context=\".\",\n        dockerfile=\"Dockerfile\",\n    ),\n    image_name=\"username/image:tag1\",\n    skip_push=True)\npulumi.export(\"imageName\", demo_image.image_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoImage = new Docker.Image(\"demo-image\", new()\n    {\n        Build = new Docker.Inputs.DockerBuildArgs\n        {\n            Args = \n            {\n                { \"platform\", \"linux/amd64\" },\n            },\n            Context = \".\",\n            Dockerfile = \"Dockerfile\",\n        },\n        ImageName = \"username/image:tag1\",\n        SkipPush = true,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"imageName\"] = demoImage.ImageName,\n    };\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdemoImage, err := docker.NewImage(ctx, \"demo-image\", \u0026docker.ImageArgs{\n\t\t\tBuild: \u0026docker.DockerBuildArgs{\n\t\t\t\tArgs: pulumi.StringMap{\n\t\t\t\t\t\"platform\": pulumi.String(\"linux/amd64\"),\n\t\t\t\t},\n\t\t\t\tContext:    pulumi.String(\".\"),\n\t\t\t\tDockerfile: pulumi.String(\"Dockerfile\"),\n\t\t\t},\n\t\t\tImageName: pulumi.String(\"username/image:tag1\"),\n\t\t\tSkipPush:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"imageName\", demoImage.ImageName)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nconfig: {}\ndescription: A Docker image build\nname: image-yaml\noutputs:\n    imageName: ${demo-image.imageName}\nresources:\n    demo-image:\n        options:\n            version: v4.4.0\n        properties:\n            build:\n                args:\n                    platform: linux/amd64\n                context: .\n                dockerfile: Dockerfile\n            imageName: username/image:tag1\n            skipPush: true\n        type: docker:Image\nruntime: yaml\nvariables: {}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Image;\nimport com.pulumi.docker.ImageArgs;\nimport com.pulumi.docker.inputs.DockerBuildArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoImage = new Image(\"demoImage\", ImageArgs.builder()        \n            .build(DockerBuildArgs.builder()\n                .args(Map.of(\"platform\", \"linux/amd64\"))\n                .context(\".\")\n                .dockerfile(\"Dockerfile\")\n                .build())\n            .imageName(\"username/image:tag1\")\n            .skipPush(true)\n            .build());\n\n        ctx.export(\"imageName\", demoImage.imageName());\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### A Docker image build and push\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst demoPushImage = new docker.Image(\"demo-push-image\", {\n    build: {\n        context: \".\",\n        dockerfile: \"Dockerfile\",\n    },\n    imageName: \"docker.io/username/push-image:tag1\",\n});\nexport const imageName = demoPushImage.imageName;\nexport const repoDigest = demoPushImage.repoDigest;\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\ndemo_push_image = docker.Image(\"demo-push-image\",\n    build=docker.DockerBuildArgs(\n        context=\".\",\n        dockerfile=\"Dockerfile\",\n    ),\n    image_name=\"docker.io/username/push-image:tag1\")\npulumi.export(\"imageName\", demo_push_image.image_name)\npulumi.export(\"repoDigest\", demo_push_image.repo_digest)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demoPushImage = new Docker.Image(\"demo-push-image\", new()\n    {\n        Build = new Docker.Inputs.DockerBuildArgs\n        {\n            Context = \".\",\n            Dockerfile = \"Dockerfile\",\n        },\n        ImageName = \"docker.io/username/push-image:tag1\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"imageName\"] = demoPushImage.ImageName,\n        [\"repoDigest\"] = demoPushImage.RepoDigest,\n    };\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdemoPushImage, err := docker.NewImage(ctx, \"demo-push-image\", \u0026docker.ImageArgs{\n\t\t\tBuild: \u0026docker.DockerBuildArgs{\n\t\t\t\tContext:    pulumi.String(\".\"),\n\t\t\t\tDockerfile: pulumi.String(\"Dockerfile\"),\n\t\t\t},\n\t\t\tImageName: pulumi.String(\"docker.io/username/push-image:tag1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"imageName\", demoPushImage.ImageName)\n\t\tctx.Export(\"repoDigest\", demoPushImage.RepoDigest)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nconfig: {}\ndescription: A Docker image build and push\nname: image-push-yaml\noutputs:\n    imageName: ${demo-push-image.imageName}\n    repoDigest: ${demo-push-image.repoDigest}\nresources:\n    demo-push-image:\n        options:\n            version: v4.4.0\n        properties:\n            build:\n                context: .\n                dockerfile: Dockerfile\n            imageName: docker.io/username/push-image:tag1\n        type: docker:Image\nruntime: yaml\nvariables: {}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Image;\nimport com.pulumi.docker.ImageArgs;\nimport com.pulumi.docker.inputs.DockerBuildArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demoPushImage = new Image(\"demoPushImage\", ImageArgs.builder()        \n            .build(DockerBuildArgs.builder()\n                .context(\".\")\n                .dockerfile(\"Dockerfile\")\n                .build())\n            .imageName(\"docker.io/username/push-image:tag1\")\n            .build());\n\n        ctx.export(\"imageName\", demoPushImage.imageName());\n        ctx.export(\"repoDigest\", demoPushImage.repoDigest());\n    }\n}\n```\n{{% /example %}}\n{{% example %}}\n### Docker image build using caching with AWS Elastic Container Registry\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ecrRepository = new aws.ecr.Repository(\"ecr-repository\", {name: \"docker-repository\"});\nconst authToken = aws.ecr.getAuthorizationTokenOutput({\n    registryId: ecrRepository.registryId,\n});\nconst myAppImage = new docker.Image(\"my-app-image\", {\n    build: {\n        args: {\n            BUILDKIT_INLINE_CACHE: \"1\",\n        },\n        cacheFrom: {\n            images: [pulumi.interpolate`${ecrRepository.repositoryUrl}:latest`],\n        },\n        context: \"app/\",\n        dockerfile: \"Dockerfile\",\n    },\n    imageName: pulumi.interpolate`${ecrRepository.repositoryUrl}:latest`,\n    registry: {\n        password: pulumi.secret(authToken.apply(authToken =\u003e authToken.password)),\n        server: ecrRepository.repositoryUrl,\n    },\n});\nexport const imageName = myAppImage.imageName;\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_docker as docker\n\necr_repository = aws.ecr.Repository(\"ecr-repository\", name=\"docker-repository\")\nauth_token = aws.ecr.get_authorization_token_output(registry_id=ecr_repository.registry_id)\nmy_app_image = docker.Image(\"my-app-image\",\n    build=docker.DockerBuildArgs(\n        args={\n            \"BUILDKIT_INLINE_CACHE\": \"1\",\n        },\n        cache_from=docker.CacheFromArgs(\n            images=[ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:latest\")],\n        ),\n        context=\"app/\",\n        dockerfile=\"Dockerfile\",\n    ),\n    image_name=ecr_repository.repository_url.apply(lambda repository_url: f\"{repository_url}:latest\"),\n    registry=docker.RegistryArgs(\n        password=pulumi.Output.secret(auth_token.password),\n        server=ecr_repository.repository_url,\n    ))\npulumi.export(\"imageName\", my_app_image.image_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ecrRepository = new Aws.Ecr.Repository(\"ecr-repository\", new()\n    {\n        Name = \"docker-repository\",\n    });\n\n    var authToken = Aws.Ecr.GetAuthorizationToken.Invoke(new()\n    {\n        RegistryId = ecrRepository.RegistryId,\n    });\n\n    var myAppImage = new Docker.Image(\"my-app-image\", new()\n    {\n        Build = new Docker.Inputs.DockerBuildArgs\n        {\n            Args = \n            {\n                { \"BUILDKIT_INLINE_CACHE\", \"1\" },\n            },\n            CacheFrom = new Docker.Inputs.CacheFromArgs\n            {\n                Images = new[]\n                {\n                    ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:latest\"),\n                },\n            },\n            Context = \"app/\",\n            Dockerfile = \"Dockerfile\",\n        },\n        ImageName = ecrRepository.RepositoryUrl.Apply(repositoryUrl =\u003e $\"{repositoryUrl}:latest\"),\n        Registry = new Docker.Inputs.RegistryArgs\n        {\n            Password = Output.CreateSecret(authToken.Apply(getAuthorizationTokenResult =\u003e getAuthorizationTokenResult.Password)),\n            Server = ecrRepository.RepositoryUrl,\n        },\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"imageName\"] = myAppImage.ImageName,\n    };\n});\n\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ecr\"\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tecrRepository, err := ecr.NewRepository(ctx, \"ecr-repository\", \u0026ecr.RepositoryArgs{\n\t\t\tName: pulumi.String(\"docker-repository\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tauthToken := ecr.GetAuthorizationTokenOutput(ctx, ecr.GetAuthorizationTokenOutputArgs{\n\t\t\tRegistryId: ecrRepository.RegistryId,\n\t\t}, nil)\n\t\tmyAppImage, err := docker.NewImage(ctx, \"my-app-image\", \u0026docker.ImageArgs{\n\t\t\tBuild: \u0026docker.DockerBuildArgs{\n\t\t\t\tArgs: pulumi.StringMap{\n\t\t\t\t\t\"BUILDKIT_INLINE_CACHE\": pulumi.String(\"1\"),\n\t\t\t\t},\n\t\t\t\tCacheFrom: \u0026docker.CacheFromArgs{\n\t\t\t\t\tImages: pulumi.StringArray{\n\t\t\t\t\t\tecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\t\t\t\treturn fmt.Sprintf(\"%v:latest\", repositoryUrl), nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContext:    pulumi.String(\"app/\"),\n\t\t\t\tDockerfile: pulumi.String(\"Dockerfile\"),\n\t\t\t},\n\t\t\tImageName: ecrRepository.RepositoryUrl.ApplyT(func(repositoryUrl string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"%v:latest\", repositoryUrl), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tRegistry: \u0026docker.RegistryArgs{\n\t\t\t\tPassword: pulumi.ToSecret(authToken.ApplyT(func(authToken ecr.GetAuthorizationTokenResult) (*string, error) {\n\t\t\t\t\treturn \u0026authToken.Password, nil\n\t\t\t\t}).(pulumi.StringPtrOutput)).(*pulumi.StringOutput),\n\t\t\t\tServer: ecrRepository.RepositoryUrl,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"imageName\", myAppImage.ImageName)\n\t\treturn nil\n\t})\n}\n```\n```yaml\nconfig: {}\ndescription: Docker image build using caching with AWS Elastic Container Registry\nname: image-caching-yaml\noutputs:\n    imageName: ${my-app-image.imageName}\nresources:\n    ecr-repository:\n        properties:\n            name: docker-repository\n        type: aws:ecr:Repository\n    my-app-image:\n        options:\n            version: v4.1.2\n        properties:\n            build:\n                args:\n                    BUILDKIT_INLINE_CACHE: \"1\"\n                cacheFrom:\n                    images:\n                        - ${ecr-repository.repositoryUrl}:latest\n                context: app/\n                dockerfile: Dockerfile\n            imageName: ${ecr-repository.repositoryUrl}:latest\n            registry:\n                password:\n                    fn::secret: ${authToken.password}\n                server: ${ecr-repository.repositoryUrl}\n        type: docker:Image\nruntime: yaml\nvariables:\n    authToken:\n        fn::aws:ecr:getAuthorizationToken:\n            registryId: ${ecr-repository.registryId}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ecr.Repository;\nimport com.pulumi.aws.ecr.RepositoryArgs;\nimport com.pulumi.aws.ecr.EcrFunctions;\nimport com.pulumi.aws.ecr.inputs.GetAuthorizationTokenArgs;\nimport com.pulumi.docker.Image;\nimport com.pulumi.docker.ImageArgs;\nimport com.pulumi.docker.inputs.DockerBuildArgs;\nimport com.pulumi.docker.inputs.CacheFromArgs;\nimport com.pulumi.docker.inputs.RegistryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ecrRepository = new Repository(\"ecrRepository\", RepositoryArgs.builder()        \n            .name(\"docker-repository\")\n            .build());\n\n        final var authToken = EcrFunctions.getAuthorizationToken(GetAuthorizationTokenArgs.builder()\n            .registryId(ecrRepository.registryId())\n            .build());\n\n        var myAppImage = new Image(\"myAppImage\", ImageArgs.builder()        \n            .build(DockerBuildArgs.builder()\n                .args(Map.of(\"BUILDKIT_INLINE_CACHE\", \"1\"))\n                .cacheFrom(CacheFromArgs.builder()\n                    .images(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:latest\", repositoryUrl)))\n                    .build())\n                .context(\"app/\")\n                .dockerfile(\"Dockerfile\")\n                .build())\n            .imageName(ecrRepository.repositoryUrl().applyValue(repositoryUrl -\u003e String.format(\"%s:latest\", repositoryUrl)))\n            .registry(RegistryArgs.builder()\n                .password(Output.ofSecret(authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult).applyValue(authToken -\u003e authToken.applyValue(getAuthorizationTokenResult -\u003e getAuthorizationTokenResult.password()))))\n                .server(ecrRepository.repositoryUrl())\n                .build())\n            .build());\n\n        ctx.export(\"imageName\", myAppImage.imageName());\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "baseImageName": {
                    "type": "string",
                    "description": "The fully qualified image name that was pushed to the registry."
                },
                "context": {
                    "type": "string",
                    "description": "The path to the build context to use."
                },
                "dockerfile": {
                    "type": "string",
                    "description": "The location of the Dockerfile relative to the docker build context."
                },
                "imageName": {
                    "type": "string",
                    "description": "The fully qualified image name"
                },
                "platform": {
                    "type": "string",
                    "description": "The image's architecture and OS"
                },
                "registryServer": {
                    "type": "string",
                    "description": "The name of the registry server hosting the image."
                },
                "repoDigest": {
                    "type": "string",
                    "description": "**For pushed images:**\nThe manifest digest of an image pushed to a registry, of the format repository@\u003calgorithm\u003e:\u003chash\u003e, e.g. `username/demo-image@sha256:a6ae6dd8d39c5bb02320e41abf00cd4cb35905fec540e37d306c878be8d38bd3`.\nThis reference is unique per image build and push. \nOnly available for images pushed to a registry.\nUse when passing a reference to a pushed image to container management resources.\n\n**Local-only images**:\nFor local images, this field is the image ID of the built local image, of the format \u003calgorithm\u003e:\u003chash\u003e, e.g `sha256:826a130323165bb0ccb0374ae774f885c067a951b51a6ee133577f4e5dbc4119` \n"
                }
            },
            "type": "object",
            "required": [
                "dockerfile",
                "context",
                "baseImageName",
                "registryServer",
                "imageName",
                "repoDigest"
            ],
            "inputProperties": {
                "build": {
                    "$ref": "#/types/docker:index/dockerBuild:DockerBuild",
                    "description": "The Docker build context"
                },
                "buildOnPreview": {
                    "type": "boolean",
                    "description": "A flag to build an image on preview",
                    "default": false
                },
                "imageName": {
                    "type": "string",
                    "description": "The image name, of the format repository[:tag], e.g. `docker.io/username/demo-image:v1`.\nThis reference is not unique to each build and push.For the unique manifest SHA of a pushed docker image, or the local image ID, please use `repoDigest`."
                },
                "registry": {
                    "$ref": "#/types/docker:index/registry:Registry",
                    "description": "The registry to push the image to"
                },
                "skipPush": {
                    "type": "boolean",
                    "description": "A flag to skip a registry push.",
                    "default": false
                }
            },
            "requiredInputs": [
                "imageName"
            ],
            "aliases": [
                {
                    "type": "docker:image:Image"
                }
            ]
        },
        "docker:index/network:Network": {
            "description": "\u003c!-- Bug: Type and Name are switched --\u003e\n`docker.Network` provides a docker network resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst privateNetwork = new docker.Network(\"privateNetwork\", {});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nprivate_network = docker.Network(\"privateNetwork\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var privateNetwork = new Docker.Network(\"privateNetwork\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewNetwork(ctx, \"privateNetwork\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Network;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var privateNetwork = new Network(\"privateNetwork\");\n\n    }\n}\n```\n```yaml\nresources:\n  privateNetwork:\n    type: docker:Network\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n### Example\n\n Assuming you created a `network` as follows\n\n #!/bin/bash\n\n docker network create foo\n\n prints the long ID\n\n 87b57a9b91ecab2db2a6dbf38df74c67d7c7108cbe479d6576574ec2cd8c2d73\n\n you provide the definition for the resource as follows\n\n terraform\n\n resource \"docker_network\" \"foo\" {\n\n\n\n name = \"foo\"\n\n }\n\n then the import command is as follows\n\n #!/bin/bash\n\n ```sh\n $ pulumi import docker:index/network:Network foo 87b57a9b91ecab2db2a6dbf38df74c67d7c7108cbe479d6576574ec2cd8c2d73\n```\n\n ",
            "properties": {
                "attachable": {
                    "type": "boolean",
                    "description": "Enable manual container attachment to the network.\n"
                },
                "checkDuplicate": {
                    "type": "boolean",
                    "description": "Requests daemon to check for networks with same name.\n"
                },
                "driver": {
                    "type": "string",
                    "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n"
                },
                "ingress": {
                    "type": "boolean",
                    "description": "Create swarm routing-mesh network. Defaults to `false`.\n"
                },
                "internal": {
                    "type": "boolean",
                    "description": "Whether the network is internal.\n"
                },
                "ipamConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/NetworkIpamConfig:NetworkIpamConfig"
                    },
                    "description": "The IPAM configuration options\n"
                },
                "ipamDriver": {
                    "type": "string",
                    "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n"
                },
                "ipamOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Provide explicit options to the IPAM driver. Valid options vary with `ipam_driver` and refer to that driver's documentation for more details.\n"
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "Enable IPv6 networking. Defaults to `false`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/NetworkLabel:NetworkLabel"
                    },
                    "description": "User-defined key/value metadata\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Docker network.\n"
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
                }
            },
            "required": [
                "driver",
                "internal",
                "ipamConfigs",
                "name",
                "options",
                "scope"
            ],
            "inputProperties": {
                "attachable": {
                    "type": "boolean",
                    "description": "Enable manual container attachment to the network.\n",
                    "willReplaceOnChanges": true
                },
                "checkDuplicate": {
                    "type": "boolean",
                    "description": "Requests daemon to check for networks with same name.\n",
                    "willReplaceOnChanges": true
                },
                "driver": {
                    "type": "string",
                    "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n",
                    "willReplaceOnChanges": true
                },
                "ingress": {
                    "type": "boolean",
                    "description": "Create swarm routing-mesh network. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "internal": {
                    "type": "boolean",
                    "description": "Whether the network is internal.\n",
                    "willReplaceOnChanges": true
                },
                "ipamConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/NetworkIpamConfig:NetworkIpamConfig"
                    },
                    "description": "The IPAM configuration options\n",
                    "willReplaceOnChanges": true
                },
                "ipamDriver": {
                    "type": "string",
                    "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n",
                    "willReplaceOnChanges": true
                },
                "ipamOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Provide explicit options to the IPAM driver. Valid options vary with `ipam_driver` and refer to that driver's documentation for more details.\n",
                    "willReplaceOnChanges": true
                },
                "ipv6": {
                    "type": "boolean",
                    "description": "Enable IPv6 networking. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/NetworkLabel:NetworkLabel"
                    },
                    "description": "User-defined key/value metadata\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Docker network.\n",
                    "willReplaceOnChanges": true
                },
                "options": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Network resources.\n",
                "properties": {
                    "attachable": {
                        "type": "boolean",
                        "description": "Enable manual container attachment to the network.\n",
                        "willReplaceOnChanges": true
                    },
                    "checkDuplicate": {
                        "type": "boolean",
                        "description": "Requests daemon to check for networks with same name.\n",
                        "willReplaceOnChanges": true
                    },
                    "driver": {
                        "type": "string",
                        "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n",
                        "willReplaceOnChanges": true
                    },
                    "ingress": {
                        "type": "boolean",
                        "description": "Create swarm routing-mesh network. Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "internal": {
                        "type": "boolean",
                        "description": "Whether the network is internal.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipamConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/NetworkIpamConfig:NetworkIpamConfig"
                        },
                        "description": "The IPAM configuration options\n",
                        "willReplaceOnChanges": true
                    },
                    "ipamDriver": {
                        "type": "string",
                        "description": "Driver used by the custom IP scheme of the network. Defaults to `default`\n",
                        "willReplaceOnChanges": true
                    },
                    "ipamOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Provide explicit options to the IPAM driver. Valid options vary with `ipam_driver` and refer to that driver's documentation for more details.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipv6": {
                        "type": "boolean",
                        "description": "Enable IPv6 networking. Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/NetworkLabel:NetworkLabel"
                        },
                        "description": "User-defined key/value metadata\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker network.\n",
                        "willReplaceOnChanges": true
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n",
                        "willReplaceOnChanges": true
                    },
                    "scope": {
                        "type": "string",
                        "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
                    }
                },
                "type": "object"
            }
        },
        "docker:index/plugin:Plugin": {
            "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nManages the lifecycle of a Docker plugin.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst sample_volume_plugin = new docker.Plugin(\"sample-volume-plugin\", {\n    alias: \"sample-volume-plugin\",\n    enableTimeout: 60,\n    enabled: false,\n    envs: [\"DEBUG=1\"],\n    forceDestroy: true,\n    forceDisable: true,\n    grantAllPermissions: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nsample_volume_plugin = docker.Plugin(\"sample-volume-plugin\",\n    alias=\"sample-volume-plugin\",\n    enable_timeout=60,\n    enabled=False,\n    envs=[\"DEBUG=1\"],\n    force_destroy=True,\n    force_disable=True,\n    grant_all_permissions=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sample_volume_plugin = new Docker.Plugin(\"sample-volume-plugin\", new()\n    {\n        Alias = \"sample-volume-plugin\",\n        EnableTimeout = 60,\n        Enabled = false,\n        Envs = new[]\n        {\n            \"DEBUG=1\",\n        },\n        ForceDestroy = true,\n        ForceDisable = true,\n        GrantAllPermissions = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewPlugin(ctx, \"sample-volume-plugin\", \u0026docker.PluginArgs{\n\t\t\tAlias:         pulumi.String(\"sample-volume-plugin\"),\n\t\t\tEnableTimeout: pulumi.Int(60),\n\t\t\tEnabled:       pulumi.Bool(false),\n\t\t\tEnvs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DEBUG=1\"),\n\t\t\t},\n\t\t\tForceDestroy:        pulumi.Bool(true),\n\t\t\tForceDisable:        pulumi.Bool(true),\n\t\t\tGrantAllPermissions: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Plugin;\nimport com.pulumi.docker.PluginArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sample_volume_plugin = new Plugin(\"sample-volume-plugin\", PluginArgs.builder()        \n            .alias(\"sample-volume-plugin\")\n            .enableTimeout(60)\n            .enabled(false)\n            .envs(\"DEBUG=1\")\n            .forceDestroy(true)\n            .forceDisable(true)\n            .grantAllPermissions(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  sample-volume-plugin:\n    type: docker:Plugin\n    properties:\n      alias: sample-volume-plugin\n      enableTimeout: 60\n      enabled: false\n      envs:\n        - DEBUG=1\n      forceDestroy: true\n      forceDisable: true\n      grantAllPermissions: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#!/bin/bash\n\n ```sh\n $ pulumi import docker:index/plugin:Plugin sample-volume-plugin \"$(docker plugin inspect -f {{.ID}} tiborvass/sample-volume-plugin:latest)\"\n```\n\n ",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "Docker Plugin alias\n"
                },
                "enableTimeout": {
                    "type": "integer",
                    "description": "HTTP client timeout to enable the plugin\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If `true` the plugin is enabled. Defaults to `true`\n"
                },
                "envs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
                },
                "forceDestroy": {
                    "type": "boolean",
                    "description": "If true, then the plugin is destroyed forcibly\n"
                },
                "forceDisable": {
                    "type": "boolean",
                    "description": "If true, then the plugin is disabled forcibly\n"
                },
                "grantAllPermissions": {
                    "type": "boolean",
                    "description": "If true, grant all permissions necessary to run the plugin\n"
                },
                "grantPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/PluginGrantPermission:PluginGrantPermission"
                    },
                    "description": "Grant specific permissions only\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the permission\n"
                },
                "pluginReference": {
                    "type": "string",
                    "description": "Docker Plugin Reference\n"
                }
            },
            "required": [
                "alias",
                "envs",
                "name",
                "pluginReference"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "Docker Plugin alias\n",
                    "willReplaceOnChanges": true
                },
                "enableTimeout": {
                    "type": "integer",
                    "description": "HTTP client timeout to enable the plugin\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If `true` the plugin is enabled. Defaults to `true`\n"
                },
                "envs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
                },
                "forceDestroy": {
                    "type": "boolean",
                    "description": "If true, then the plugin is destroyed forcibly\n"
                },
                "forceDisable": {
                    "type": "boolean",
                    "description": "If true, then the plugin is disabled forcibly\n"
                },
                "grantAllPermissions": {
                    "type": "boolean",
                    "description": "If true, grant all permissions necessary to run the plugin\n"
                },
                "grantPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/PluginGrantPermission:PluginGrantPermission"
                    },
                    "description": "Grant specific permissions only\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the permission\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Plugin resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "Docker Plugin alias\n",
                        "willReplaceOnChanges": true
                    },
                    "enableTimeout": {
                        "type": "integer",
                        "description": "HTTP client timeout to enable the plugin\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "If `true` the plugin is enabled. Defaults to `true`\n"
                    },
                    "envs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
                    },
                    "forceDestroy": {
                        "type": "boolean",
                        "description": "If true, then the plugin is destroyed forcibly\n"
                    },
                    "forceDisable": {
                        "type": "boolean",
                        "description": "If true, then the plugin is disabled forcibly\n"
                    },
                    "grantAllPermissions": {
                        "type": "boolean",
                        "description": "If true, grant all permissions necessary to run the plugin\n"
                    },
                    "grantPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/PluginGrantPermission:PluginGrantPermission"
                        },
                        "description": "Grant specific permissions only\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the permission\n",
                        "willReplaceOnChanges": true
                    },
                    "pluginReference": {
                        "type": "string",
                        "description": "Docker Plugin Reference\n"
                    }
                },
                "type": "object"
            }
        },
        "docker:index/registryImage:RegistryImage": {
            "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nManages the lifecycle of docker image in a registry. You can upload images to a registry (= `docker push`) and also delete them again\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nBuild an image with the `docker.RemoteImage` resource and then push it to a registry:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst helloworld = new docker.RegistryImage(\"helloworld\", {keepRemotely: true});\nconst image = new docker.RemoteImage(\"image\", {\n    name: \"registry.com/somename:1.0\",\n    build: {\n        context: `${path.cwd}/absolutePathToContextFolder`,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nhelloworld = docker.RegistryImage(\"helloworld\", keep_remotely=True)\nimage = docker.RemoteImage(\"image\",\n    name=\"registry.com/somename:1.0\",\n    build=docker.RemoteImageBuildArgs(\n        context=f\"{path['cwd']}/absolutePathToContextFolder\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var helloworld = new Docker.RegistryImage(\"helloworld\", new()\n    {\n        KeepRemotely = true,\n    });\n\n    var image = new Docker.RemoteImage(\"image\", new()\n    {\n        Name = \"registry.com/somename:1.0\",\n        Build = new Docker.Inputs.RemoteImageBuildArgs\n        {\n            Context = $\"{path.Cwd}/absolutePathToContextFolder\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewRegistryImage(ctx, \"helloworld\", \u0026docker.RegistryImageArgs{\n\t\t\tKeepRemotely: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewRemoteImage(ctx, \"image\", \u0026docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(\"registry.com/somename:1.0\"),\n\t\t\tBuild: \u0026docker.RemoteImageBuildArgs{\n\t\t\t\tContext: pulumi.String(fmt.Sprintf(\"%v/absolutePathToContextFolder\", path.Cwd)),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.RegistryImage;\nimport com.pulumi.docker.RegistryImageArgs;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport com.pulumi.docker.inputs.RemoteImageBuildArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var helloworld = new RegistryImage(\"helloworld\", RegistryImageArgs.builder()        \n            .keepRemotely(true)\n            .build());\n\n        var image = new RemoteImage(\"image\", RemoteImageArgs.builder()        \n            .name(\"registry.com/somename:1.0\")\n            .build(RemoteImageBuildArgs.builder()\n                .context(String.format(\"%s/absolutePathToContextFolder\", path.cwd()))\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  helloworld:\n    type: docker:RegistryImage\n    properties:\n      keepRemotely: true\n  image:\n    type: docker:RemoteImage\n    properties:\n      name: registry.com/somename:1.0\n      build:\n        context: ${path.cwd}/absolutePathToContextFolder\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "insecureSkipVerify": {
                    "type": "boolean",
                    "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
                },
                "keepRemotely": {
                    "type": "boolean",
                    "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Docker image.\n"
                },
                "sha256Digest": {
                    "type": "string",
                    "description": "The sha256 digest of the image.\n"
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of arbitrary strings that, when changed, will force the `docker.RegistryImage` resource to be replaced. This can be used to repush a local image\n"
                }
            },
            "required": [
                "name",
                "sha256Digest"
            ],
            "inputProperties": {
                "insecureSkipVerify": {
                    "type": "boolean",
                    "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
                },
                "keepRemotely": {
                    "type": "boolean",
                    "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Docker image.\n",
                    "willReplaceOnChanges": true
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of arbitrary strings that, when changed, will force the `docker.RegistryImage` resource to be replaced. This can be used to repush a local image\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RegistryImage resources.\n",
                "properties": {
                    "insecureSkipVerify": {
                        "type": "boolean",
                        "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
                    },
                    "keepRemotely": {
                        "type": "boolean",
                        "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker image.\n",
                        "willReplaceOnChanges": true
                    },
                    "sha256Digest": {
                        "type": "string",
                        "description": "The sha256 digest of the image.\n"
                    },
                    "triggers": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of arbitrary strings that, when changed, will force the `docker.RegistryImage` resource to be replaced. This can be used to repush a local image\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "docker:index/remoteImage:RemoteImage": {
            "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nPulls a Docker image to a given Docker host from a Docker Registry.\n This resource will *not* pull new layers of the image automatically unless used in conjunction with docker.RegistryImage data source to update the `pull_triggers` field.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n\nFinds and downloads the latest `ubuntu:precise` image but does not check\nfor further updates of the image\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntu = new docker.RemoteImage(\"ubuntu\", {name: \"ubuntu:precise\"});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu = docker.RemoteImage(\"ubuntu\", name=\"ubuntu:precise\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntu = new Docker.RemoteImage(\"ubuntu\", new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewRemoteImage(ctx, \"ubuntu\", \u0026docker.RemoteImageArgs{\n\t\t\tName: pulumi.String(\"ubuntu:precise\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntu = new RemoteImage(\"ubuntu\", RemoteImageArgs.builder()        \n            .name(\"ubuntu:precise\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntu:\n    type: docker:RemoteImage\n    properties:\n      name: ubuntu:precise\n```\n{{% /example %}}\n{{% example %}}\n### Dynamic updates\n\nTo be able to update an image dynamically when the `sha256` sum changes,\nyou need to use it in combination with `docker.RegistryImage` as follows:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntuRegistryImage = docker.getRegistryImage({\n    name: \"ubuntu:precise\",\n});\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {\n    name: ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.name),\n    pullTriggers: [ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.sha256Digest)],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu_registry_image = docker.get_registry_image(name=\"ubuntu:precise\")\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\",\n    name=ubuntu_registry_image.name,\n    pull_triggers=[ubuntu_registry_image.sha256_digest])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuRegistryImage = Docker.GetRegistryImage.Invoke(new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n    var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new()\n    {\n        Name = ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Name),\n        PullTriggers = new[]\n        {\n            ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Sha256Digest),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tubuntuRegistryImage, err := docker.LookupRegistryImage(ctx, \u0026docker.LookupRegistryImageArgs{\n\t\t\tName: \"ubuntu:precise\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", \u0026docker.RemoteImageArgs{\n\t\t\tName: *pulumi.String(ubuntuRegistryImage.Name),\n\t\t\tPullTriggers: pulumi.StringArray{\n\t\t\t\t*pulumi.String(ubuntuRegistryImage.Sha256Digest),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetRegistryImageArgs;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ubuntuRegistryImage = DockerFunctions.getRegistryImage(GetRegistryImageArgs.builder()\n            .name(\"ubuntu:precise\")\n            .build());\n\n        var ubuntuRemoteImage = new RemoteImage(\"ubuntuRemoteImage\", RemoteImageArgs.builder()        \n            .name(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.name()))\n            .pullTriggers(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.sha256Digest()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuRemoteImage:\n    type: docker:RemoteImage\n    properties:\n      name: ${ubuntuRegistryImage.name}\n      pullTriggers:\n        - ${ubuntuRegistryImage.sha256Digest}\nvariables:\n  ubuntuRegistryImage:\n    fn::invoke:\n      Function: docker:getRegistryImage\n      Arguments:\n        name: ubuntu:precise\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "build": {
                    "$ref": "#/types/docker:index/RemoteImageBuild:RemoteImageBuild",
                    "description": "Configuration to build an image. Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
                },
                "forceRemove": {
                    "type": "boolean",
                    "description": "Always remove intermediate containers\n"
                },
                "imageId": {
                    "type": "string",
                    "description": "The ID of the image (as seen when executing `docker inspect` on the image). Can be used to reference the image via its ID in other resources.\n"
                },
                "keepLocally": {
                    "type": "boolean",
                    "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.\n"
                },
                "name": {
                    "type": "string",
                    "description": "type of ulimit, e.g. `nofile`\n"
                },
                "platform": {
                    "type": "string",
                    "description": "Set platform if server is multi-platform capable\n"
                },
                "pullTriggers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.\n"
                },
                "repoDigest": {
                    "type": "string",
                    "description": "The image sha256 digest in the form of `repo[:tag]@sha256:\u003chash\u003e`.\n"
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change\n"
                }
            },
            "required": [
                "imageId",
                "name",
                "repoDigest"
            ],
            "inputProperties": {
                "build": {
                    "$ref": "#/types/docker:index/RemoteImageBuild:RemoteImageBuild",
                    "description": "Configuration to build an image. Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
                },
                "forceRemove": {
                    "type": "boolean",
                    "description": "Always remove intermediate containers\n"
                },
                "keepLocally": {
                    "type": "boolean",
                    "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.\n"
                },
                "name": {
                    "type": "string",
                    "description": "type of ulimit, e.g. `nofile`\n",
                    "willReplaceOnChanges": true
                },
                "platform": {
                    "type": "string",
                    "description": "Set platform if server is multi-platform capable\n",
                    "willReplaceOnChanges": true
                },
                "pullTriggers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.\n",
                    "willReplaceOnChanges": true
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "name"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RemoteImage resources.\n",
                "properties": {
                    "build": {
                        "$ref": "#/types/docker:index/RemoteImageBuild:RemoteImageBuild",
                        "description": "Configuration to build an image. Please see [docker build command reference](https://docs.docker.com/engine/reference/commandline/build/#options) too.\n"
                    },
                    "forceRemove": {
                        "type": "boolean",
                        "description": "Always remove intermediate containers\n"
                    },
                    "imageId": {
                        "type": "string",
                        "description": "The ID of the image (as seen when executing `docker inspect` on the image). Can be used to reference the image via its ID in other resources.\n"
                    },
                    "keepLocally": {
                        "type": "boolean",
                        "description": "If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker local storage on destroy operation.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "type of ulimit, e.g. `nofile`\n",
                        "willReplaceOnChanges": true
                    },
                    "platform": {
                        "type": "string",
                        "description": "Set platform if server is multi-platform capable\n",
                        "willReplaceOnChanges": true
                    },
                    "pullTriggers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of values which cause an image pull when changed. This is used to store the image digest from the registry when using the docker*registry*image.\n",
                        "willReplaceOnChanges": true
                    },
                    "repoDigest": {
                        "type": "string",
                        "description": "The image sha256 digest in the form of `repo[:tag]@sha256:\u003chash\u003e`.\n"
                    },
                    "triggers": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of arbitrary strings that, when changed, will force the `docker.RemoteImage` resource to be replaced. This can be used to rebuild an image when contents of source code folders change\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "docker:index/secret:Secret": {
            "description": "\n\n\n## Import\n\n#!/bin/bash\n\n Docker secret cannot be imported as the secret data, once set, is never exposed again.\n\n ",
            "properties": {
                "data": {
                    "type": "string",
                    "description": "Base64-url-safe-encoded secret data\n",
                    "secret": true
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/SecretLabel:SecretLabel"
                    },
                    "description": "User-defined key/value metadata\n"
                },
                "name": {
                    "type": "string",
                    "description": "User-defined name of the secret\n"
                }
            },
            "required": [
                "data",
                "name"
            ],
            "inputProperties": {
                "data": {
                    "type": "string",
                    "description": "Base64-url-safe-encoded secret data\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/SecretLabel:SecretLabel"
                    },
                    "description": "User-defined key/value metadata\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "User-defined name of the secret\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "data"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Secret resources.\n",
                "properties": {
                    "data": {
                        "type": "string",
                        "description": "Base64-url-safe-encoded secret data\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/SecretLabel:SecretLabel"
                        },
                        "description": "User-defined key/value metadata\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "User-defined name of the secret\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "docker:index/service:Service": {
            "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nThis resource manages the lifecycle of a Docker service. By default, the creation, update and delete of services are detached.\n With the Converge Config Name of the service\n- `task_spec` (Block List, Min: 1, Max: 1) User modifiable task configuration (see below for nested schema)\n\n\n## Import\n\n### Example\n\n Assuming you created a `service` as follows\n\n #!/bin/bash\n\n docker service create --name foo -p 8080:80 nginx\n\n prints th ID\n\n 4pcphbxkfn2rffhbhe6czytgi\n\n you provide the definition for the resource as follows\n\n terraform\n\n resource \"docker_service\" \"foo\" {\n\n\n\n name = \"foo\"\n\n\n\n task_spec {\n\n\n\n\n\n container_spec {\n\n\n\n\n\n\n\n image = \"nginx\"\n\n\n\n\n\n }\n\n\n\n }\n\n\n\n endpoint_spec {\n\n\n\n\n\n ports {\n\n\n\n\n\n\n\n target_port\n\n\n\n= \"80\"\n\n\n\n\n\n\n\n published_port = \"8080\"\n\n\n\n\n\n }\n\n\n\n }\n\n }\n\n then the import command is as follows\n\n #!/bin/bash\n\n ```sh\n $ pulumi import docker:index/service:Service foo 4pcphbxkfn2rffhbhe6czytgi\n```\n\n ",
            "properties": {
                "auth": {
                    "$ref": "#/types/docker:index/ServiceAuth:ServiceAuth",
                    "description": "Configuration for the authentication for pulling the images of the service\n"
                },
                "convergeConfig": {
                    "$ref": "#/types/docker:index/ServiceConvergeConfig:ServiceConvergeConfig",
                    "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
                },
                "endpointSpec": {
                    "$ref": "#/types/docker:index/ServiceEndpointSpec:ServiceEndpointSpec",
                    "description": "Properties that can be configured to access and load balance a service\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceLabel:ServiceLabel"
                    },
                    "description": "User-defined key/value metadata\n"
                },
                "mode": {
                    "$ref": "#/types/docker:index/ServiceMode:ServiceMode",
                    "description": "Scheduling mode for the service\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service\n"
                },
                "rollbackConfig": {
                    "$ref": "#/types/docker:index/ServiceRollbackConfig:ServiceRollbackConfig",
                    "description": "Specification for the rollback strategy of the service\n"
                },
                "taskSpec": {
                    "$ref": "#/types/docker:index/ServiceTaskSpec:ServiceTaskSpec",
                    "description": "User modifiable task configuration\n"
                },
                "updateConfig": {
                    "$ref": "#/types/docker:index/ServiceUpdateConfig:ServiceUpdateConfig",
                    "description": "Specification for the update strategy of the service\n"
                }
            },
            "required": [
                "endpointSpec",
                "labels",
                "mode",
                "name",
                "taskSpec"
            ],
            "inputProperties": {
                "auth": {
                    "$ref": "#/types/docker:index/ServiceAuth:ServiceAuth",
                    "description": "Configuration for the authentication for pulling the images of the service\n",
                    "willReplaceOnChanges": true
                },
                "convergeConfig": {
                    "$ref": "#/types/docker:index/ServiceConvergeConfig:ServiceConvergeConfig",
                    "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
                },
                "endpointSpec": {
                    "$ref": "#/types/docker:index/ServiceEndpointSpec:ServiceEndpointSpec",
                    "description": "Properties that can be configured to access and load balance a service\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/ServiceLabel:ServiceLabel"
                    },
                    "description": "User-defined key/value metadata\n"
                },
                "mode": {
                    "$ref": "#/types/docker:index/ServiceMode:ServiceMode",
                    "description": "Scheduling mode for the service\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service\n",
                    "willReplaceOnChanges": true
                },
                "rollbackConfig": {
                    "$ref": "#/types/docker:index/ServiceRollbackConfig:ServiceRollbackConfig",
                    "description": "Specification for the rollback strategy of the service\n"
                },
                "taskSpec": {
                    "$ref": "#/types/docker:index/ServiceTaskSpec:ServiceTaskSpec",
                    "description": "User modifiable task configuration\n"
                },
                "updateConfig": {
                    "$ref": "#/types/docker:index/ServiceUpdateConfig:ServiceUpdateConfig",
                    "description": "Specification for the update strategy of the service\n"
                }
            },
            "requiredInputs": [
                "taskSpec"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Service resources.\n",
                "properties": {
                    "auth": {
                        "$ref": "#/types/docker:index/ServiceAuth:ServiceAuth",
                        "description": "Configuration for the authentication for pulling the images of the service\n",
                        "willReplaceOnChanges": true
                    },
                    "convergeConfig": {
                        "$ref": "#/types/docker:index/ServiceConvergeConfig:ServiceConvergeConfig",
                        "description": "A configuration to ensure that a service converges aka reaches the desired that of all task up and running\n"
                    },
                    "endpointSpec": {
                        "$ref": "#/types/docker:index/ServiceEndpointSpec:ServiceEndpointSpec",
                        "description": "Properties that can be configured to access and load balance a service\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/ServiceLabel:ServiceLabel"
                        },
                        "description": "User-defined key/value metadata\n"
                    },
                    "mode": {
                        "$ref": "#/types/docker:index/ServiceMode:ServiceMode",
                        "description": "Scheduling mode for the service\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the service\n",
                        "willReplaceOnChanges": true
                    },
                    "rollbackConfig": {
                        "$ref": "#/types/docker:index/ServiceRollbackConfig:ServiceRollbackConfig",
                        "description": "Specification for the rollback strategy of the service\n"
                    },
                    "taskSpec": {
                        "$ref": "#/types/docker:index/ServiceTaskSpec:ServiceTaskSpec",
                        "description": "User modifiable task configuration\n"
                    },
                    "updateConfig": {
                        "$ref": "#/types/docker:index/ServiceUpdateConfig:ServiceUpdateConfig",
                        "description": "Specification for the update strategy of the service\n"
                    }
                },
                "type": "object"
            }
        },
        "docker:index/serviceConfig:ServiceConfig": {
            "description": "\n\n\n## Import\n\n### Example\n\n Assuming you created a `config` as follows\n\n #!/bin/bash\n\n printf '{\"a\":\"b\"}' | docker config create foo -\n\n prints the id\n\n 08c26c477474478d971139f750984775a7f019dbe8a2e7f09d66a187c009e66d\n\n you provide the definition for the resource as follows\n\n terraform\n\n resource \"docker_config\" \"foo\" {\n\n\n\n name = \"foo\"\n\n\n\n data = base64encode(\"{\\\"a\\\": \\\"b\\\"}\")\n\n }\n\n then the import command is as follows\n\n #!/bin/bash\n\n ```sh\n $ pulumi import docker:index/serviceConfig:ServiceConfig foo 08c26c477474478d971139f750984775a7f019dbe8a2e7f09d66a187c009e66d\n```\n\n ",
            "properties": {
                "data": {
                    "type": "string",
                    "description": "Base64-url-safe-encoded config data\n"
                },
                "name": {
                    "type": "string",
                    "description": "User-defined name of the config\n"
                }
            },
            "required": [
                "data",
                "name"
            ],
            "inputProperties": {
                "data": {
                    "type": "string",
                    "description": "Base64-url-safe-encoded config data\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "User-defined name of the config\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "data"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceConfig resources.\n",
                "properties": {
                    "data": {
                        "type": "string",
                        "description": "Base64-url-safe-encoded config data\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "User-defined name of the config\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "docker:index/tag:Tag": {
            "description": "Creates a docker tag. It has the exact same functionality as the `docker tag` command. Deleting the resource will neither delete the source nor target images. The source image must exist on the machine running the docker daemon.\n",
            "properties": {
                "sourceImage": {
                    "type": "string",
                    "description": "Name of the source image.\n"
                },
                "sourceImageId": {
                    "type": "string",
                    "description": "ImageID of the source image in the format of `sha256:\u003c\u003cID\u003e\u003e`\n"
                },
                "targetImage": {
                    "type": "string",
                    "description": "Name of the target image.\n"
                }
            },
            "required": [
                "sourceImage",
                "sourceImageId",
                "targetImage"
            ],
            "inputProperties": {
                "sourceImage": {
                    "type": "string",
                    "description": "Name of the source image.\n",
                    "willReplaceOnChanges": true
                },
                "targetImage": {
                    "type": "string",
                    "description": "Name of the target image.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "sourceImage",
                "targetImage"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "sourceImage": {
                        "type": "string",
                        "description": "Name of the source image.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceImageId": {
                        "type": "string",
                        "description": "ImageID of the source image in the format of `sha256:\u003c\u003cID\u003e\u003e`\n"
                    },
                    "targetImage": {
                        "type": "string",
                        "description": "Name of the target image.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "docker:index/volume:Volume": {
            "description": "\u003c!-- Bug: Type and Name are switched --\u003e\nCreates and destroys a volume in Docker. This can be used alongside docker.Container to prepare volumes that can be shared across containers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst sharedVolume = new docker.Volume(\"sharedVolume\", {});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nshared_volume = docker.Volume(\"sharedVolume\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sharedVolume = new Docker.Volume(\"sharedVolume\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.NewVolume(ctx, \"sharedVolume\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.Volume;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sharedVolume = new Volume(\"sharedVolume\");\n\n    }\n}\n```\n```yaml\nresources:\n  sharedVolume:\n    type: docker:Volume\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n### Example\n\n Assuming you created a `volume` as follows\n\n #!/bin/bash\n\n docker volume create\n\n prints the long ID\n\n 524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d\n\n you provide the definition for the resource as follows\n\n terraform\n\n resource \"docker_volume\" \"foo\" {\n\n\n\n name = \"524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d\"\n\n }\n\n then the import command is as follows\n\n #!/bin/bash\n\n ```sh\n $ pulumi import docker:index/volume:Volume foo 524b0457aa2a87dd2b75c74c3e4e53f406974249e63ab3ed9bf21e5644f9dc7d\n```\n\n ",
            "properties": {
                "driver": {
                    "type": "string",
                    "description": "Driver type for the volume. Defaults to `local`.\n"
                },
                "driverOpts": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Options specific to the driver.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/VolumeLabel:VolumeLabel"
                    },
                    "description": "User-defined key/value metadata\n"
                },
                "mountpoint": {
                    "type": "string",
                    "description": "The mountpoint of the volume.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Docker volume (will be generated if not provided).\n"
                }
            },
            "required": [
                "driver",
                "mountpoint",
                "name"
            ],
            "inputProperties": {
                "driver": {
                    "type": "string",
                    "description": "Driver type for the volume. Defaults to `local`.\n",
                    "willReplaceOnChanges": true
                },
                "driverOpts": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Options specific to the driver.\n",
                    "willReplaceOnChanges": true
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/docker:index/VolumeLabel:VolumeLabel"
                    },
                    "description": "User-defined key/value metadata\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Docker volume (will be generated if not provided).\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Volume resources.\n",
                "properties": {
                    "driver": {
                        "type": "string",
                        "description": "Driver type for the volume. Defaults to `local`.\n",
                        "willReplaceOnChanges": true
                    },
                    "driverOpts": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Options specific to the driver.\n",
                        "willReplaceOnChanges": true
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/VolumeLabel:VolumeLabel"
                        },
                        "description": "User-defined key/value metadata\n",
                        "willReplaceOnChanges": true
                    },
                    "mountpoint": {
                        "type": "string",
                        "description": "The mountpoint of the volume.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker volume (will be generated if not provided).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "docker:index/getLogs:getLogs": {
            "description": "`docker.getLogs` provides logs from specific container\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLogs.\n",
                "properties": {
                    "details": {
                        "type": "boolean"
                    },
                    "discardHeaders": {
                        "type": "boolean",
                        "description": "Discard headers that docker appends to each log entry\n"
                    },
                    "follow": {
                        "type": "boolean"
                    },
                    "logsListStringEnabled": {
                        "type": "boolean",
                        "description": "If true populate computed value `logs_list_string`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker Container\n"
                    },
                    "showStderr": {
                        "type": "boolean"
                    },
                    "showStdout": {
                        "type": "boolean"
                    },
                    "since": {
                        "type": "string"
                    },
                    "tail": {
                        "type": "string"
                    },
                    "timestamps": {
                        "type": "boolean"
                    },
                    "until": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLogs.\n",
                "properties": {
                    "details": {
                        "type": "boolean"
                    },
                    "discardHeaders": {
                        "type": "boolean",
                        "description": "Discard headers that docker appends to each log entry\n"
                    },
                    "follow": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "logsListStringEnabled": {
                        "type": "boolean",
                        "description": "If true populate computed value `logs_list_string`\n"
                    },
                    "logsListStrings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of container logs, each element is a line.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker Container\n"
                    },
                    "showStderr": {
                        "type": "boolean"
                    },
                    "showStdout": {
                        "type": "boolean"
                    },
                    "since": {
                        "type": "string"
                    },
                    "tail": {
                        "type": "string"
                    },
                    "timestamps": {
                        "type": "boolean"
                    },
                    "until": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "logsListStrings",
                    "name",
                    "id"
                ]
            }
        },
        "docker:index/getNetwork:getNetwork": {
            "description": "`docker.Network` provides details about a specific Docker Network.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst main = docker.getNetwork({\n    name: \"main\",\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nmain = docker.get_network(name=\"main\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = Docker.GetNetwork.Invoke(new()\n    {\n        Name = \"main\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.LookupNetwork(ctx, \u0026docker.LookupNetworkArgs{\n\t\t\tName: \"main\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var main = DockerFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"main\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  main:\n    fn::invoke:\n      Function: docker:getNetwork\n      Arguments:\n        name: main\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetwork.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker network.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetwork.\n",
                "properties": {
                    "driver": {
                        "type": "string",
                        "description": "The driver of the Docker network. Possible values are `bridge`, `host`, `overlay`, `macvlan`. See [network docs](https://docs.docker.com/network/#network-drivers) for more details.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of this resource.\n"
                    },
                    "internal": {
                        "type": "boolean",
                        "description": "If `true`, the network is internal.\n"
                    },
                    "ipamConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/docker:index/getNetworkIpamConfig:getNetworkIpamConfig"
                        },
                        "description": "The IPAM configuration options\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker network.\n"
                    },
                    "options": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Only available with bridge networks. See [bridge options docs](https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options) for more details.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Scope of the network. One of `swarm`, `global`, or `local`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "driver",
                    "id",
                    "internal",
                    "ipamConfigs",
                    "name",
                    "options",
                    "scope"
                ]
            }
        },
        "docker:index/getPlugin:getPlugin": {
            "description": "Reads the local Docker plugin. The plugin must be installed locally.\n\n{{% examples %}}\n## Example Usage\n\n### With alias\ndata \"docker.Plugin\" \"by_alias\" {\n  alias = \"sample-volume-plugin:latest\"\n}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPlugin.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias of the Docker plugin. If the tag is omitted, `:latest` is complemented to the attribute value.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of the plugin, which has precedence over the `alias` of both are given\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPlugin.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias of the Docker plugin. If the tag is omitted, `:latest` is complemented to the attribute value.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "If `true` the plugin is enabled\n"
                    },
                    "envs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The environment variables in the form of `KEY=VALUE`, e.g. `DEBUG=0`\n"
                    },
                    "grantAllPermissions": {
                        "type": "boolean",
                        "description": "If true, grant all permissions necessary to run the plugin\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of the plugin, which has precedence over the `alias` of both are given\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The plugin name. If the tag is omitted, `:latest` is complemented to the attribute value.\n"
                    },
                    "pluginReference": {
                        "type": "string",
                        "description": "The Docker Plugin Reference\n"
                    }
                },
                "type": "object",
                "required": [
                    "enabled",
                    "envs",
                    "grantAllPermissions",
                    "name",
                    "pluginReference"
                ]
            }
        },
        "docker:index/getRegistryImage:getRegistryImage": {
            "description": "Reads the image metadata from a Docker Registry. Used in conjunction with the docker.RemoteImage resource to keep an image up to date on the latest available version of the tag.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst ubuntuRegistryImage = docker.getRegistryImage({\n    name: \"ubuntu:precise\",\n});\nconst ubuntuRemoteImage = new docker.RemoteImage(\"ubuntuRemoteImage\", {\n    name: ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.name),\n    pullTriggers: [ubuntuRegistryImage.then(ubuntuRegistryImage =\u003e ubuntuRegistryImage.sha256Digest)],\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nubuntu_registry_image = docker.get_registry_image(name=\"ubuntu:precise\")\nubuntu_remote_image = docker.RemoteImage(\"ubuntuRemoteImage\",\n    name=ubuntu_registry_image.name,\n    pull_triggers=[ubuntu_registry_image.sha256_digest])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuRegistryImage = Docker.GetRegistryImage.Invoke(new()\n    {\n        Name = \"ubuntu:precise\",\n    });\n\n    var ubuntuRemoteImage = new Docker.RemoteImage(\"ubuntuRemoteImage\", new()\n    {\n        Name = ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Name),\n        PullTriggers = new[]\n        {\n            ubuntuRegistryImage.Apply(getRegistryImageResult =\u003e getRegistryImageResult.Sha256Digest),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tubuntuRegistryImage, err := docker.LookupRegistryImage(ctx, \u0026docker.LookupRegistryImageArgs{\n\t\t\tName: \"ubuntu:precise\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.NewRemoteImage(ctx, \"ubuntuRemoteImage\", \u0026docker.RemoteImageArgs{\n\t\t\tName: *pulumi.String(ubuntuRegistryImage.Name),\n\t\t\tPullTriggers: pulumi.StringArray{\n\t\t\t\t*pulumi.String(ubuntuRegistryImage.Sha256Digest),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetRegistryImageArgs;\nimport com.pulumi.docker.RemoteImage;\nimport com.pulumi.docker.RemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var ubuntuRegistryImage = DockerFunctions.getRegistryImage(GetRegistryImageArgs.builder()\n            .name(\"ubuntu:precise\")\n            .build());\n\n        var ubuntuRemoteImage = new RemoteImage(\"ubuntuRemoteImage\", RemoteImageArgs.builder()        \n            .name(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.name()))\n            .pullTriggers(ubuntuRegistryImage.applyValue(getRegistryImageResult -\u003e getRegistryImageResult.sha256Digest()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuRemoteImage:\n    type: docker:RemoteImage\n    properties:\n      name: ${ubuntuRegistryImage.name}\n      pullTriggers:\n        - ${ubuntuRegistryImage.sha256Digest}\nvariables:\n  ubuntuRegistryImage:\n    fn::invoke:\n      Function: docker:getRegistryImage\n      Arguments:\n        name: ubuntu:precise\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRegistryImage.\n",
                "properties": {
                    "insecureSkipVerify": {
                        "type": "boolean",
                        "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker image, including any tags. e.g. `alpine:latest`\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRegistryImage.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "insecureSkipVerify": {
                        "type": "boolean",
                        "description": "If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker image, including any tags. e.g. `alpine:latest`\n"
                    },
                    "sha256Digest": {
                        "type": "string",
                        "description": "The content digest of the image, as stored in the registry.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "sha256Digest",
                    "id"
                ]
            }
        },
        "docker:index/getRemoteImage:getRemoteImage": {
            "description": "`docker.RemoteImage` provides details about a specific Docker Image which needs to be present on the Docker Host\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as docker from \"@pulumi/docker\";\n\nconst latest = docker.getRemoteImage({\n    name: \"nginx\",\n});\nconst specific = docker.getRemoteImage({\n    name: \"nginx:1.17.6\",\n});\nconst digest = docker.getRemoteImage({\n    name: \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n});\nconst tagAndDigest = docker.getRemoteImage({\n    name: \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_docker as docker\n\nlatest = docker.get_remote_image(name=\"nginx\")\nspecific = docker.get_remote_image(name=\"nginx:1.17.6\")\ndigest = docker.get_remote_image(name=\"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\ntag_and_digest = docker.get_remote_image(name=\"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Docker = Pulumi.Docker;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var latest = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx\",\n    });\n\n    var specific = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx:1.17.6\",\n    });\n\n    var digest = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n    });\n\n    var tagAndDigest = Docker.GetRemoteImage.Invoke(new()\n    {\n        Name = \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-docker/sdk/v4/go/docker\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := docker.LookupRemoteImage(ctx, \u0026docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, \u0026docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx:1.17.6\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, \u0026docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = docker.LookupRemoteImage(ctx, \u0026docker.LookupRemoteImageArgs{\n\t\t\tName: \"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.docker.DockerFunctions;\nimport com.pulumi.docker.inputs.GetRemoteImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var latest = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx\")\n            .build());\n\n        final var specific = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx:1.17.6\")\n            .build());\n\n        final var digest = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\n            .build());\n\n        final var tagAndDigest = DockerFunctions.getRemoteImage(GetRemoteImageArgs.builder()\n            .name(\"nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  latest:\n    fn::invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx\n  specific:\n    fn::invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx:1.17.6\n  digest:\n    fn::invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\n  tagAndDigest:\n    fn::invoke:\n      Function: docker:getRemoteImage\n      Arguments:\n        name: nginx:1.19.1@sha256:36b74457bccb56fbf8b05f79c85569501b721d4db813b684391d63e02287c0b2\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRemoteImage.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRemoteImage.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Docker image, including any tags or SHA256 repo digests.\n"
                    },
                    "repoDigest": {
                        "type": "string",
                        "description": "The image sha256 digest in the form of `repo[:tag]@sha256:\u003chash\u003e`. It may be empty in the edge case where the local image was pulled from a repo, tagged locally, and then referred to in the data source by that local name/tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "repoDigest",
                    "id"
                ]
            }
        }
    }
}